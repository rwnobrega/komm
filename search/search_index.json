{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to Komm!</p> <p>Komm is an open-source library for Python 3 providing tools for analysis and simulation of analog and digital communication systems. This project is inspired by\u2014but is not meant to be compatible with\u2014the MATLAB\u00ae Communications System Toolbox\u2122. Other sources of inspiration include GNU Radio, CommPy, and SageMath. Komm is licensed under the GNU General Public License v3.0.</p> <p>For installation instructions and source code, please check the project's development page.</p> <p>[!WARNING] Please be advised that this project is currently under development. As such, there may be changes to the project's codebase, including the API.</p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Home</li> <li>Library reference</li> <li>Algebra<ul> <li>BinaryPolynomial</li> <li>BinaryPolynomialFraction</li> <li>FiniteBifield</li> </ul> </li> <li>Channels<ul> <li>AWGNChannel</li> <li>DiscreteMemorylessChannel</li> <li>BinarySymmetricChannel</li> <li>BinaryErasureChannel</li> <li>ZChannel</li> </ul> </li> <li>Error control<ul> <li>Block coding</li> <li>BlockCode</li> <li>SystematicBlockCode</li> <li>CyclicCode</li> <li>HammingCode</li> <li>SimplexCode</li> <li>GolayCode</li> <li>RepetitionCode</li> <li>SingleParityCheckCode</li> <li>CordaroWagnerCode</li> <li>ReedMullerCode</li> <li>BCHCode</li> <li>SlepianArray</li> <li>BlockEncoder</li> <li>BlockDecoder</li> <li>Convolutional coding</li> <li>ConvolutionalCode</li> <li>ConvolutionalStreamEncoder</li> <li>ConvolutionalStreamDecoder</li> <li>TerminatedConvolutionalCode</li> </ul> </li> <li>Finite-state machines<ul> <li>FiniteStateMachine</li> </ul> </li> <li>Modulation<ul> <li>Modulation</li> <li>PAModulation</li> <li>QAModulation</li> <li>ASKModulation</li> <li>PSKModulation</li> <li>APSKModulation</li> </ul> </li> <li>Pulse formatting<ul> <li>Pulses</li> <li>Pulse</li> <li>RectangularPulse</li> <li>ManchesterPulse</li> <li>SincPulse</li> <li>RaisedCosinePulse</li> <li>RootRaisedCosinePulse</li> <li>GaussianPulse</li> <li>Filtering</li> <li>TransmitFilter</li> <li>ReceiveFilter</li> </ul> </li> <li>Sequences<ul> <li>Binary sequences</li> <li>BinarySequence</li> <li>BarkerSequence</li> <li>WalshHadamardSequence</li> <li>LFSRSequence</li> <li>GoldSequence</li> <li>KasamiSequence</li> <li>Complex sequences</li> <li>ComplexSequence</li> <li>ZadoffChuSequence</li> </ul> </li> <li>Source coding<ul> <li>Lossless coding</li> <li>FixedToVariableCode</li> <li>HuffmanCode</li> <li>FixedToVariableEncoder</li> <li>FixedToVariableDecoder</li> <li>VariableToFixedCode</li> <li>TunstallCode</li> <li>VariableToFixedEncoder</li> <li>VariableToFixedDecoder</li> <li>Quantization</li> <li>ScalarQuantizer</li> <li>LloydMaxQuantizer</li> <li>UniformQuantizer</li> </ul> </li> <li>Sources<ul> <li>DiscreteMemorylessSource</li> </ul> </li> <li>Utilities<ul> <li>binlist2int</li> <li>int2binlist</li> <li>pack</li> <li>unpack</li> <li>qfunc</li> <li>qfuncinv</li> <li>acorr</li> <li>cyclic_acorr</li> <li>entropy</li> <li>binary_entropy</li> </ul> </li> </ul>"},{"location":"ref/","title":"Library reference","text":""},{"location":"ref/#algebra","title":"Algebra","text":"<ul> <li><code>BinaryPolynomial</code> \u2013 Binary polynomial.</li> <li><code>BinaryPolynomialFraction</code> \u2013 Binary polynomial fraction.</li> <li><code>FiniteBifield</code> \u2013 Finite field with binary characteristic.</li> </ul>"},{"location":"ref/#channels","title":"Channels","text":"<ul> <li><code>AWGNChannel</code> \u2013 Additive white Gaussian noise (AWGN) channel.</li> <li><code>DiscreteMemorylessChannel</code> \u2013 General discrete memoryless channel (DMC).</li> <li><code>BinarySymmetricChannel</code> \u2013 Binary symmetric channel (BSC).</li> <li><code>BinaryErasureChannel</code> \u2013 Binary erasure channel (BEC).</li> <li><code>ZChannel</code> \u2013 Z-channel.</li> </ul>"},{"location":"ref/#error-control","title":"Error control","text":""},{"location":"ref/#block-coding","title":"Block coding","text":"<ul> <li><code>BlockCode</code> \u2013 General binary linear block code.</li> <li><code>SystematicBlockCode</code> \u2013 Systematic linear block code.</li> <li><code>CyclicCode</code> \u2013 General binary cyclic code.</li> <li><code>HammingCode</code> \u2013 Hamming code.</li> <li><code>SimplexCode</code> \u2013 Simplex (maximum-length) code.</li> <li><code>GolayCode</code> \u2013 Binary Golay code.</li> <li><code>RepetitionCode</code> \u2013 Repetition code.</li> <li><code>SingleParityCheckCode</code> \u2013 Single parity check code.</li> <li><code>CordaroWagnerCode</code> \u2013 Cordaro\u2013Wagner code.</li> <li><code>ReedMullerCode</code> \u2013 Reed\u2013Muller code.</li> <li><code>BCHCode</code> \u2013 Bose\u2013Ray-Chaudhuri\u2013Hocquenghem (BCH) code.</li> <li><code>SlepianArray</code> \u2013 Slepian array (standard array) for a linear block code.</li> <li><code>BlockEncoder</code> \u2013 Encoder for linear block codes.</li> <li><code>BlockDecoder</code> \u2013 Decoder for linear block codes.</li> </ul>"},{"location":"ref/#convolutional-coding","title":"Convolutional coding","text":"<ul> <li><code>ConvolutionalCode</code> \u2013 Binary convolutional code.</li> <li><code>ConvolutionalStreamEncoder</code> \u2013 Convolutional stream encoder.</li> <li><code>ConvolutionalStreamDecoder</code> \u2013 Convolutional stream decoder using Viterbi algorithm.</li> <li><code>TerminatedConvolutionalCode</code> \u2013 Terminated convolutional code.</li> </ul>"},{"location":"ref/#finite-state-machines","title":"Finite-state machines","text":"<ul> <li><code>FiniteStateMachine</code> \u2013 Finite-state machine (Mealy machine).</li> </ul>"},{"location":"ref/#modulation","title":"Modulation","text":"<ul> <li><code>Modulation</code> \u2013 General modulation scheme.</li> <li><code>PAModulation</code> \u2013 Pulse-amplitude modulation (PAM).</li> <li><code>QAModulation</code> \u2013 Quadrature-amplitude modulation (QAM).</li> <li><code>ASKModulation</code> \u2013 Amplitude-shift keying (ASK) modulation.</li> <li><code>PSKModulation</code> \u2013 Phase-shift keying (PSK) modulation.</li> <li><code>APSKModulation</code> \u2013 Amplitude- and phase-shift keying (APSK) modulation.</li> </ul>"},{"location":"ref/#pulse-formatting","title":"Pulse formatting","text":""},{"location":"ref/#pulses","title":"Pulses","text":"<ul> <li><code>Pulse</code> \u2013 General pulse [Not implemented yet].</li> <li><code>RectangularPulse</code> \u2013 Rectangular pulse.</li> <li><code>ManchesterPulse</code> \u2013 Manchester pulse.</li> <li><code>SincPulse</code> \u2013 Sinc pulse.</li> <li><code>RaisedCosinePulse</code> \u2013 Raised cosine pulse.</li> <li><code>RootRaisedCosinePulse</code> \u2013 Root raised cosine pulse.</li> <li><code>GaussianPulse</code> \u2013 Gaussian pulse.</li> </ul>"},{"location":"ref/#filtering","title":"Filtering","text":"<ul> <li><code>TransmitFilter</code> \u2013 Transmit filter (pulse shaping).</li> <li><code>ReceiveFilter</code> \u2013 Receive filter [Not implemented yet].</li> </ul>"},{"location":"ref/#sequences","title":"Sequences","text":""},{"location":"ref/#binary-sequences","title":"Binary sequences","text":"<ul> <li><code>BinarySequence</code> \u2013 General binary sequence.</li> <li><code>BarkerSequence</code> \u2013 Barker sequence.</li> <li><code>WalshHadamardSequence</code> \u2013 Walsh\u2013Hadamard sequence.</li> <li><code>LFSRSequence</code> \u2013 Linear-feedback shift register (LFSR) sequence.</li> <li><code>GoldSequence</code> \u2013 Gold sequence [Not implemented yet].</li> <li><code>KasamiSequence</code> \u2013 Kasami sequence [Not implemented yet].</li> </ul>"},{"location":"ref/#complex-sequences","title":"Complex sequences","text":"<ul> <li><code>ComplexSequence</code> \u2013 General complex sequence.</li> <li><code>ZadoffChuSequence</code> \u2013 Zadoff\u2013Chu sequence.</li> </ul>"},{"location":"ref/#source-coding","title":"Source coding","text":""},{"location":"ref/#lossless-coding","title":"Lossless coding","text":"<ul> <li><code>FixedToVariableCode</code> \u2013 Fixed-to-variable length code.</li> <li><code>HuffmanCode</code> \u2013 Binary Huffman code.</li> <li><code>FixedToVariableEncoder</code> \u2013 Encoder for fixed-to-variable length codes.</li> <li><code>FixedToVariableDecoder</code> \u2013 Decoder for prefix-free fixed-to-variable length codes.</li> <li><code>VariableToFixedCode</code> \u2013 Variable-to-fixed length code.</li> <li><code>TunstallCode</code> \u2013 Binary Tunstall code.</li> <li><code>VariableToFixedEncoder</code> \u2013 Encoder for prefix-free variable-to-fixed length codes.</li> <li><code>VariableToFixedDecoder</code> \u2013 Decoder for variable-to-fixed length codes.</li> </ul>"},{"location":"ref/#quantization","title":"Quantization","text":"<ul> <li><code>ScalarQuantizer</code> \u2013 General scalar quantizer.</li> <li><code>LloydMaxQuantizer</code> \u2013 Lloyd\u2013Max scalar quantizer.</li> <li><code>UniformQuantizer</code> \u2013 Uniform scalar quantizer.</li> </ul>"},{"location":"ref/#sources","title":"Sources","text":"<ul> <li><code>DiscreteMemorylessSource</code> \u2013 Discrete memoryless source (DMS).</li> </ul>"},{"location":"ref/#utilities","title":"Utilities","text":"<ul> <li><code>binlist2int</code> \u2013 Converts a bit array to its integer representation (LSB first).</li> <li><code>int2binlist</code> \u2013 Converts an integer to its bit array representation (LSB first).</li> <li><code>pack</code> \u2013 Packs a given bit array.</li> <li><code>unpack</code> \u2013 Unpacks a given integer array.</li> <li><code>qfunc</code> \u2013 Computes the Gaussian Q-function.</li> <li><code>qfuncinv</code> \u2013 Computes the inverse Gaussian Q-function.</li> <li><code>acorr</code> \u2013 Computes the autocorrelation $R[\\ell]$ of a real or complex sequence $x[n]$.</li> <li><code>cyclic_acorr</code> \u2013 Computes the cyclic autocorrelation $\\tilde{R}[\\ell]$ of a real or complex sequence $x[n]$.</li> <li><code>entropy</code> \u2013 Computes the entropy of a random variable with a given pmf.</li> <li><code>binary_entropy</code> \u2013 Computes the binary entropy function.</li> </ul>"},{"location":"ref/APSKModulation/","title":"komm.APSKModulation","text":"<p>Amplitude- and phase-shift keying (APSK) modulation. It is a complex modulation scheme in which the constellation is the union (concatenation) of component PSK constellations, called rings. More precisely, consider $K$ rings $\\mathbf{X}_k$, for $k \\in [0 : K)$, where the $k$-th ring has order $M_k$, amplitude $A_k$, and phase offset $\\phi_k$. The $i$-th constellation symbol of the $k$-th ring is given by $$     x_{k,i} = A_k \\exp \\left( \\mathrm{j} \\frac{2 \\pi i}{M_k} \\right) \\exp(\\mathrm{j} \\phi_k),     \\quad k \\in [0 : K),     \\quad i \\in [0 : M_k). $$ The resulting APSK constellation is therefore given by $$     \\mathbf{X} = \\begin{bmatrix}         \\mathbf{X}_0 \\\\         \\vdots \\\\         \\mathbf{X}_{K-1}     \\end{bmatrix}, $$ which has order $M = M_0 + M_1 + \\cdots + M_{K-1}$. The order $M_k$ of each ring need not be a power of $2$; however, the order $M$ of the constructed APSK modulation must be. The APSK constellation is depicted below for $(M_0, M_1) = (8, 8)$ with $(A_0, A_1) = (A, 2A)$ and $(\\phi_0, \\phi_1) = (0, \\pi/8)$; and for $(M_0, M_1) = (4, 12)$ with $(A_0, A_1) = (\\sqrt{2}A, 3A)$ and $(\\phi_0, \\phi_1) = (\\pi/4, 0)$.</p> <p> </p>"},{"location":"ref/APSKModulation/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>orders</code> (<code>tuple[int, ...]</code>)         \u2013          <p>A $K$-tuple with the orders $M_k$ of each ring, for $k \\in [0 : K)$. The sum $M_0 + M_1 + \\cdots + M_{K-1}$ must be a power of $2$.</p> </li> <li> <code>amplitudes</code> (<code>tuple[float, ...]</code>)         \u2013          <p>A $K$-tuple with the amplitudes $A_k$ of each ring, for $k \\in [0 : K)$.</p> </li> <li> <code>phase_offsets</code> (<code>Optional[tuple[float, ...] | float]</code>)         \u2013          <p>A $K$-tuple with the phase offsets $\\phi_k$ of each ring, for $k \\in [0 : K)$. If specified as a single float $\\phi$, then it is assumed that $\\phi_k = \\phi$ for all $k \\in [0 : K)$. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling of the modulation. Can be specified either as a 2D-array of integers (see base class for details), or as a string. In the latter case, the string must be equal to <code>'natural'</code>. The default value is <code>'natural'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; apsk = komm.APSKModulation(orders=(8, 8), amplitudes=(1.0, 2.0), phase_offsets=(0.0, np.pi/8))\n&gt;&gt;&gt; apsk.constellation.round(4)\narray([ 1.    +0.j    ,  0.7071+0.7071j,  0.    +1.j    , -0.7071+0.7071j,\n       -1.    +0.j    , -0.7071-0.7071j, -0.    -1.j    ,  0.7071-0.7071j,\n        1.8478+0.7654j,  0.7654+1.8478j, -0.7654+1.8478j, -1.8478+0.7654j,\n       -1.8478-0.7654j, -0.7654-1.8478j,  0.7654-1.8478j,  1.8478-0.7654j])\n</code></pre> <pre><code>&gt;&gt;&gt; apsk = komm.APSKModulation(orders=(4, 12), amplitudes=(np.sqrt(2), 3.0), phase_offsets=(np.pi/4, 0.0))\n&gt;&gt;&gt; apsk.constellation.round(4)\narray([ 1.    +1.j    , -1.    +1.j    , -1.    -1.j    ,  1.    -1.j    ,\n        3.    +0.j    ,  2.5981+1.5j   ,  1.5   +2.5981j,  0.    +3.j    ,\n       -1.5   +2.5981j, -2.5981+1.5j   , -3.    +0.j    , -2.5981-1.5j   ,\n       -1.5   -2.5981j, -0.    -3.j    ,  1.5   -2.5981j,  2.5981-1.5j   ])\n</code></pre>"},{"location":"ref/ASKModulation/","title":"komm.ASKModulation","text":"<p>Amplitude-shift keying (ASK) modulation. It is a complex modulation scheme in which the points of the constellation symbols are uniformly arranged in a ray. More precisely, the $i$-th constellation symbol is given by $$     x_i = iA \\exp(\\mathrm{j}\\phi), \\quad i \\in [0 : M), $$ where $M$ is the order (a power of $2$), $A$ is the base amplitude, and $\\phi$ is the phase offset of the modulation. The ASK constellation is depicted below for $M = 4$.</p> <p></p>"},{"location":"ref/ASKModulation/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>order</code> (<code>int</code>)         \u2013          <p>The order $M$ of the modulation. It must be a power of $2$.</p> </li> <li> <code>base_amplitude</code> (<code>Optional[float]</code>)         \u2013          <p>The base amplitude $A$ of the constellation. The default value is <code>1.0</code>.</p> </li> <li> <code>phase_offset</code> (<code>Optional[float]</code>)         \u2013          <p>The phase offset $\\phi$ of the constellation. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling of the modulation. Can be specified either as a 2D-array of integers (see base class for details), or as a string. In the latter case, the string must be either <code>'natural'</code> or <code>'reflected'</code>. The default value is <code>'reflected'</code>, corresponding to the Gray labeling.</p> </li> </ul> <p>Examples:</p> <p>The ASK modulation with order $M = 4$, base amplitude $A = 1$, and Gray labeling is depicted below.</p> <p></p> <pre><code>&gt;&gt;&gt; ask = komm.ASKModulation(4)\n&gt;&gt;&gt; ask.constellation\narray([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j])\n&gt;&gt;&gt; ask.labeling\narray([[0, 0],\n       [1, 0],\n       [1, 1],\n       [0, 1]])\n&gt;&gt;&gt; ask.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([0.+0.j, 2.+0.j, 0.+0.j, 1.+0.j, 1.+0.j])\n</code></pre>"},{"location":"ref/AWGNChannel/","title":"komm.AWGNChannel","text":"<p>Additive white Gaussian noise (AWGN) channel. It is defined by $$     Y_n = X_n + Z_n, $$ where $X_n$ is the channel input signal, $Y_n$ is the channel output signal, and $Z_n$ is the noise, which is iid according to a Gaussian distribution with zero mean. The channel signal-to-noise ratio is calculated by $$     \\snr = \\frac{P}{N}, $$ where $P = \\mathrm{E}[X^2_n]$ is the average power of the input signal, and $N = \\mathrm{E}[Z^2_n]$ is the average power (and variance) of the noise. For more details, see CT06, Ch. 9.</p> <p>Attributes:</p> <ul> <li> <code>signal_power</code> (<code>float | str</code>)         \u2013          <p>The input signal power $P$. If equal to the string <code>'measured'</code>, then every time the channel is invoked the input signal power will be computed from the input itself (i.e., its squared Euclidean norm).</p> </li> <li> <code>snr</code> (<code>Optional[float]</code>)         \u2013          <p>The channel signal-to-noise ratio $\\snr$ (linear, not decibel). The default value is <code>np.inf</code>, which corresponds to a noiseless channel.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[float]</code>)         \u2013          <p>The input signal $X_n$.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[float]</code>)         \u2013          <p>The output signal $Y_n$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; awgn = komm.AWGNChannel(signal_power=5.0, snr=200.0)\n&gt;&gt;&gt; x = [1.0, 3.0, -3.0, -1.0, -1.0, 1.0, 3.0, 1.0, -1.0, 3.0]\n&gt;&gt;&gt; awgn(x).round(2)\narray([ 1.26,  2.9 , -3.08, -1.17, -0.86,  0.64,  3.28,  0.88, -0.95,  2.96])\n</code></pre>"},{"location":"ref/AWGNChannel/#noise_power","title":"<code>noise_power: float</code>  <code>property</code>","text":"<p>The noise power $N$.</p>"},{"location":"ref/AWGNChannel/#capacity","title":"<code>capacity</code>","text":"<p>Returns the channel capacity $C$. It is given by $C = \\frac{1}{2}\\log_2(1 + \\snr)$, in bits per dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; awgn = komm.AWGNChannel(signal_power=1.0, snr=63.0)\n&gt;&gt;&gt; awgn.capacity()\nnp.float64(3.0)\n</code></pre>"},{"location":"ref/BCHCode/","title":"komm.BCHCode","text":"<p>Bose\u2013Ray-Chaudhuri\u2013Hocquenghem (BCH) code. For given parameters $\\mu \\geq 2$ and $\\delta$ satisfying $2 \\leq \\delta \\leq 2^{\\mu} - 1$, a binary BCH code is a cyclic code with generator polynomial given by $$     g(X) = \\mathrm{lcm} \\left\\{ \\phi_1(X), \\phi_2(X), \\ldots, \\phi_{\\delta - 1}(X) \\right\\}, $$ where $\\phi_i(X)$ is the minimal polynomial of $\\alpha^i$, and $\\alpha$ is a primitive element of $\\mathrm{GF}(2^\\mu)$. The parameter $\\delta$ must be a Bose distance. The resulting code is denoted by $\\bch(\\mu, \\delta)$, and has the following parameters, where $\\delta = 2 \\tau + 1$:</p> <ul> <li>Length: $n = 2^{\\mu} - 1$</li> <li>Dimension: $k \\geq n - \\mu \\tau$</li> <li>Redundancy: $m \\leq \\mu \\tau$</li> <li>Minimum distance: $d \\geq \\delta$</li> </ul> <p>Only narrow-sense and primitive BCH codes are implemented. For more details, see LC04, Ch. 6 and HP03, Sec. 5.1.</p> <p>The table below lists the possible values of $\\delta$ for $2 \\leq \\mu \\leq 10$.</p> $\\mu$ $n$ Bose distances $\\delta$ $2$ $3$ $3$ $3$ $7$ $3$, $7$ $4$ $15$ $3$, $5$, $7$, $15$ $5$ $31$ $3$, $5$, $7$, $11$, $15$, $31$ $6$ $63$ $3$, $5$, $7$, $9$, $11$, $13$, $15$, $21$, $23$, $27$, $31$, $63$ $7$ $127$ $3$, $5$, $7$, $9$, $11$, $13$, $15$, $19$, $21$, $23$, $27$, $29$, $31$, $43$, $47$, $55$, $63$, $127$ $8$ $255$ $3$, $5$, $7$, $9$, $11$, $13$, $15$, $17$, $19$, $21$, $23$, $25$, $27$, $29$, $31$, $37$, $39$, $43$, $45$, $47$, $51$, $53$, $55$, $59$, $61$, $63$, $85$, $87$, $91$, $95$, $111$, $119$, $127$, $255$ $9$ $511$ $3$, $5$, $7$, $9$, $11$, $13$, $15$, $17$, $19$, $21$, $23$, $25$, $27$, $29$, $31$, $35$, $37$, $39$, $41$, $43$, $45$, $47$, $51$, $53$, $55$, $57$, $59$, $61$, $63$, $73$, $75$, $77$, $79$, $83$, $85$, $87$, $91$, $93$, $95$, $103$, $107$, $109$, $111$, $117$, $119$, $123$, $125$, $127$, $171$, $175$, $183$, $187$, $191$, $219$, $223$, $239$, $255$, $511$ $10$ $1023$ $3$, $5$, $7$, $9$, $11$, $13$, $15$, $17$, $19$, $21$, $23$, $25$, $27$, $29$, $31$, $33$, $35$, $37$, $39$, $41$, $43$, $45$, $47$, $49$, $51$, $53$, $55$, $57$, $59$, $61$, $63$, $69$, $71$, $73$, $75$, $77$, $79$, $83$, $85$, $87$, $89$, $91$, $93$, $95$, $99$, $101$, $103$, $105$, $107$, $109$, $111$, $115$, $117$, $119$, $121$, $123$, $125$, $127$, $147$, $149$, $151$, $155$, $157$, $159$, $165$, $167$, $171$, $173$, $175$, $179$, $181$, $183$, $187$, $189$, $191$, $205$, $207$, $213$, $215$, $219$, $221$, $223$, $231$, $235$, $237$, $239$, $245$, $247$, $251$, $253$, $255$, $341$, $343$, $347$, $351$, $363$, $367$, $375$, $379$, $383$, $439$, $447$, $479$, $495$, $511$, $1023$ Notes <ul> <li>For $\\delta = 3$ it reduces to the Hamming code.</li> <li>For $\\delta = 2^{\\mu} - 1$ it reduces to the repetition code.</li> </ul> <p>Attributes:</p> <ul> <li> <code>mu</code> (<code>int</code>)         \u2013          <p>The parameter $\\mu$ of the BCH code.</p> </li> <li> <code>delta</code> (<code>int</code>)         \u2013          <p>The Bose distance $\\delta$ of the BCH code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BCHCode(mu=5, delta=7)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(31, 16, 15)\n&gt;&gt;&gt; code.generator_polynomial\nBinaryPolynomial(0b1000111110101111)\n&gt;&gt;&gt; code.minimum_distance()\n7\n</code></pre> <pre><code>&gt;&gt;&gt; komm.BCHCode(mu=7, delta=31)\nBCHCode(mu=7, delta=31)\n</code></pre> <pre><code>&gt;&gt;&gt; komm.BCHCode(mu=7, delta=32)\nTraceback (most recent call last):\n...\nValueError: 'delta' must be a Bose distance (the next one is 43)\n</code></pre> <pre><code>&gt;&gt;&gt; komm.BCHCode(mu=7, delta=43)\nBCHCode(mu=7, delta=43)\n</code></pre>"},{"location":"ref/BarkerSequence/","title":"komm.BarkerSequence","text":"<p>Barker sequence. A Barker sequence is a binary sequence with autocorrelation $R[\\ell]$ satisfying $|R[\\ell]| \\leq 1$, for $\\ell \\neq 0$. The only known Barker sequences (up to negation and reversion) are shown in the table below.</p> Length $L$ Barker sequence $b[n]$ $2$ $01$ and $00$ $3$ $001$ $4$ $0010$ and $0001$ $5$ $00010$ $7$ $0001101$ $11$ $00011101101$ $13$ $0000011001010$ References <ol> <li>https://en.wikipedia.org/wiki/Barker_code</li> </ol>"},{"location":"ref/BarkerSequence/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>length</code> (<code>int</code>)         \u2013          <p>Length of the Barker sequence. Must be in the set $\\{ 2, 3, 4, 5, 7, 11, 13 \\}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; barker = komm.BarkerSequence(length=13)\n&gt;&gt;&gt; barker.polar_sequence\narray([ 1,  1,  1,  1,  1, -1, -1,  1,  1, -1,  1, -1,  1])\n&gt;&gt;&gt; barker.autocorrelation()\narray([13,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1])\n</code></pre>"},{"location":"ref/BinaryErasureChannel/","title":"komm.BinaryErasureChannel","text":"<p>Binary erasure channel (BEC). It is a discrete memoryless channel with input alphabet $\\mathcal{X} = \\{ 0, 1 \\}$ and output alphabet $\\mathcal{Y} = \\{ 0, 1, 2 \\}$. The channel is characterized by a parameter $\\epsilon$, called the erasure probability. With probability $1 - \\epsilon$, the output symbol is identical to the input symbol, and with probability $\\epsilon$, the output symbol is replaced by an erasure symbol (denoted by $2$). For more details, see CT06, Sec. 7.1.5.</p> <p>Attributes:</p> <ul> <li> <code>erasure_probability</code> (<code>Optional[float]</code>)         \u2013          <p>The channel erasure probability $\\epsilon$. Must satisfy $0 \\leq \\epsilon \\leq 1$. Default value is <code>0.0</code>, which corresponds to a noiseless channel.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>input_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The input sequence.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>output_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The output sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; bec = komm.BinaryErasureChannel(0.1)\n&gt;&gt;&gt; bec([1, 1, 1, 0, 0, 0, 1, 0, 1, 0])\narray([1, 1, 2, 0, 0, 2, 1, 0, 1, 0])\n</code></pre>"},{"location":"ref/BinaryErasureChannel/#transition_matrix","title":"<code>transition_matrix: npt.NDArray[np.float64]</code>  <code>property</code>","text":"<p>The transition probability matrix of the channel, given by $$     p_{Y \\mid X} =     \\begin{bmatrix}         1 - \\epsilon &amp; 0 &amp; \\epsilon \\\\         0 &amp; 1 - \\epsilon &amp; \\epsilon     \\end{bmatrix}. $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bec = komm.BinaryErasureChannel(0.1)\n&gt;&gt;&gt; bec.transition_matrix\narray([[0.9, 0. , 0.1],\n       [0. , 0.9, 0.1]])\n</code></pre>"},{"location":"ref/BinaryErasureChannel/#mutual_information","title":"<code>mutual_information</code>","text":"<p>Returns the mutual information $\\mathrm{I}(X ; Y)$ between the input $X$ and the output $Y$ of the channel. It is given by $$     \\mathrm{I}(X ; Y) = (1 - \\epsilon) \\, \\Hb(\\pi), $$ in bits, where $\\pi = \\Pr[X = 1]$, and $\\Hb$ is the binary entropy function.</p> <p>Parameters:</p> <p>Same as the corresponding method of the general class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bec = komm.BinaryErasureChannel(0.1)\n&gt;&gt;&gt; bec.mutual_information([0.45, 0.55])\nnp.float64(0.8934970085890275)\n</code></pre>"},{"location":"ref/BinaryErasureChannel/#capacity","title":"<code>capacity</code>","text":"<p>Returns the channel capacity $C$. It is given by $$     C = 1 - \\epsilon, $$ in bits.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bec = komm.BinaryErasureChannel(0.1)\n&gt;&gt;&gt; bec.capacity()\nnp.float64(0.9)\n</code></pre>"},{"location":"ref/BinaryPolynomial/","title":"komm.BinaryPolynomial","text":"<p>Binary polynomial. A binary polynomial is a polynomial whose coefficients are elements in the finite field $\\mathbb{F}_2 = \\{ 0, 1 \\}$.</p> <p>The default constructor of the class expects the following:</p> <p>Attributes:</p> <ul> <li> <code>value</code> (<code>int</code>)         \u2013          <p>An integer whose binary digits represent the coefficients of the polynomial\u2014the leftmost bit standing for the highest degree term. For example, the binary polynomial $X^4 + X^3 + X$ is represented by the integer <code>0b11010</code> = <code>0o32</code> = <code>26</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\nBinaryPolynomial(0b11010)\n</code></pre> <p>See also the class methods <code>from_coefficients</code> and <code>from_exponents</code> for alternative ways to construct a binary polynomial.</p> Algebraic structure <p>The binary polynomials form an Euclidean domain. The following operations are supported: addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), euclidean division (<code>//</code>), modulo (<code>%</code>), and exponentiation (<code>**</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly1 = komm.BinaryPolynomial(0b10111)  # X^4 + X^2 + X + 1\n&gt;&gt;&gt; poly2 = komm.BinaryPolynomial(0b101)  # X^2 + 1\n&gt;&gt;&gt; poly1 + poly2  # X^4 + X\nBinaryPolynomial(0b10010)\n&gt;&gt;&gt; poly1 - poly2  # X^4 + X\nBinaryPolynomial(0b10010)\n&gt;&gt;&gt; poly1 * poly2  # X^6 + X^3 + X + 1\nBinaryPolynomial(0b1001011)\n&gt;&gt;&gt; poly1 // poly2  # X^2\nBinaryPolynomial(0b100)\n&gt;&gt;&gt; poly1 % poly2  # X + 1\nBinaryPolynomial(0b11)\n&gt;&gt;&gt; poly1 ** 2  # X^8 + X^4 + X^2 + 1\nBinaryPolynomial(0b100010101)\n</code></pre>"},{"location":"ref/BinaryPolynomial/#from_coefficients","title":"<code>from_coefficients</code>  <code>classmethod</code>","text":"<p>Constructs a binary polynomial from its coefficients.</p> <p>Parameters:</p> <ul> <li> <code>coefficients</code> (<code>Array1D[int]</code>)         \u2013          <p>The coefficients of the binary polynomial\u2014the $i$-th element of the array standing for the coefficient of $X^i$. For example, <code>[0, 1, 0, 1, 1]</code> represents the binary polynomial $X^4 + X^3 + X$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.BinaryPolynomial.from_coefficients([0, 1, 0, 1, 1])  # X^4 + X^3 + X\nBinaryPolynomial(0b11010)\n</code></pre>"},{"location":"ref/BinaryPolynomial/#from_exponents","title":"<code>from_exponents</code>  <code>classmethod</code>","text":"<p>Constructs a binary polynomial from its exponents.</p> <p>Parameters:</p> <ul> <li> <code>exponents</code> (<code>Array1D[int]</code>)         \u2013          <p>The exponents of the nonzero terms of the binary polynomial. For example, <code>[1, 3, 4]</code> represents the binary polynomial $X^4 + X^3 + X$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.BinaryPolynomial.from_exponents([1, 3, 4])  # X^4 + X^3 + X\nBinaryPolynomial(0b11010)\n</code></pre>"},{"location":"ref/BinaryPolynomial/#degree","title":"<code>degree: int</code>  <code>property</code>","text":"<p>The degree of the polynomial.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.degree\n4\n</code></pre>"},{"location":"ref/BinaryPolynomial/#coefficients","title":"<code>coefficients</code>","text":"<p>Returns the coefficients of the binary polynomial.</p> <p>Parameters:</p> <ul> <li> <code>width</code> (<code>Optional[int]</code>)         \u2013          <p>If this parameter is specified, the output will be filled with zeros on the right so that the its length will be the specified value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>coefficients</code>  (<code>Array1D[int]</code>)          \u2013          <p>Coefficients of the binary polynomial. The $i$-th element of the array stands for the coefficient of $X^i$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.coefficients()\narray([0, 1, 0, 1, 1])\n&gt;&gt;&gt; poly.coefficients(width=8)\narray([0, 1, 0, 1, 1, 0, 0, 0])\n</code></pre>"},{"location":"ref/BinaryPolynomial/#exponents","title":"<code>exponents</code>","text":"<p>Returns the exponents of the binary polynomial.</p> <p>Returns:</p> <ul> <li> <code>exponents</code>  (<code>Array1D[int]</code>)          \u2013          <p>Exponents of the nonzero terms of the binary polynomial. The exponents are returned in ascending order.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.exponents()\narray([1, 3, 4])\n</code></pre>"},{"location":"ref/BinaryPolynomial/#evaluate","title":"<code>evaluate</code>","text":"<p>Evaluates the polynomial at a given point. Uses Horner's method.</p> <p>Parameters:</p> <ul> <li> <code>point</code> (<code>RingElement</code>)         \u2013          <p>The point at which the polynomial is evaluated. It must be an element of a ring in which multiplication by integers is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>result</code>  (<code>RingElement</code>)          \u2013          <p>The result of evaluating the binary polynomial at <code>point</code>. It has the same type as <code>point</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.evaluate(komm.Integer(7))  # same as 7**4 + 7**3 + 7\nInteger(value=2751)\n</code></pre>"},{"location":"ref/BinaryPolynomial/#xgcd","title":"<code>xgcd</code>  <code>classmethod</code>","text":"<p>Performs the extended Euclidean algorithm on two given binary polynomials.</p>"},{"location":"ref/BinaryPolynomial/#gcd","title":"<code>gcd</code>  <code>classmethod</code>","text":"<p>Computes the greatest common divisor (gcd) of the arguments.</p>"},{"location":"ref/BinaryPolynomial/#lcm","title":"<code>lcm</code>  <code>classmethod</code>","text":"<p>Computes the least common multiple (lcm) of the arguments.</p>"},{"location":"ref/BinaryPolynomialFraction/","title":"komm.BinaryPolynomialFraction","text":"<p>Binary polynomial fraction. A binary polynomial fraction is a ratio of two binary polynomials.</p> <p>Attributes:</p> <ul> <li> <code>numerator</code> (<code>BinaryPolynomial</code>)         \u2013          <p>The numerator of the fraction.</p> </li> <li> <code>denominator</code> (<code>BinaryPolynomial</code>)         \u2013          <p>The denominator of the fraction.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.BinaryPolynomialFraction(0b11010, 0b101)  # (X^4 + X^3 + X) / (X^2 + 1)\nBinaryPolynomialFraction(0b11010, 0b101)\n</code></pre> Algebraic structure <p>The binary polynomial fractions form a field. The following operations are supported: addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and exponentiation (<code>**</code>).</p>"},{"location":"ref/BinarySequence/","title":"komm.BinarySequence","text":"<p>General binary sequence. It may be represented either in bit format, denoted by $b[n]$, with elements in the set $\\{ 0, 1 \\}$, or in polar format, denoted by $x[n]$, with elements in the set $\\{ \\pm 1 \\}$. The correspondences $0 \\mapsto +1$ and $1 \\mapsto -1$ from bit format to polar format is assumed.</p>"},{"location":"ref/BinarySequence/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class. It expects exactly one the following parameters:</p> <p>Parameters:</p> <ul> <li> <code>bit_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The binary sequence in bit format. Must be a 1D-array with elements in $\\{ 0, 1 \\}$.</p> </li> <li> <code>polar_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The binary sequence in polar format. Must be a 1D-array with elements in $\\{ \\pm 1 \\}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; seq = komm.BinarySequence(bit_sequence=[0, 1, 1, 0])\n&gt;&gt;&gt; seq.bit_sequence\narray([0, 1, 1, 0])\n&gt;&gt;&gt; seq.polar_sequence\narray([ 1, -1, -1,  1])\n</code></pre> <pre><code>&gt;&gt;&gt; seq = komm.BinarySequence(polar_sequence=[1, -1, -1, 1])\n&gt;&gt;&gt; seq.bit_sequence\narray([0, 1, 1, 0])\n&gt;&gt;&gt; seq.polar_sequence\narray([ 1, -1, -1,  1])\n</code></pre>"},{"location":"ref/BinarySequence/#bit_sequence","title":"<code>bit_sequence</code>  <code>property</code>","text":"<p>The binary sequence in bit format, $b[n] \\in \\{ 0, 1 \\}$.</p>"},{"location":"ref/BinarySequence/#polar_sequence","title":"<code>polar_sequence</code>  <code>property</code>","text":"<p>The binary sequence in polar format, $x[n] \\in \\{ \\pm 1 \\}$.</p>"},{"location":"ref/BinarySequence/#length","title":"<code>length</code>  <code>property</code>","text":"<p>The length (or period) $L$ of the binary sequence.</p>"},{"location":"ref/BinarySequence/#autocorrelation","title":"<code>autocorrelation</code>","text":"<p>Returns the autocorrelation $R[\\ell]$ of the binary sequence in polar format. See <code>komm.autocorrelation</code> for more details.</p> <p>Parameters:</p> <ul> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>See <code>komm.autocorrelation</code>. The default value yields $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>See <code>komm.autocorrelation</code>. The default value is <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>autocorrelation</code>  (<code>Array1D[complex]</code>)          \u2013          <p>The autocorrelation $R[\\ell]$ of the complex sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; seq = komm.BinarySequence(bit_sequence=[0, 1, 1, 0])\n&gt;&gt;&gt; seq.autocorrelation()\narray([ 4, -1, -2,  1])\n</code></pre>"},{"location":"ref/BinarySequence/#cyclic_autocorrelation","title":"<code>cyclic_autocorrelation</code>","text":"<p>Returns the cyclic autocorrelation $\\tilde{R}[\\ell]$ of the binary sequence in polar format. See <code>komm.cyclic_autocorrelation</code> for more details.</p> <p>Parameters:</p> <ul> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>See <code>komm.cyclic_autocorrelation</code>. The default value yields $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>See <code>komm.cyclic_autocorrelation</code>. The default value is <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cyclic_autocorrelation</code>  (<code>Array1D[complex]</code>)          \u2013          <p>The cyclic autocorrelation $\\tilde{R}[\\ell]$ of the complex sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; seq = komm.BinarySequence(bit_sequence=[0, 1, 1, 0])\n&gt;&gt;&gt; seq.cyclic_autocorrelation()\narray([ 4,  0, -4,  0])\n</code></pre>"},{"location":"ref/BinarySymmetricChannel/","title":"komm.BinarySymmetricChannel","text":"<p>Binary symmetric channel (BSC). It is a discrete memoryless channel with input and output alphabets $\\mathcal{X} = \\mathcal{Y} = \\{ 0, 1 \\}$. The channel is characterized by a parameter $p$, called the crossover probability. With probability $1 - p$, the output symbol is identical to the input symbol, and with probability $p$, the output symbol is flipped. Equivalently, the channel can be modeled as $$     Y_n = X_n + Z_n, $$ where $Z_n$ are iid Bernoulli random variables with $\\Pr[Z_n = 1] = p$. For more details, see CT06, Sec. 7.1.4.</p> <p>Attributes:</p> <ul> <li> <code>crossover_probability</code> (<code>Optional[float]</code>)         \u2013          <p>The channel crossover probability $p$. Must satisfy $0 \\leq p \\leq 1$. The default value is <code>0.0</code>, which corresponds to a noiseless channel.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>input_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The input sequence.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>output_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The output sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; bsc = komm.BinarySymmetricChannel(0.1)\n&gt;&gt;&gt; bsc([0, 1, 1, 1, 0, 0, 0, 0, 0, 1])\narray([0, 1, 0, 1, 0, 1, 0, 0, 0, 1])\n</code></pre>"},{"location":"ref/BinarySymmetricChannel/#transition_matrix","title":"<code>transition_matrix: npt.NDArray[np.float64]</code>  <code>property</code>","text":"<p>The transition probability matrix of the channel. It is given by $$     p_{Y \\mid X} = \\begin{bmatrix} 1-p &amp; p \\\\ p &amp; 1-p \\end{bmatrix}. $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bsc = komm.BinarySymmetricChannel(0.1)\n&gt;&gt;&gt; bsc.transition_matrix\narray([[0.9, 0.1],\n       [0.1, 0.9]])\n</code></pre>"},{"location":"ref/BinarySymmetricChannel/#mutual_information","title":"<code>mutual_information</code>","text":"<p>Returns the mutual information $\\mathrm{I}(X ; Y)$ between the input $X$ and the output $Y$ of the channel. It is given by $$     \\mathrm{I}(X ; Y) = \\Hb(p + \\pi - 2 p \\pi) - \\Hb(p), $$ in bits, where $\\pi = \\Pr[X = 1]$, and $\\Hb$ is the binary entropy function.</p> <p>Parameters:</p> <p>Same as the corresponding method of the general class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bsc = komm.BinarySymmetricChannel(0.1)\n&gt;&gt;&gt; bsc.mutual_information([0.45, 0.55])\nnp.float64(0.5263828452309445)\n</code></pre>"},{"location":"ref/BinarySymmetricChannel/#capacity","title":"<code>capacity</code>","text":"<p>Returns the channel capacity $C$. It is given by $$     C = 1 - \\Hb(p), $$ in bits, where $\\Hb$ is the binary entropy function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bsc = komm.BinarySymmetricChannel(0.1)\n&gt;&gt;&gt; bsc.capacity()\nnp.float64(0.5310044064107188)\n</code></pre>"},{"location":"ref/BlockCode/","title":"komm.BlockCode","text":"<p>General binary linear block code. It is characterized by its generator matrix $G \\in \\mathbb{B}^{k \\times n}$, and by its check matrix $H \\in \\mathbb{B}^{m \\times n}$, which are related by $G H^\\transpose = 0$. The parameters $n$, $k$, and $m$ are called the code length, dimension, and redundancy, respectively, and are related by $k + m = n$. For more details, see LC04, Ch. 3.</p> <p>The constructor expects either the generator matrix or the check matrix.</p> <p>Parameters:</p> <ul> <li> <code>generator_matrix</code> (<code>Array2D[int]</code>)         \u2013          <p>The generator matrix $G$ of the code, which is a $k \\times n$ binary matrix.</p> </li> <li> <code>check_matrix</code> (<code>Array2D[int]</code>)         \u2013          <p>The check matrix $H$ of the code, which is a $m \\times n$ binary matrix.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.check_matrix\narray([[0, 1, 1, 1, 0, 0],\n       [1, 0, 1, 0, 1, 0],\n       [1, 1, 0, 0, 0, 1]])\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(check_matrix=[[0, 1, 1, 1, 0, 0], [1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1]])\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.check_matrix\narray([[0, 1, 1, 1, 0, 0],\n       [1, 0, 1, 0, 1, 0],\n       [1, 1, 0, 0, 0, 1]])\n</code></pre>"},{"location":"ref/BlockCode/#length","title":"<code>length: int</code>  <code>property</code>","text":"<p>The length $n$ of the code.</p>"},{"location":"ref/BlockCode/#dimension","title":"<code>dimension: int</code>  <code>property</code>","text":"<p>The dimension $k$ of the code.</p>"},{"location":"ref/BlockCode/#redundancy","title":"<code>redundancy: int</code>  <code>property</code>","text":"<p>The redundancy $m$ of the code.</p>"},{"location":"ref/BlockCode/#rate","title":"<code>rate: float</code>  <code>property</code>","text":"<p>The rate $R = k/n$ of the code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.rate\n0.5\n</code></pre>"},{"location":"ref/BlockCode/#enc_mapping","title":"<code>enc_mapping</code>","text":"<p>The encoding mapping $\\Enc : \\mathbb{B}^k \\to \\mathbb{B}^n$ of the code. This is a function that takes a message $u \\in \\mathbb{B}^k$ and returns the corresponding codeword $v \\in \\mathbb{B}^n$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; enc_mapping = code.enc_mapping\n&gt;&gt;&gt; enc_mapping([1, 0, 1])\narray([1, 0, 1, 1, 0, 1])\n</code></pre>"},{"location":"ref/BlockCode/#inv_enc_mapping","title":"<code>inv_enc_mapping</code>","text":"<p>The inverse encoding mapping $\\Enc^{-1} : \\mathbb{B}^n \\to \\mathbb{B}^k$ of the code. This is a function that takes a codeword $v \\in \\mathbb{B}^n$ and returns the corresponding message $u \\in \\mathbb{B}^k$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; inv_enc_mapping = code.inv_enc_mapping\n&gt;&gt;&gt; inv_enc_mapping([1, 0, 1, 1, 0, 1])\narray([1, 0, 1])\n</code></pre>"},{"location":"ref/BlockCode/#chk_mapping","title":"<code>chk_mapping</code>","text":"<p>The check mapping $\\mathrm{Chk}: \\mathbb{B}^n \\to \\mathbb{B}^m$ of the code. This is a function that takes a received word $r \\in \\mathbb{B}^n$ and returns the corresponding syndrome $s \\in \\mathbb{B}^m$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; chk_mapping = code.chk_mapping\n&gt;&gt;&gt; chk_mapping([1, 0, 1, 1, 0, 1])\narray([0, 0, 0])\n</code></pre>"},{"location":"ref/BlockCode/#codewords","title":"<code>codewords</code>  <code>cached</code>","text":"<p>Returns the codewords of the code. This is a $2^k \\times n$ matrix whose rows are all the codewords. The codeword in row $i$ corresponds to the message obtained by expressing $i$ in binary with $k$ bits (MSB in the right).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.codewords()\narray([[0, 0, 0, 0, 0, 0],\n       [1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [1, 1, 0, 1, 1, 0],\n       [0, 0, 1, 1, 1, 0],\n       [1, 0, 1, 1, 0, 1],\n       [0, 1, 1, 0, 1, 1],\n       [1, 1, 1, 0, 0, 0]])\n</code></pre>"},{"location":"ref/BlockCode/#codeword_weight_distribution","title":"<code>codeword_weight_distribution</code>  <code>cached</code>","text":"<p>Returns the codeword weight distribution of the code. This is an array of shape $(n + 1)$ in which element in position $w$ is equal to the number of codewords of Hamming weight $w$, for $w \\in [0 : n]$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.codeword_weight_distribution()\narray([1, 0, 0, 4, 3, 0, 0])\n</code></pre>"},{"location":"ref/BlockCode/#minimum_distance","title":"<code>minimum_distance</code>  <code>cached</code>","text":"<p>Returns the minimum distance $d$ of the code. This is equal to the minimum Hamming weight of the non-zero codewords.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.minimum_distance()\n3\n</code></pre>"},{"location":"ref/BlockCode/#coset_leaders","title":"<code>coset_leaders</code>  <code>cached</code>","text":"<p>Returns the coset leaders of the code. This is a $2^m \\times n$ matrix whose rows are all the coset leaders. The coset leader in row $i$ corresponds to the syndrome obtained by expressing $i$ in binary with $m$ bits (MSB in the right), and whose Hamming weight is minimal. This may be used as a LUT for syndrome-based decoding.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.coset_leaders()\narray([[0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 1, 0],\n       [0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1],\n       [0, 1, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0, 0],\n       [1, 0, 0, 1, 0, 0]])\n</code></pre>"},{"location":"ref/BlockCode/#coset_leader_weight_distribution","title":"<code>coset_leader_weight_distribution</code>  <code>cached</code>","text":"<p>Returns the coset leader weight distribution of the code. This is an array of shape $(n + 1)$ in which element in position $w$ is equal to the number of coset leaders of weight $w$, for $w \\in [0 : n]$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.coset_leader_weight_distribution()\narray([1, 6, 1, 0, 0, 0, 0])\n</code></pre>"},{"location":"ref/BlockCode/#packing_radius","title":"<code>packing_radius</code>  <code>cached</code>","text":"<p>Returns the packing radius of the code. This is also called the error-correcting capability of the code, and is equal to $\\lfloor (d - 1) / 2 \\rfloor$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.packing_radius()\n1\n</code></pre>"},{"location":"ref/BlockCode/#covering_radius","title":"<code>covering_radius</code>  <code>cached</code>","text":"<p>Returns the covering radius of the code. This is equal to the maximum Hamming weight of the coset leaders.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.covering_radius()\n2\n</code></pre>"},{"location":"ref/BlockDecoder/","title":"komm.BlockDecoder","text":"<p>Decoder for linear block codes.</p> <p>Attributes:</p> <ul> <li> <code>code</code> (<code>BlockCode</code>)         \u2013          <p>The block code to be considered.</p> </li> <li> <code>method</code> (<code>Literal['bcjr', 'berlekamp', 'exhaustive-search-hard', 'exhaustive-search-soft', 'majority-logic-repetition-code', 'meggitt', 'reed', 'syndrome-table', 'viterbi-hard', 'viterbi-soft', 'wagner', 'weighted-reed'] | None</code>)         \u2013          <p>The identifier of the method to be used for decoding. The default corresponds to <code>code.default_decoder</code>.</p> </li> <li> <code>decoder_kwargs</code> (<code>dict[str, Any]</code>)         \u2013          <p>Additional keyword arguments to be passed to the decoder.</p> </li> </ul> Notes <ul> <li>To see the default decoding method for a given code, use <code>code.default_decoder</code>; to see the available decoding methods for a given code, use <code>code.supported_decoders()</code>.</li> </ul> Available decoding methods <p><code>bcjr</code>: Bahl\u2013Cocke\u2013Jelinek\u2013Raviv (BCJR)</p> <ul> <li>Input type: soft</li> <li>Output type: soft</li> <li>Target: message</li> <li>Supported by: <code>TerminatedConvolutionalCode</code>.</li> </ul> <p><code>berlekamp</code>: Berlekamp decoder</p> <ul> <li>Input type: hard</li> <li>Output type: hard</li> <li>Target: codeword</li> <li>Supported by: <code>BCHCode</code>.</li> </ul> <p><code>exhaustive-search-hard</code>: Exhaustive search (hard-decision). Minimum Hamming distance decoder</p> <ul> <li>Input type: hard</li> <li>Output type: hard</li> <li>Target: codeword</li> <li>Supported by: All codes.</li> </ul> <p><code>exhaustive-search-soft</code>: Exhaustive search (soft-decision). Minimum Euclidean distance decoder</p> <ul> <li>Input type: soft</li> <li>Output type: hard</li> <li>Target: codeword</li> <li>Supported by: All codes.</li> </ul> <p><code>majority-logic-repetition-code</code>: Majority-logic decoder. A hard-decision decoder for Repetition codes only.</p> <ul> <li>Input type: hard</li> <li>Output type: hard</li> <li>Target: message</li> <li>Supported by: <code>RepetitionCode</code>.</li> </ul> <p><code>meggitt</code>: Meggitt decoder</p> <ul> <li>Input type: hard</li> <li>Output type: hard</li> <li>Target: codeword</li> <li>Supported by: <code>BCHCode</code>, <code>CyclicCode</code>.</li> </ul> <p><code>reed</code>: Reed decoding algorithm for Reed\u2013Muller codes. It's a majority-logic decoding algorithm.</p> <ul> <li>Input type: hard</li> <li>Output type: hard</li> <li>Target: message</li> <li>Supported by: <code>ReedMullerCode</code>.</li> </ul> <p><code>syndrome-table</code>: Syndrome table decoder</p> <ul> <li>Input type: hard</li> <li>Output type: hard</li> <li>Target: codeword</li> <li>Supported by: All codes.</li> </ul> <p><code>viterbi-hard</code>: Viterbi (hard-decision)</p> <ul> <li>Input type: hard</li> <li>Output type: hard</li> <li>Target: message</li> <li>Supported by: <code>TerminatedConvolutionalCode</code>.</li> </ul> <p><code>viterbi-soft</code>: Viterbi (soft-decision)</p> <ul> <li>Input type: soft</li> <li>Output type: hard</li> <li>Target: message</li> <li>Supported by: <code>TerminatedConvolutionalCode</code>.</li> </ul> <p><code>wagner</code>: Wagner decoder. A soft-decision decoder for SingleParityCheck codes only.</p> <ul> <li>Input type: soft</li> <li>Output type: hard</li> <li>Target: codeword</li> <li>Supported by: <code>SingleParityCheckCode</code>.</li> </ul> <p><code>weighted-reed</code>: Weighted Reed decoding algorithm for Reed\u2013Muller codes.</p> <ul> <li>Input type: soft</li> <li>Output type: hard</li> <li>Target: message</li> <li>Supported by: <code>ReedMullerCode</code>.</li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int] | Array1D[float]</code>)         \u2013          <p>The (hard or soft) bit sequence to be decoded. Its length must be a multiple of the code's block length $n$.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The decoded bit sequence. Its length is a multiple of the code's dimension $k$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.HammingCode(3)\n&gt;&gt;&gt; code.default_decoder\n'syndrome-table'\n&gt;&gt;&gt; code.supported_decoders()\n['exhaustive-search-hard', 'exhaustive-search-soft', 'syndrome-table']\n</code></pre> <pre><code>&gt;&gt;&gt; decoder = komm.BlockDecoder(code)\n&gt;&gt;&gt; decoder([1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0])\narray([1, 1, 0, 0, 1, 0, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; decoder = komm.BlockDecoder(code, method='exhaustive-search-soft')\n&gt;&gt;&gt; decoder([-0.98, -0.85, 1.07, -0.78, 1.11, -0.95, -1.16, -0.87, 1.11, -0.83, -0.95, 0.94, 1.07, 0.91])\narray([1, 1, 0, 0, 1, 0, 1, 1])\n</code></pre>"},{"location":"ref/BlockEncoder/","title":"komm.BlockEncoder","text":"<p>Encoder for linear block codes.</p> <p>Attributes:</p> <ul> <li> <code>code</code> (<code>BlockCode</code>)         \u2013          <p>The block code to be considered.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int]</code>)         \u2013          <p>The bit sequence to be encoded. Its length must be a multiple of the code's dimension $k$.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The encoded bit sequence. Its length is a multiple of the code's block length $n$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.HammingCode(3)\n&gt;&gt;&gt; encoder = komm.BlockEncoder(code)\n&gt;&gt;&gt; encoder([1, 1, 0, 0, 1, 0, 1, 1])\narray([1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0])\n</code></pre>"},{"location":"ref/ComplexSequence/","title":"komm.ComplexSequence","text":"<p>General complex sequence. It is denoted by $x[n]$, with elements in $\\mathbb{C}$. Its length (or period) is denoted by $L$.</p>"},{"location":"ref/ComplexSequence/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>sequence</code> (<code>Array1D[complex]</code>)         \u2013          <p>The complex sequence. Must be a 1D-array of length $L$ with elements in $\\mathbb{C}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; seq = ComplexSequence([1, 1j, -1, -1j])\n&gt;&gt;&gt; seq.sequence\narray([ 1.+0.j,  0.+1.j, -1.+0.j, -0.-1.j])\n</code></pre>"},{"location":"ref/ComplexSequence/#sequence","title":"<code>sequence</code>  <code>property</code>","text":"<p>The complex sequence $x[n]$.</p>"},{"location":"ref/ComplexSequence/#length","title":"<code>length</code>  <code>property</code>","text":"<p>The length (or period) $L$ of the complex sequence.</p>"},{"location":"ref/ComplexSequence/#autocorrelation","title":"<code>autocorrelation</code>","text":"<p>Returns the autocorrelation $R[\\ell]$ of the complex sequence. See <code>komm.autocorrelation</code> for more details.</p> <p>Parameters:</p> <ul> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>See <code>komm.autocorrelation</code>. The default value yields $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>See <code>komm.autocorrelation</code>. The default value is <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>autocorrelation</code>  (<code>Array1D[complex]</code>)          \u2013          <p>The autocorrelation $R[\\ell]$ of the complex sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; seq = ComplexSequence([1, 1j, -1, -1j])\n&gt;&gt;&gt; seq.autocorrelation(shifts=[-2, -1, 0, 1, 2])\narray([-2.+0.j,  0.-3.j,  4.+0.j,  0.+3.j, -2.+0.j])\n</code></pre>"},{"location":"ref/ComplexSequence/#cyclic_autocorrelation","title":"<code>cyclic_autocorrelation</code>","text":"<p>Returns the cyclic autocorrelation $\\tilde{R}[\\ell]$ of the complex sequence. See <code>komm.cyclic_autocorrelation</code> for more details.</p> <p>Parameters:</p> <ul> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>See <code>komm.cyclic_autocorrelation</code>. The default value yields $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>See <code>komm.cyclic_autocorrelation</code>. The default value is <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cyclic_autocorrelation</code>  (<code>Array1D[complex]</code>)          \u2013          <p>The cyclic autocorrelation $\\tilde{R}[\\ell]$ of the complex sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; seq = ComplexSequence([1, 1j, -1, -1j])\n&gt;&gt;&gt; seq.cyclic_autocorrelation(shifts=[-2, -1, 0, 1, 2])\narray([-4.+0.j,  0.-4.j,  4.+0.j,  0.+4.j, -4.+0.j])\n</code></pre>"},{"location":"ref/ConvolutionalCode/","title":"komm.ConvolutionalCode","text":"<p>Binary convolutional code. It is characterized by a matrix of feedforward polynomials $P(D)$, of shape $k \\times n$, and (optionally) by a vector of feedback polynomials $q(D)$, of length $k$. The element in row $i$ and column $j$ of $P(D)$ is denoted by $p_{i,j}(D)$, and the element in position $i$ of $q(D)$ is denoted by $q_i(D)$; they are binary polynomials in $D$. The parameters $k$ and $n$ are the number of input and output bits per block, respectively.</p> Transfer function matrix <p>The transfer function matrix (also known as transform-domain generator matrix) $G(D)$ of the convolutional code, of shape $k \\times n$, is such that the element in row $i$ and column $j$ is given by $$     g_{i,j}(D) = \\frac{p_{i,j}(D)}{q_{i}(D)}, $$ for $i \\in [0 : k)$ and $j \\in [0 : n)$.</p> Constraint lengths and related parameters <p>The constraint lengths of the code are defined by $$     \\nu_i = \\max \\{ \\deg p_{i,0}(D), \\deg p_{i,1}(D), \\ldots, \\deg p_{i,n-1}(D), \\deg q_i(D) \\}, $$ for $i \\in [0 : k)$.</p> <p>The overall constraint length of the code is defined by $$     \\nu = \\sum_{0 \\leq i &lt; k} \\nu_i. $$</p> <p>The memory order of the code is defined by $$     \\mu = \\max_{0 \\leq i &lt; k} \\nu_i. $$</p> Space-state representation <p>A convolutional code may also be described via the space-state representation. Let $\\mathbf{u}_t = (u_t^{(0)}, u_t^{(1)}, \\ldots, u_t^{(k-1)})$ be the input block, $\\mathbf{v}_t = (v_t^{(0)}, v_t^{(1)}, \\ldots, v_t^{(n-1)})$ be the output block, and $\\mathbf{s}_t = (s_t^{(0)}, s_t^{(1)}, \\ldots, s_t^{(\\nu-1)})$ be the state, all defined at time instant $t$. Then, $$ \\begin{aligned}     \\mathbf{s}_{t+1} &amp; = \\mathbf{s}_t A + \\mathbf{u}_t B, \\\\     \\mathbf{v}_{t} &amp; = \\mathbf{s}_t C + \\mathbf{u}_t D, \\end{aligned} $$ where $A$ is the $\\nu \\times \\nu$ state matrix, $B$ is the $k \\times \\nu$ control matrix, $C$ is the $\\nu \\times n$ observation matrix, and $D$ is the $k \\times n$ transition matrix.</p> Tables of convolutional codes <p>The tables below LC04, Sec. 12.3 lists optimal convolutional codes with no feedback, for parameters $(n,k) = (2,1)$ and $(n,k) = (3,1)$, and small values of the overall constraint length $\\nu$.</p> Parameters $(n, k, \\nu)$ Transfer function matrix $G(D)$ $(2, 1, 1)$ <code>[[0o1, 0o3]]</code> $(2, 1, 2)$ <code>[[0o5, 0o7]]</code> $(2, 1, 3)$ <code>[[0o13, 0o17]]</code> $(2, 1, 4)$ <code>[[0o27, 0o31]]</code> $(2, 1, 5)$ <code>[[0o53, 0o75]]</code> $(2, 1, 6)$ <code>[[0o117, 0o155]]</code> $(2, 1, 7)$ <code>[[0o247, 0o371]]</code> $(2, 1, 8)$ <code>[[0o561, 0o753]]</code> Parameters $(n, k, \\nu)$ Transfer function matrix $G(D)$ $(3, 1, 1)$ <code>[[0o1, 0o3, 0o3]]</code> $(3, 1, 2)$ <code>[[0o5, 0o7, 0o7]]</code> $(3, 1, 3)$ <code>[[0o13, 0o15, 0o17]]</code> $(3, 1, 4)$ <code>[[0o25, 0o33, 0o37]]</code> $(3, 1, 5)$ <code>[[0o47, 0o53, 0o75]]</code> $(3, 1, 6)$ <code>[[0o117, 0o127, 0o155]]</code> $(3, 1, 7)$ <code>[[0o255, 0o331, 0o367]]</code> $(3, 1, 8)$ <code>[[0o575, 0o623, 0o727]]</code> <p>For more details, see JZ15 and LC04, Chs. 11, 12.</p>"},{"location":"ref/ConvolutionalCode/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>feedforward_polynomials</code> (<code>Array2D[BinaryPolynomial, int]</code>)         \u2013          <p>The matrix of feedforward polynomials $P(D)$, which is a $k \\times n$ matrix whose entries are either binary polynomials or integers to be converted to the former.</p> </li> <li> <code>feedback_polynomials</code> (<code>Optional[Array1D[BinaryPolynomial, int]]</code>)         \u2013          <p>The vector of feedback polynomials $q(D)$, which is a $k$-vector whose entries are either binary polynomials or integers to be converted to the former. The default value corresponds to no feedback, that is, $q_i(D) = 1$ for all $i \\in [0 : k)$.</p> </li> </ul> <p>Examples:</p> <p>The convolutional code with encoder depicted in the figure below has parameters $(n, k, \\nu) = (2, 1, 6)$; its transfer function matrix is given by $$     G(D) =     \\begin{bmatrix}         D^6 + D^3 + D^2 + D + 1  &amp;  D^6 + D^5 + D^3 + D^2 + 1     \\end{bmatrix}, $$ yielding <code>feedforward_polynomials = [[0b1001111, 0b1101101]] = [[0o117, 0o155]] = [[79, 109]]</code>.</p> <p></p> <pre><code>&gt;&gt;&gt; code = komm.ConvolutionalCode(feedforward_polynomials=[[0o117, 0o155]])\n&gt;&gt;&gt; (code.num_output_bits, code.num_input_bits, code.overall_constraint_length)\n(2, 1, 6)\n</code></pre> <p>The convolutional code with encoder depicted in the figure below has parameters $(n, k, \\nu) = (3, 2, 7)$; its transfer function matrix is given by $$     G(D) =     \\begin{bmatrix}         D^4 + D^3 + 1  &amp;  D^4 + D^2 + D + 1  &amp;  0 \\\\         0  &amp;  D^3 + D  &amp;  D^3 + D^2 + 1     \\end{bmatrix}, $$ yielding <code>feedforward_polynomials = [[0b11001, 0b10111, 0b00000], [0b0000, 0b1010, 0b1101]] = [[0o31, 0o27, 0o00], [0o00, 0o12, 0o15]] = [[25, 23, 0], [0, 10, 13]]</code>.</p> <p></p> <pre><code>&gt;&gt;&gt; code = komm.ConvolutionalCode(feedforward_polynomials=[[0o31, 0o27, 0o00], [0o00, 0o12, 0o15]])\n&gt;&gt;&gt; (code.num_output_bits, code.num_input_bits, code.overall_constraint_length)\n(3, 2, 7)\n</code></pre> <p>The convolutional code with feedback encoder depicted in the figure below has parameters $(n, k, \\nu) = (2, 1, 4)$; its transfer function matrix is given by $$     G(D) =     \\begin{bmatrix}         1  &amp;  \\dfrac{D^4 + D^3 + 1}{D^4 + D^2 + D + 1}     \\end{bmatrix}, $$ yielding <code>feedforward_polynomials = [[0b10111, 0b11001]] = [[0o27, 0o31]] = [[23, 25]]</code> and <code>feedback_polynomials = [0o27]</code>.</p> <p></p> <pre><code>&gt;&gt;&gt; code = komm.ConvolutionalCode(feedforward_polynomials=[[0o27, 0o31]], feedback_polynomials=[0o27])\n&gt;&gt;&gt; (code.num_output_bits, code.num_input_bits, code.overall_constraint_length)\n(2, 1, 4)\n</code></pre>"},{"location":"ref/ConvolutionalCode/#num_input_bits","title":"<code>num_input_bits: int</code>  <code>property</code>","text":"<p>The number of input bits per block, $k$.</p>"},{"location":"ref/ConvolutionalCode/#num_output_bits","title":"<code>num_output_bits: int</code>  <code>property</code>","text":"<p>The number of output bits per block, $n$.</p>"},{"location":"ref/ConvolutionalCode/#constraint_lengths","title":"<code>constraint_lengths: npt.NDArray[np.int_]</code>  <code>cached</code> <code>property</code>","text":"<p>The constraint lengths $\\nu_i$ of the code, for $i \\in [0 : k)$. This is a $k$-array of integers.</p>"},{"location":"ref/ConvolutionalCode/#overall_constraint_length","title":"<code>overall_constraint_length: int</code>  <code>cached</code> <code>property</code>","text":"<p>The overall constraint length $\\nu$ of the code.</p>"},{"location":"ref/ConvolutionalCode/#memory_order","title":"<code>memory_order: int</code>  <code>cached</code> <code>property</code>","text":"<p>The memory order $\\mu$ of the code.</p>"},{"location":"ref/ConvolutionalCode/#transfer_function_matrix","title":"<code>transfer_function_matrix: npt.NDArray[np.object_]</code>  <code>cached</code> <code>property</code>","text":"<p>The transfer function matrix $G(D)$ of the code. This is a $k \\times n$ array of binary polynomial fractions.</p>"},{"location":"ref/ConvolutionalCode/#finite_state_machine","title":"<code>finite_state_machine: FiniteStateMachine</code>  <code>property</code>","text":"<p>The finite-state machine of the code.</p>"},{"location":"ref/ConvolutionalCode/#state_matrix","title":"<code>state_matrix: npt.NDArray[np.int_]</code>  <code>property</code>","text":"<p>The state matrix $A$ of the state-space representation. This is a $\\nu \\times \\nu$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalCode/#control_matrix","title":"<code>control_matrix: npt.NDArray[np.int_]</code>  <code>property</code>","text":"<p>The control matrix $B$ of the state-space representation. This is a $k \\times \\nu$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalCode/#observation_matrix","title":"<code>observation_matrix: npt.NDArray[np.int_]</code>  <code>property</code>","text":"<p>The observation matrix $C$ of the state-space representation. This is a $\\nu \\times n$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalCode/#transition_matrix","title":"<code>transition_matrix: npt.NDArray[np.int_]</code>  <code>property</code>","text":"<p>The transition matrix $D$ of the state-space representation. This is a $k \\times n$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalStreamDecoder/","title":"komm.ConvolutionalStreamDecoder","text":"<p>Convolutional stream decoder using Viterbi algorithm. Decode a (hard or soft) bit stream given a convolutional code, assuming a traceback length (path memory) of $\\tau$. At time $t$, the decoder chooses the path survivor with best metric at time $t - \\tau$ and outputs the corresponding information bits. The output stream has a delay equal to $k \\tau$, where $k$ is the number of input bits of the convolutional code. As a rule of thumb, the traceback length is chosen as $\\tau = 5\\mu$, where $\\mu$ is the memory order of the convolutional code.</p> <p>Attributes:</p> <ul> <li> <code>convolutional_code</code> (<code>ConvolutionalCode</code>)         \u2013          <p>The convolutional code.</p> </li> <li> <code>traceback_length</code> (<code>int</code>)         \u2013          <p>The traceback length (path memory) $\\tau$ of the decoder.</p> </li> <li> <code>state</code> (<code>int</code>)         \u2013          <p>The current state of the decoder. The default value is <code>0</code>.</p> </li> <li> <code>input_type</code> (<code>str</code>)         \u2013          <p>The type of the input sequence, either <code>hard</code> or <code>soft</code>. The default value is <code>hard</code>.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int] | Array1D[float]</code>)         \u2013          <p>The (hard or soft) bit sequence to be decoded.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The decoded bit sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0o7, 0o5]])\n&gt;&gt;&gt; convolutional_decoder = komm.ConvolutionalStreamDecoder(convolutional_code, traceback_length=10)\n&gt;&gt;&gt; convolutional_decoder([1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1])\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n&gt;&gt;&gt; convolutional_decoder(np.zeros(2*10, dtype=int))\narray([1, 0, 1, 1, 1, 0, 1, 1, 0, 0])\n</code></pre>"},{"location":"ref/ConvolutionalStreamEncoder/","title":"komm.ConvolutionalStreamEncoder","text":"<p>Convolutional stream encoder. Encode a bit stream using a given convolutional code. The internal state of the encoder is maintained across each call.</p> <p>Attributes:</p> <ul> <li> <code>convolutional_code</code> (<code>ConvolutionalCode</code>)         \u2013          <p>The convolutional code.</p> </li> <li> <code>state</code> (<code>int</code>)         \u2013          <p>The current state of the encoder. The default value is <code>0</code>.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int]</code>)         \u2013          <p>The bit sequence to be encoded.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The encoded bit sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0o7, 0o5]])\n&gt;&gt;&gt; convolutional_encoder = komm.ConvolutionalStreamEncoder(convolutional_code)\n&gt;&gt;&gt; convolutional_encoder([1, 1, 1, 1])\narray([1, 1, 0, 1, 1, 0, 1, 0])\n&gt;&gt;&gt; convolutional_encoder([1, 1, 1, 1])\narray([1, 0, 1, 0, 1, 0, 1, 0])\n</code></pre>"},{"location":"ref/CordaroWagnerCode/","title":"komm.CordaroWagnerCode","text":"<p>Cordaro\u2013Wagner code. For a given length $n \\geq 2$, it is the linear block code with dimension $k = 2$ which is optimum for the BSC with sufficiently small crossover probability. For more details, see CW67.</p> <ul> <li>Length: $n$</li> <li>Dimension: $k = 2$</li> <li>Redundancy: $m = n - 2$</li> <li>Minimum distance: $d = \\left\\lceil 2n / 3 \\right\\rceil - 1$</li> </ul> <p>Attributes:</p> <ul> <li> <code>n</code> (<code>int</code>)         \u2013          <p>The length $n$ of the code. Must satisfy $n \\geq 2$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.CordaroWagnerCode(11)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(11, 2, 9)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n       [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n7\n&gt;&gt;&gt; code.codeword_weight_distribution()\narray([1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0])\n&gt;&gt;&gt; code.coset_leader_weight_distribution()\narray([  1,  11,  55, 165, 226,  54,   0,   0,   0,   0,   0,   0])\n</code></pre>"},{"location":"ref/CyclicCode/","title":"komm.CyclicCode","text":"<p>General binary cyclic code. A cyclic code is a linear block code such that, if $c$ is a codeword, then every cyclic shift of $c$ is also a codeword. It is characterized by its generator polynomial $g(X)$, of degree $m$ (the redundancy of the code), and by its check polynomial $h(X)$, of degree $k$ (the dimension of the code). Those polynomials are related by $g(X) h(X) = X^n + 1$, where $n = k + m$ is the length of the code.</p> <p>Examples of generator polynomials can be found in the table below.</p> Code $(n, k, d)$ Generator polynomial $g(X)$ Integer representation Hamming $(7,4,3)$ $X^3 + X + 1$ <code>0b1011 = 0o13 = 11</code> Simplex $(7,3,4)$ $X^4 + X^2 + X +   1$ <code>0b10111 = 0o27 = 23</code> BCH $(15,5,7)$ $X^{10} + X^8 + X^5 + X^4 + X^2 + X + 1$ <code>0b10100110111 = 0o2467 = 1335</code> Golay $(23,12,7)$ $X^{11} + X^9 + X^7 + X^6 + X^5 + X + 1$ <code>0b101011100011 = 0o5343 = 2787</code> <p>For more details, see LC04, Ch. 5.</p> <p>The constructor expects either the generator polynomial or the check polynomial.</p> <p>Parameters:</p> <ul> <li> <code>length</code>         \u2013          <p>The length $n$ of the code.</p> </li> <li> <code>generator_polynomial</code>         \u2013          <p>The generator polynomial $g(X)$ of the code, of degree $m$ (the redundancy of the code), specified either as a binary polynomial or as an integer to be converted to the former.</p> </li> <li> <code>check_polynomial</code>         \u2013          <p>The check polynomial $h(X)$ of the code, of degree $k$ (the dimension of the code), specified either as a binary polynomial or as an integer to be converted to the former.</p> </li> <li> <code>systematic</code>         \u2013          <p>Whether the encoder is systematic. Default is <code>True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.CyclicCode(length=23, generator_polynomial=0b101011100011)  # Golay (23, 12)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(23, 12, 11)\n&gt;&gt;&gt; code.minimum_distance()\n7\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.CyclicCode(length=23, check_polynomial=0b1010010011111)  # Golay (23, 12)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(23, 12, 11)\n&gt;&gt;&gt; code.minimum_distance()\n7\n</code></pre>"},{"location":"ref/CyclicCode/#meggitt_table","title":"<code>meggitt_table: dict[BinaryPolynomial, BinaryPolynomial]</code>  <code>cached</code> <code>property</code>","text":"<p>The Meggitt table for the cyclic code. It is a dictionary where the keys are syndromes and the values are error patterns. See XiD03, Sec. 3.4.</p>"},{"location":"ref/DiscreteMemorylessChannel/","title":"komm.DiscreteMemorylessChannel","text":"<p>General discrete memoryless channel (DMC). It is defined by an input alphabet $\\mathcal{X}$, an output alphabet $\\mathcal{Y}$, and a transition probability matrix $p_{Y \\mid X}$. Here, for simplicity, the input and output alphabets are always taken as $\\mathcal{X} = \\{ 0, 1, \\ldots, |\\mathcal{X}| - 1 \\}$ and $\\mathcal{Y} = \\{ 0, 1, \\ldots, |\\mathcal{Y}| - 1 \\}$, respectively. The transition probability matrix $p_{Y \\mid X}$, of size $|\\mathcal{X}|$-by-$|\\mathcal{Y}|$, gives the conditional probability of receiving $Y = y$ given that $X = x$ is transmitted. For more details, see CT06, Ch. 7.</p> <p>Attributes:</p> <ul> <li> <code>transition_matrix</code> (<code>Array2D[float]</code>)         \u2013          <p>The channel transition probability matrix $p_{Y \\mid X}$. The element in row $x \\in \\mathcal{X}$ and column $y \\in \\mathcal{Y}$ must be equal to $p_{Y \\mid X}(y \\mid x)$.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>input_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The input sequence.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>output_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The output sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; dmc = komm.DiscreteMemorylessChannel([[0.9, 0.05, 0.05], [0.0, 0.5, 0.5]])\n&gt;&gt;&gt; dmc([0, 1, 0, 1, 1, 1, 0, 0, 0, 1])\narray([0, 2, 0, 1, 1, 1, 0, 0, 0, 2])\n</code></pre>"},{"location":"ref/DiscreteMemorylessChannel/#input_cardinality","title":"<code>input_cardinality: int</code>  <code>property</code>","text":"<p>The channel input cardinality $|\\mathcal{X}|$.</p>"},{"location":"ref/DiscreteMemorylessChannel/#output_cardinality","title":"<code>output_cardinality: int</code>  <code>property</code>","text":"<p>The channel output cardinality $|\\mathcal{Y}|$.</p>"},{"location":"ref/DiscreteMemorylessChannel/#mutual_information","title":"<code>mutual_information</code>","text":"<p>Returns the mutual information $\\mathrm{I}(X ; Y)$ between the input $X$ and the output $Y$ of the channel. It is given by $$     \\mathrm{I}(X ; Y) = \\mathrm{H}(X) - \\mathrm{H}(X \\mid Y), $$ where $\\mathrm{H}(X)$ is the the entropy of $X$ and $\\mathrm{H}(X \\mid Y)$ is the conditional entropy of $X$ given $Y$. By default, the base of the logarithm is $2$, in which case the mutual information is measured in bits. See CT06, Ch. 2.</p> <p>Parameters:</p> <ul> <li> <code>input_pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The probability mass function $p_X$ of the channel input $X$. It must be a valid pmf, that is, all of its values must be non-negative and sum up to $1$.</p> </li> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>The base of the logarithm to be used. It must be a positive float or the string <code>'e'</code>. The default value is <code>2.0</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mutual_information</code>  (<code>float</code>)          \u2013          <p>The mutual information $\\mathrm{I}(X ; Y)$ between the input $X$ and the output $Y$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dmc = komm.DiscreteMemorylessChannel([[0.6, 0.3, 0.1], [0.7, 0.1, 0.2], [0.5, 0.05, 0.45]])\n&gt;&gt;&gt; dmc.mutual_information([1/3, 1/3, 1/3]).round(6)\nnp.float64(0.123811)\n&gt;&gt;&gt; dmc.mutual_information([1/3, 1/3, 1/3], base=3).round(6)\nnp.float64(0.078116)\n&gt;&gt;&gt; dmc.mutual_information([1/3, 1/3, 1/3], base='e').round(6)\nnp.float64(0.085819)\n</code></pre>"},{"location":"ref/DiscreteMemorylessChannel/#capacity","title":"<code>capacity</code>","text":"<p>Returns the channel capacity $C$. It is given by $C = \\max_{p_X} \\mathrm{I}(X;Y)$. This method computes the channel capacity via the Arimoto\u2013Blahut algorithm. See CT06, Sec. 10.8.</p> <p>Parameters:</p> <ul> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>The base of the logarithm to be used. It must be a positive float or the string <code>'e'</code>. The default value is <code>2.0</code>.</p> </li> </ul> <p>Additional keyword arguments for the Arimoto\u2013Blahut algorithm:</p> <ul> <li> <code>max_iter</code> (<code>Optional[int]</code>)         \u2013          <p>The maximum number of iterations. The default value is <code>1000</code>.</p> </li> <li> <code>tol</code> (<code>Optional[float]</code>)         \u2013          <p>The error tolerance. The default value is <code>1e-12</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>capacity</code>  (<code>float</code>)          \u2013          <p>The channel capacity $C$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dmc = komm.DiscreteMemorylessChannel([[0.6, 0.3, 0.1], [0.7, 0.1, 0.2], [0.5, 0.05, 0.45]])\n&gt;&gt;&gt; dmc.capacity().round(6)\nnp.float64(0.161632)\n&gt;&gt;&gt; dmc.capacity(base=3).round(6)\nnp.float64(0.101978)\n&gt;&gt;&gt; dmc.capacity(base='e').round(6)\nnp.float64(0.112035)\n</code></pre>"},{"location":"ref/DiscreteMemorylessSource/","title":"komm.DiscreteMemorylessSource","text":"<p>Discrete memoryless source (DMS). It is defined by an alphabet $\\mathcal{X}$ and a probability mass function (pmf) $p_X$. Here, for simplicity, the alphabet is always taken as $\\mathcal{X} = \\{ 0, 1, \\ldots, |\\mathcal{X}| - 1 \\}$. The pmf $p_X$ gives the probability of the source emitting the symbol $X = x$.</p> <p>To invoke the source, call the object giving the number of symbols to be emitted as parameter (see example below).</p> <p>Attributes:</p> <ul> <li> <code>pmf</code> (<code>NDArray[float64]</code>)         \u2013          <p>The source probability mass function $p_X$. The element in position $x \\in \\mathcal{X}$ must be equal to $p_X(x)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; dms = komm.DiscreteMemorylessSource([0.5, 0.4, 0.1])\n&gt;&gt;&gt; dms(10)\narray([0, 2, 1, 1, 0, 0, 0, 1, 1, 1])\n</code></pre>"},{"location":"ref/DiscreteMemorylessSource/#cardinality","title":"<code>cardinality: int</code>  <code>property</code>","text":"<p>The cardinality $|\\mathcal{X}|$ of the source alphabet.</p>"},{"location":"ref/DiscreteMemorylessSource/#entropy","title":"<code>entropy</code>","text":"<p>Returns the source entropy $\\mathrm{H}(X)$. See <code>komm.entropy</code> for more details.</p> <p>Parameters:</p> <ul> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>See <code>komm.entropy</code>. The default value is $2.0$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dms = komm.DiscreteMemorylessSource([1/2, 1/4, 1/8, 1/8])\n&gt;&gt;&gt; dms.entropy()\nnp.float64(1.75)\n&gt;&gt;&gt; dms.entropy(base=4)\nnp.float64(0.875)\n</code></pre>"},{"location":"ref/FiniteBifield/","title":"komm.FiniteBifield","text":"<p>Finite field with binary characteristic. Objects of this class represent a finite field $\\mathrm{GF}(2^k)$ (also known as Galois field), with characteristic $2$ and degree $k$.</p> <p>Attributes:</p> <ul> <li> <code>degree</code> (<code>int</code>)         \u2013          <p>Degree $k$ of the finite field. Must be a positive integer.</p> </li> <li> <code>modulus</code> (<code>Optional[BinaryPolynomial | int]</code>)         \u2013          <p>Modulus (primitive polynomial) $p(X)$ of the field, specified either as a binary polynomial or as an integer to be converted to the former. Must be an irreducible polynomial. If not specified, the modulus is chosen from the table below LC04, p.42.</p> Degree $k$ Modulus $p(X)$ Degree $k$ Modulus $p(X)$ $1$ <code>0b11</code> $9$ <code>0b1000010001</code> $2$ <code>0b111</code> $10$ <code>0b10000001001</code> $3$ <code>0b1011</code> $11$ <code>0b100000000101</code> $4$ <code>0b10011</code> $12$ <code>0b1000001010011</code> $5$ <code>0b100101</code> $13$ <code>0b10000000011011</code> $6$ <code>0b1000011</code> $14$ <code>0b100010001000011</code> $7$ <code>0b10001001</code> $15$ <code>0b1000000000000011</code> $8$ <code>0b100011101</code> $16$ <code>0b10001000000001011</code> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = komm.FiniteBifield(4)\n&gt;&gt;&gt; field\nFiniteBifield(4)\n&gt;&gt;&gt; (field.characteristic, field.degree, field.order)\n(2, 4, 16)\n&gt;&gt;&gt; field.modulus\nBinaryPolynomial(0b10011)\n</code></pre> <pre><code>&gt;&gt;&gt; field = komm.FiniteBifield(4, modulus=0b11001)\n&gt;&gt;&gt; field\nFiniteBifield(4, modulus=0b11001)\n&gt;&gt;&gt; (field.characteristic, field.degree, field.order)\n(2, 4, 16)\n&gt;&gt;&gt; field.modulus\nBinaryPolynomial(0b11001)\n</code></pre> Construction of elements <p>To construct elements of the finite field, call the finite field object. For example, <code>field(0b1101)</code> will construct the element whose polynomial representation is $X^3 + X^2 + 1$.</p> Algebraic structure <p>The following operations are supported: addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and exponentiation (<code>**</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = komm.FiniteBifield(4)\n&gt;&gt;&gt; x = field(0b1011)\n&gt;&gt;&gt; y = field(0b1100)\n&gt;&gt;&gt; x + y\n0b111\n&gt;&gt;&gt; x - y\n0b111\n&gt;&gt;&gt; x * y\n0b1101\n&gt;&gt;&gt; x / y\n0b10\n&gt;&gt;&gt; x**2\n0b1001\n</code></pre> Further methods on elements <p>The following methods are available on elements of the finite field:</p> <ul> <li><code>logarithm(base)</code>: Returns the logarithm of the element, with respect to a given base.</li> <li><code>conjugates()</code>: Returns the conjugates of the element.</li> <li><code>minimal_polynomial()</code>: Returns the minimal polynomial of the element.</li> </ul> <p>For more details, see LC04, Sec. 2.5.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = komm.FiniteBifield(4)\n&gt;&gt;&gt; x = field(0b1011)\n&gt;&gt;&gt; base = field(0b10)\n&gt;&gt;&gt; x.logarithm(base)\n7\n&gt;&gt;&gt; x.conjugates()\n[0b1011, 0b1001, 0b1101, 0b1110]\n&gt;&gt;&gt; x.minimal_polynomial()\nBinaryPolynomial(0b11001)\n</code></pre>"},{"location":"ref/FiniteBifield/#characteristic","title":"<code>characteristic: int</code>  <code>property</code>","text":"<p>The characteristic $2$ of the finite field.</p>"},{"location":"ref/FiniteBifield/#order","title":"<code>order: int</code>  <code>property</code>","text":"<p>The order (number of elements) of the finite field. It is given by $2^k$.</p>"},{"location":"ref/FiniteBifield/#primitive_element","title":"<code>primitive_element: FiniteBifieldElement[Self]</code>  <code>property</code>","text":"<p>A primitive element $\\alpha$ of the finite field. It satisfies $p(\\alpha) = 0$, where $p(X)$ is the modulus (primitive polynomial) of the finite field.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field1 = komm.FiniteBifield(3, modulus=0b1011)\n&gt;&gt;&gt; alpha1 = field1.primitive_element\n&gt;&gt;&gt; [alpha1**i for i in range(7)]\n[0b1, 0b10, 0b100, 0b11, 0b110, 0b111, 0b101]\n&gt;&gt;&gt; field2 = komm.FiniteBifield(3, modulus=0b1101)\n&gt;&gt;&gt; alpha2 = field2.primitive_element\n&gt;&gt;&gt; [alpha2**i for i in range(7)]\n[0b1, 0b10, 0b100, 0b101, 0b111, 0b11, 0b110]\n</code></pre>"},{"location":"ref/FiniteStateMachine/","title":"komm.FiniteStateMachine","text":"<p>Finite-state machine (Mealy machine). It is defined by a set of states $\\mathcal{S}$, an input alphabet $\\mathcal{X}$, an output alphabet $\\mathcal{Y}$, and a transition function $T : \\mathcal{S} \\times \\mathcal{X} \\to \\mathcal{S} \\times \\mathcal{Y}$. Here, for simplicity, the set of states, the input alphabet, and the output alphabet are always taken as $\\mathcal{S} = \\{ 0, 1, \\ldots, |\\mathcal{S}| - 1 \\}$, $\\mathcal{X} = \\{ 0, 1, \\ldots, |\\mathcal{X}| - 1 \\}$, and $\\mathcal{Y} = \\{ 0, 1, \\ldots, |\\mathcal{Y}| - 1 \\}$, respectively.</p> <p>For example, consider the finite-state machine whose state diagram depicted in the figure below.</p> <p></p> <p>It has set of states $\\mathcal{S} = \\{ 0, 1, 2, 3 \\}$, input alphabet $\\mathcal{X} = \\{ 0, 1 \\}$, output alphabet $\\mathcal{Y} = \\{ 0, 1, 2, 3 \\}$, and transition function $T$ given by the table below.</p> State Input Next state Output $0$ $0$ $0$ $0$ $0$ $1$ $1$ $3$ $1$ $0$ $2$ $1$ $1$ $1$ $3$ $2$ $2$ $0$ $0$ $3$ $2$ $1$ $1$ $0$ $3$ $0$ $2$ $2$ $3$ $1$ $3$ $1$ <p>Attributes:</p> <ul> <li> <code>next_states</code> (<code>Array2D[int]</code>)         \u2013          <p>The matrix of next states of the machine, of shape $|\\mathcal{S}| \\times |\\mathcal{X}|$. The element in row $s$ and column $x$ should be the next state of the machine (an element in $\\mathcal{S}$), given that the current state is $s \\in \\mathcal{S}$ and the input is $x \\in \\mathcal{X}$.</p> </li> <li> <code>outputs</code> (<code>Array2D[int]</code>)         \u2013          <p>The matrix of outputs of the machine, of shape $|\\mathcal{S}| \\times |\\mathcal{X}|$. The element in row $s$ and column $x$ should be the output of the machine (an element in $\\mathcal{Y}$), given that the current state is $s \\in \\mathcal{S}$ and the input is $x \\in \\mathcal{X}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n</code></pre>"},{"location":"ref/FiniteStateMachine/#num_states","title":"<code>num_states: int</code>  <code>cached</code> <code>property</code>","text":"<p>The number of states of the machine.</p>"},{"location":"ref/FiniteStateMachine/#num_input_symbols","title":"<code>num_input_symbols: int</code>  <code>cached</code> <code>property</code>","text":"<p>The size (cardinality) of the input alphabet $\\mathcal{X}$.</p>"},{"location":"ref/FiniteStateMachine/#num_output_symbols","title":"<code>num_output_symbols: int</code>  <code>cached</code> <code>property</code>","text":"<p>The size (cardinality) of the output alphabet $\\mathcal{Y}$.</p>"},{"location":"ref/FiniteStateMachine/#input_edges","title":"<code>input_edges: npt.NDArray[np.int_]</code>  <code>property</code>","text":"<p>The matrix of input edges of the machine. It has shape $|\\mathcal{S}| \\times |\\mathcal{S}|$. If there is an edge from $s_0 \\in \\mathcal{S}$ to $s_1 \\in \\mathcal{S}$, then the element in row $s_0$ and column $s_1$ is the input associated with that edge (an element of $\\mathcal{X}$); if there is no such edge, then the element is $-1$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n&gt;&gt;&gt; fsm.input_edges\narray([[ 0,  1, -1, -1],\n       [-1, -1,  0,  1],\n       [ 0,  1, -1, -1],\n       [-1, -1,  0,  1]])\n</code></pre>"},{"location":"ref/FiniteStateMachine/#output_edges","title":"<code>output_edges: npt.NDArray[np.int_]</code>  <code>property</code>","text":"<p>The matrix of output edges of the machine. It has shape $|\\mathcal{S}| \\times |\\mathcal{S}|$. If there is an edge from $s_0 \\in \\mathcal{S}$ to $s_1 \\in \\mathcal{S}$, then the element in row $s_0$ and column $s_1$ is the output associated with that edge (an element of $\\mathcal{Y}$); if there is no such edge, then the element is $-1$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n&gt;&gt;&gt; fsm.output_edges\narray([[ 0,  3, -1, -1],\n       [-1, -1,  1,  2],\n       [ 3,  0, -1, -1],\n       [-1, -1,  2,  1]])\n</code></pre>"},{"location":"ref/FiniteStateMachine/#process","title":"<code>process</code>","text":"<p>Returns the output sequence corresponding to a given input sequence. It assumes the machine starts at a given initial state $s_\\mathrm{i}$. The input sequence and the output sequence are denoted by $\\mathbf{x} = (x_0, x_1, \\ldots, x_{L-1}) \\in \\mathcal{X}^L$ and $\\mathbf{y} = (y_0, y_1, \\ldots, y_{L-1}) \\in \\mathcal{Y}^L$, respectively.</p> <p>Parameters:</p> <ul> <li> <code>input_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The input sequence $\\mathbf{x} \\in \\mathcal{X}^L$. It should be a 1D-array with elements in $\\mathcal{X}$.</p> </li> <li> <code>initial_state</code> (<code>int</code>)         \u2013          <p>The initial state $s_\\mathrm{i}$ of the machine. Should be an integer in $\\mathcal{S}$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>output_sequence</code>  (<code>Array1D[int]</code>)          \u2013          <p>The output sequence $\\mathbf{y} \\in \\mathcal{Y}^L$ corresponding to <code>input_sequence</code>, assuming the machine starts at the state given by <code>initial_state</code>. It is a 1D-array with elements in $\\mathcal{Y}$.</p> </li> <li> <code>final_state</code>  (<code>int</code>)          \u2013          <p>The final state $s_\\mathrm{f}$ of the machine. It is an integer in $\\mathcal{S}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n&gt;&gt;&gt; input_sequence, initial_state = [1, 1, 0, 1, 0], 0\n&gt;&gt;&gt; output_sequence, final_state = fsm.process(input_sequence, initial_state)\n&gt;&gt;&gt; output_sequence\narray([3, 2, 2, 0, 1])\n&gt;&gt;&gt; final_state\nnp.int64(2)\n</code></pre>"},{"location":"ref/FiniteStateMachine/#viterbi","title":"<code>viterbi</code>","text":"<p>Applies the Viterbi algorithm on a given observed sequence. The Viterbi algorithm finds the most probable input sequence $\\hat{\\mathbf{x}}(s) \\in \\mathcal{X}^L$ ending in state $s$, for all $s \\in \\mathcal{S}$, given an observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$. It is assumed uniform input priors. See LC04, Sec. 12.1.</p> <p>Parameters:</p> <ul> <li> <code>observed_sequence</code> (<code>Array1D</code>)         \u2013          <p>The observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$.</p> </li> <li> <code>metric_function</code> (<code>function</code>)         \u2013          <p>The metric function $\\mathcal{Y} \\times \\mathcal{Z} \\to \\mathbb{R}$.</p> </li> <li> <code>initial_metrics</code> (<code>Optional[Array1D[float]]</code>)         \u2013          <p>The initial metrics for each state. It must be a 1D-array of length $|\\mathcal{S}|$. The default value is <code>0.0</code> for all states.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>input_sequences_hat</code>  (<code>Array2D[int]</code>)          \u2013          <p>The most probable input sequence $\\hat{\\mathbf{x}}(s) \\in \\mathcal{X}^L$ ending in state $s$, for all $s \\in \\mathcal{S}$. It is a 2D-array of shape $L \\times |\\mathcal{S}|$, in which column $s$ is equal to $\\hat{\\mathbf{x}}(s)$.</p> </li> <li> <code>final_metrics</code>  (<code>Array1D[float]</code>)          \u2013          <p>The final metrics for each state. It is a 1D-array of length $|\\mathcal{S}|$.</p> </li> </ul>"},{"location":"ref/FiniteStateMachine/#viterbi_streaming","title":"<code>viterbi_streaming</code>","text":"<p>Applies the streaming version of the Viterbi algorithm on a given observed sequence. The path memory (or traceback length) is denoted by $\\tau$. It chooses the survivor with best metric and selects the information block on this path. See LC04, Sec. 12.3.</p> <p>Parameters:</p> <ul> <li> <code>observed_sequence</code> (<code>Array1D</code>)         \u2013          <p>The observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$.</p> </li> <li> <code>metric_function</code> (<code>function</code>)         \u2013          <p>The metric function $\\mathcal{Y} \\times \\mathcal{Z} \\to \\mathbb{R}$.</p> </li> <li> <code>memory</code> (<code>dict</code>)         \u2013          <p>The metrics for each state. It must be a dictionary containing two keys: <code>'paths'</code>, a 2D-array of integers of shape $|\\mathcal{S}| \\times (\\tau + 1)$; and <code>'metrics'</code>, a 2D-array of floats of shape $|\\mathcal{S}| \\times (\\tau + 1)$. This dictionary is updated in-place by this method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>input_sequence_hat</code>  (<code>Array1D[int]</code>)          \u2013          <p>The most probable input sequence $\\hat{\\mathbf{x}} \\in \\mathcal{X}^L$</p> </li> </ul>"},{"location":"ref/FiniteStateMachine/#forward_backward","title":"<code>forward_backward</code>","text":"<p>Applies the forward-backward algorithm on a given observed sequence. The forward-backward algorithm computes the posterior pmf of each input $x_0, x_1, \\ldots, x_{L-1} \\in \\mathcal{X}$ given an observed sequence $\\mathbf{z} = (z_0, z_1, \\ldots, z_{L-1}) \\in \\mathcal{Z}^L$. The prior pmf of each input may also be provided. See LC04, 12.6.</p> <p>Parameters:</p> <ul> <li> <code>observed_sequence</code> (<code>Array1D</code>)         \u2013          <p>The observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$.</p> </li> <li> <code>metric_function</code> (<code>function</code>)         \u2013          <p>The metric function $\\mathcal{Y} \\times \\mathcal{Z} \\to \\mathbb{R}$.</p> </li> <li> <code>input_priors</code> (<code>Optional[Array2D[float]]</code>)         \u2013          <p>The prior pmf of each input, of shape $L \\times |\\mathcal{X}|$. The element in row $t \\in [0 : L)$ and column $x \\in \\mathcal{X}$ should be $p(x_t = x)$. The default value yields uniform priors.</p> </li> <li> <code>initial_state_distribution</code> (<code>Optional[Array1D[float]]</code>)         \u2013          <p>The pmf of the initial state of the machine. It must be a 1D-array of length $|\\mathcal{S}|$. The default value is uniform over all states.</p> </li> <li> <code>final_state_distribution</code> (<code>Optional[Array1D[float]]</code>)         \u2013          <p>The pmf of the final state of the machine. It must be a 1D-array of length $|\\mathcal{S}|$. The default value is uniform over all states.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>input_posteriors</code>  (<code>Array2D[float]</code>)          \u2013          <p>The posterior pmf of each input, given the observed sequence, of shape $L \\times |\\mathcal{X}|$. The element in row $t \\in [0 : L)$ and column $x \\in \\mathcal{X}$ is $p(x_t = x \\mid \\mathbf{z})$.</p> </li> </ul>"},{"location":"ref/FixedToVariableCode/","title":"komm.FixedToVariableCode","text":"<p>Fixed-to-variable length code. A fixed-to-variable length code with source alphabet $\\mathcal{S}$, target alphabet $\\mathcal{T}$, and source block size $k$ is defined by an injective encoding mapping $\\Enc : \\mathcal{S}^k \\to \\mathcal{T}^+$, where the domain is the set of all $k$-tuples with entries in $\\mathcal{S}$, and the co-domain is the set of all finite-length, non-empty tuples with entries in $\\mathcal{T}$. Here we assume that $\\mathcal{S} = [0:S)$ and $\\mathcal{T} = [0:T)$, for integers $S \\geq 2$ and $T \\geq 2$. The elements in the image of $\\Enc$ are called codewords.</p> <p>Attributes:</p> <ul> <li> <code>source_cardinality</code> (<code>int</code>)         \u2013          <p>The source cardinality $S$.</p> </li> <li> <code>target_cardinality</code> (<code>int</code>)         \u2013          <p>The target cardinality $T$.</p> </li> <li> <code>source_block_size</code> (<code>int</code>)         \u2013          <p>The source block size $k$.</p> </li> <li> <code>enc_mapping</code> (<code>dict[Word, Word]</code>)         \u2013          <p>The encoding mapping $\\Enc$ of the code. Must be a dictionary of length $S^k$ whose keys are $k$-tuples of integers in $[0:S)$ and whose values are distinct non-empty tuples of integers in $[0:T)$.</p> </li> </ul>"},{"location":"ref/FixedToVariableCode/#from_enc_mapping","title":"<code>from_enc_mapping</code>  <code>classmethod</code>","text":"<p>Constructs a fixed-to-variable length code from the encoding mapping $\\Enc$.</p> <p>Parameters:</p> <ul> <li> <code>enc_mapping</code> (<code>dict[Word, Word]</code>)         \u2013          <p>The encoding mapping $\\Enc$. See the corresponding attribute for more details.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_enc_mapping({(0,): (0,), (1,): (1,0), (2,): (1,1)})\n&gt;&gt;&gt; code.source_cardinality, code.target_cardinality, code.source_block_size\n(3, 2, 1)\n&gt;&gt;&gt; code.enc_mapping\n{(0,): (0,),\n (1,): (1, 0),\n (2,): (1, 1)}\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_enc_mapping({(0,0): (0,), (0,1): (1,0,0), (1,0): (1,1), (1,1): (1,0,1)})\n&gt;&gt;&gt; code.source_cardinality, code.target_cardinality, code.source_block_size\n(2, 2, 2)\n&gt;&gt;&gt; code.enc_mapping\n{(0, 0): (0,),\n (0, 1): (1, 0, 0),\n (1, 0): (1, 1),\n (1, 1): (1, 0, 1)}\n</code></pre>"},{"location":"ref/FixedToVariableCode/#from_codewords","title":"<code>from_codewords</code>  <code>classmethod</code>","text":"<p>Constructs a fixed-to-variable length code from the source cardinality $S$ and a list of codewords.</p> <p>Parameters:</p> <ul> <li> <code>source_cardinality</code> (<code>int</code>)         \u2013          <p>The source cardinality $S$. Must be an integer greater than or equal to $2$.</p> </li> <li> <code>codewords</code> (<code>list[Word]</code>)         \u2013          <p>The codewords of the code. See the corresponding property for more details.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.source_cardinality, code.target_cardinality, code.source_block_size\n(3, 2, 1)\n&gt;&gt;&gt; code.enc_mapping\n{(0,): (0,),\n (1,): (1, 0),\n (2,): (1, 1)}\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(2, [(0,), (1,0,0), (1,1), (1,0,1)])\n&gt;&gt;&gt; (code.source_cardinality, code.target_cardinality, code.source_block_size)\n(2, 2, 2)\n&gt;&gt;&gt; code.enc_mapping\n{(0, 0): (0,),\n (0, 1): (1, 0, 0),\n (1, 0): (1, 1),\n (1, 1): (1, 0, 1)}\n</code></pre>"},{"location":"ref/FixedToVariableCode/#codewords","title":"<code>codewords: list[Word]</code>  <code>property</code>","text":"<p>The codewords of the code. It is a list of length $S^k$ containing tuples of integers in $[0:T)$. The tuple in position $i$ of <code>codewords</code> is equal to $\\Enc(u)$, where $u$ is the $i$-th element in the lexicographic ordering of $[0:S)^k$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_enc_mapping({(0,): (0,), (1,): (1,0), (2,): (1,1)})\n&gt;&gt;&gt; code.codewords\n[(0,), (1, 0), (1, 1)]\n</code></pre>"},{"location":"ref/FixedToVariableCode/#inv_enc_mapping","title":"<code>inv_enc_mapping: dict[Word, Word]</code>  <code>property</code>","text":"<p>The inverse encoding mapping $\\Enc^{-1}$ of the code. It is a dictionary of length $S^k$ whose keys are all the codewords of the code and whose values are the corresponding source words.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.inv_enc_mapping\n{(0,): (0,),\n (1, 0): (1,),\n (1, 1): (2,)}\n</code></pre>"},{"location":"ref/FixedToVariableCode/#is_uniquely_decodable","title":"<code>is_uniquely_decodable</code>","text":"<p>Returns whether the code is uniquely decodable or not. A code is uniquely decodable if $$     s_1 \\cdots s_n \\neq s'_1 \\cdots s'_m \\implies \\Enc(s_1) \\cdots \\Enc(s_n) \\neq \\Enc(s'_1) \\cdots \\Enc(s'_m). $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.is_uniquely_decodable()\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (0,1), (1,1)])\n&gt;&gt;&gt; code.is_uniquely_decodable()\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (0,1), (1,0)])\n&gt;&gt;&gt; code.is_uniquely_decodable()\nFalse\n</code></pre>"},{"location":"ref/FixedToVariableCode/#is_prefix_free","title":"<code>is_prefix_free</code>","text":"<p>Returns whether the code is prefix-free or not. A code is prefix-free if no codeword is a prefix of any other codeword.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.is_prefix_free()\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (0,1), (1,1)])\n&gt;&gt;&gt; code.is_prefix_free()\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (0,1), (1,0)])\n&gt;&gt;&gt; code.is_prefix_free()\nFalse\n</code></pre>"},{"location":"ref/FixedToVariableCode/#rate","title":"<code>rate</code>","text":"<p>Computes the expected rate $R$ of the code, considering a given pmf. This quantity is given by $$     R = \\frac{\\bar{n}}{k}, $$ where $\\bar{n}$ is the expected codeword length, assuming iid source symbols drawn from $p_X$, and $k$ is the source block size. It is measured in $T$-ary digits per source symbol.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>ArrayLike</code>)         \u2013          <p>The (first-order) probability mass function $p_X$ to be considered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rate</code>  (<code>float</code>)          \u2013          <p>The expected rate $R$ of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.rate([0.5, 0.25, 0.25])\nnp.float64(1.5)\n</code></pre>"},{"location":"ref/FixedToVariableDecoder/","title":"komm.FixedToVariableDecoder","text":"<p>Decoder for prefix-free fixed-to-variable length codes.</p> <p>Attributes:</p> <ul> <li> <code>code</code> (<code>FixedToVariableCode</code>)         \u2013          <p>The code to be considered, which must be a prefix-free code (that is, no codeword is a prefix of another codeword).</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of symbols to be decoded. Must be a 1D-array with elements in $[0:T)$, where $T$ is the target cardinality of the code.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of decoded symbols. It is a 1D-array with elements in $[0:S)$, where $S$ is the source cardinality of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (1,0), (1,1)])\n&gt;&gt;&gt; decoder = komm.FixedToVariableDecoder(code)\n&gt;&gt;&gt; decoder([1, 0, 0, 1, 0, 0, 1, 1, 0])\narray([1, 0, 1, 0, 2, 0])\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(2, [(0,), (1,0), (1,1), (1,1,0)])\n&gt;&gt;&gt; decoder = komm.FixedToVariableDecoder(code)\nTraceback (most recent call last):\n...\nValueError: code is not prefix-free\n</code></pre>"},{"location":"ref/FixedToVariableEncoder/","title":"komm.FixedToVariableEncoder","text":"<p>Encoder for fixed-to-variable length codes.</p> <p>Attributes:</p> <ul> <li> <code>code</code> (<code>FixedToVariableCode</code>)         \u2013          <p>The code to be considered.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of symbols to be encoded. Must be a 1D-array with elements in $[0:S)$, where $S$ is the source cardinality of the code.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of encoded symbols. It is a 1D-array with elements in $[0:T)$, where $T$ is the target cardinality of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode.from_codewords(3, [(0,), (1,0), (1,1)])\n&gt;&gt;&gt; encoder = komm.FixedToVariableEncoder(code)\n&gt;&gt;&gt; encoder([1, 0, 1, 0, 2, 0])\narray([1, 0, 0, 1, 0, 0, 1, 1, 0])\n</code></pre>"},{"location":"ref/GaussianPulse/","title":"komm.GaussianPulse","text":"<p>Gaussian pulse. It is a pulse with waveform given by $$     h(t) = \\mathrm{e}^{-\\frac{1}{2} (2 \\pi \\bar{B} t)^2} $$ where the $\\bar{B} = B / \\sqrt{\\ln 2}$, and $B$ is the half-power bandwidth of the filter. Its spectrum is given by $$     \\hat{h}(f) = \\frac{1}{\\sqrt{2 \\pi} \\bar{B}} \\mathrm{e}^{-\\frac{1}{2} (f / \\bar{B})^2}. $$</p> <p>The Gaussian pulse is depicted below for $B = 0.5$, and for $B = 1$.</p> <p> </p> <p>Attributes:</p> <ul> <li> <code>half_power_bandwidth</code> (<code>float</code>)         \u2013          <p>The half-power bandwidth $B$ of the pulse. The default value is <code>1.0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.GaussianPulse(half_power_bandwidth=0.25)\n&gt;&gt;&gt; pulse.waveform([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.3675, 0.6408, 0.8947, 1.    , 0.8947, 0.6408, 0.3675])\n&gt;&gt;&gt; pulse.spectrum([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.0587, 0.3321, 0.9394, 1.3286, 0.9394, 0.3321, 0.0587])\n</code></pre>"},{"location":"ref/GolayCode/","title":"komm.GolayCode","text":"<p>Binary Golay code. It is the linear block code with parity submatrix $$ P = \\begin{bmatrix}     1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\     0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\     0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\     1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\\\     1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\     1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\     0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\     0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\     0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\\\     1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\\\     1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\\\     1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\end{bmatrix} $$</p> <p>The Golay code has the following parameters:</p> <ul> <li>Length: $23$</li> <li>Dimension: $12$</li> <li>Minimum distance: $7$</li> </ul> Notes <ul> <li>The binary Golay code is a perfect code.</li> </ul> <p>Attributes:</p> <ul> <li> <code>extended</code> (<code>bool</code>)         \u2013          <p>If <code>True</code>, constructs the code in extended version. The default value is <code>False</code>.</p> </li> </ul> <p>This function returns the code in systematic form, with the information set on the left.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.GolayCode()\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(23, 12, 11)\n&gt;&gt;&gt; code.minimum_distance()\n7\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.GolayCode(extended=True)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(24, 12, 12)\n&gt;&gt;&gt; code.minimum_distance()\n8\n</code></pre>"},{"location":"ref/GoldSequence/","title":"komm.GoldSequence","text":"<p>Gold sequence [Not implemented yet].</p>"},{"location":"ref/HammingCode/","title":"komm.HammingCode","text":"<p>Hamming code. For a given parameter $\\mu \\geq 2$, it is the linear block code with check matrix whose columns are all the $2^\\mu - 1$ nonzero binary $\\mu$-tuples. The Hamming code has the following parameters:</p> <ul> <li>Length: $n = 2^\\mu - 1$</li> <li>Dimension: $k = 2^\\mu - \\mu - 1$</li> <li>Redundancy: $m = \\mu$</li> <li>Minimum distance: $d = 3$</li> </ul> <p>In its extended version, the Hamming code has the following parameters:</p> <ul> <li>Length: $n = 2^\\mu$</li> <li>Dimension: $k = 2^\\mu - \\mu - 1$</li> <li>Redundancy: $m = \\mu + 1$</li> <li>Minimum distance: $d = 4$</li> </ul> <p>For more details, see LC04, Sec. 4.1.</p> Notes <ul> <li>For $\\mu = 2$ it reduces to the repetition code of length $3$.</li> <li>Its dual is the simplex code.</li> <li>Hamming codes are perfect codes.</li> </ul> <p>Attributes:</p> <ul> <li> <code>mu</code> (<code>int</code>)         \u2013          <p>The parameter $\\mu$ of the code. Must satisfy $\\mu \\geq 2$.</p> </li> <li> <code>extended</code> (<code>bool</code>)         \u2013          <p>Whether to use the extended version of the Hamming code. Default is <code>False</code>.</p> </li> </ul> <p>This function returns the code in systematic form, with the information set on the left.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.HammingCode(3)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(7, 4, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1, 0],\n       [0, 1, 0, 0, 1, 0, 1],\n       [0, 0, 1, 0, 0, 1, 1],\n       [0, 0, 0, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.check_matrix\narray([[1, 1, 0, 1, 1, 0, 0],\n       [1, 0, 1, 1, 0, 1, 0],\n       [0, 1, 1, 1, 0, 0, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n3\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.HammingCode(3, extended=True)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(8, 4, 4)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1, 0, 1],\n       [0, 1, 0, 0, 1, 0, 1, 1],\n       [0, 0, 1, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.check_matrix\narray([[1, 1, 0, 1, 1, 0, 0, 0],\n       [1, 0, 1, 1, 0, 1, 0, 0],\n       [0, 1, 1, 1, 0, 0, 1, 0],\n       [1, 1, 1, 0, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n4\n</code></pre>"},{"location":"ref/HuffmanCode/","title":"komm.HuffmanCode","text":"<p>Binary Huffman code. It is an optimal (minimal expected rate) fixed-to-variable length code for a given probability mass function. For more details, see Say06, Sec. 3.2.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>ArrayLike</code>)         \u2013          <p>The probability mass function of the source.</p> </li> <li> <code>source_block_size</code> (<code>int</code>)         \u2013          <p>The source block size $k$. The default value is $k = 1$.</p> </li> <li> <code>policy</code> (<code>Literal['high', 'low']</code>)         \u2013          <p>The policy to be used when constructing the code. It must be either <code>'high'</code> (move combined symbols as high as possible) or <code>'low'</code> (move combined symbols as low as possible). The default value is <code>'high'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pmf = [0.7, 0.15, 0.15]\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.HuffmanCode(pmf)\n&gt;&gt;&gt; code.enc_mapping\n{(0,): (0,),\n (1,): (1, 1),\n (2,): (1, 0)}\n&gt;&gt;&gt; code.rate(pmf)\nnp.float64(1.3)\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.HuffmanCode(pmf, 2)\n&gt;&gt;&gt; code.enc_mapping\n{(0, 0): (1,),\n (0, 1): (0, 0, 0, 0),\n (0, 2): (0, 1, 1),\n (1, 0): (0, 1, 0),\n (1, 1): (0, 0, 0, 1, 1, 1),\n (1, 2): (0, 0, 0, 1, 1, 0),\n (2, 0): (0, 0, 1),\n (2, 1): (0, 0, 0, 1, 0, 1),\n (2, 2): (0, 0, 0, 1, 0, 0)}\n&gt;&gt;&gt; code.rate(pmf)\nnp.float64(1.1975)\n</code></pre>"},{"location":"ref/KasamiSequence/","title":"komm.KasamiSequence","text":"<p>Kasami sequence [Not implemented yet].</p>"},{"location":"ref/LFSRSequence/","title":"komm.LFSRSequence","text":"<p>Linear-feedback shift register (LFSR) sequence. It is a binary sequence obtained from the output of a LFSR. The LFSR feedback taps are specified as a binary polynomial $p(X)$ of degree $n$, called the feedback polynomial. More specifically: if bit $i$ of the LFSR is tapped, for $i \\in [1 : n]$, then the coefficient of $X^i$ in $p(X)$ is $1$; otherwise, it is $0$; moreover, the coefficient of $X^0$ in $p(X)$ is always $1$. For example, the feedback polynomial corresponding to the LFSR in the figure below is $p(X) = X^5 + X^2 + 1$, whose integer representation is <code>0b100101</code>.</p> <p></p> <p>The start state of the machine is specified by the so called start state polynomial. More specifically, the coefficient of $X^i$ in the start state polynomial is equal to the initial value of bit $i$ of the LFSR.</p> Maximum-length sequences <p>If the feedback polynomial $p(X)$ is primitive, then the corresponding LFSR sequence will be a maximum-length sequence (MLS). Such sequences have the following cyclic autocorrelation: $$     \\tilde{R}[\\ell] =     \\begin{cases}         L, &amp; \\ell = 0, \\, \\pm L, \\, \\pm 2L, \\ldots, \\\\         -1, &amp; \\text{otherwise},     \\end{cases} $$ where $L$ is the length of the sequence.</p> References <ol> <li>https://en.wikipedia.org/wiki/Linear-feedback_shift_register</li> <li>https://en.wikipedia.org/wiki/Maximum_length_sequence</li> </ol>"},{"location":"ref/LFSRSequence/#__init__","title":"<code>__init__</code>","text":"<p>Default constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>feedback_polynomial</code> (<code>BinaryPolynomial | int</code>)         \u2013          <p>The feedback polynomial of the LFSR, specified either as a binary polynomial or as an integer to be converted to the former.</p> </li> <li> <code>start_state_polynomial</code> (<code>Optional[BinaryPolynomial | int]</code>)         \u2013          <p>The start state polynomial of the LFSR, specified either as a binary polynomial or as an integer to be converted to the former. The default value is <code>0b1</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lfsr = komm.LFSRSequence(feedback_polynomial=0b100101)\n&gt;&gt;&gt; lfsr.bit_sequence\narray([0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1])\n&gt;&gt;&gt; lfsr.cyclic_autocorrelation()\narray([31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])\n</code></pre> <p>See also the class method <code>maximum_length_sequence</code> for a more convenient way to construct a maximum-length sequence.</p>"},{"location":"ref/LFSRSequence/#maximum_length_sequence","title":"<code>maximum_length_sequence</code>  <code>classmethod</code>","text":"<p>Constructs a maximum-length sequences (MLS) of a given degree. The feedback polynomial $p(X)$ is chosen according to the following table of primitive polynomials.</p> Degree $n$ Feedback polynomial $p(X)$ Degree $n$ Feedback polynomial $p(X)$ $1$ <code>0b11</code> $9$ <code>0b1000010001</code> $2$ <code>0b111</code> $10$ <code>0b10000001001</code> $3$ <code>0b1011</code> $11$ <code>0b100000000101</code> $4$ <code>0b10011</code> $12$ <code>0b1000001010011</code> $5$ <code>0b100101</code> $13$ <code>0b10000000011011</code> $6$ <code>0b1000011</code> $14$ <code>0b100010001000011</code> $7$ <code>0b10001001</code> $15$ <code>0b1000000000000011</code> $8$ <code>0b100011101</code> $16$ <code>0b10001000000001011</code> <p>Parameters:</p> <ul> <li> <code>degree</code> (<code>int</code>)         \u2013          <p>The degree $n$ of the MLS. Only degrees in the range $[1 : 16]$ are implemented.</p> </li> <li> <code>start_state_polynomial</code> (<code>Optional[BinaryPolynomial | int]</code>)         \u2013          <p>See the corresponding parameter of the default constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.LFSRSequence.maximum_length_sequence(degree=5)\nLFSRSequence(feedback_polynomial=0b100101)\n</code></pre>"},{"location":"ref/LFSRSequence/#feedback_polynomial","title":"<code>feedback_polynomial</code>  <code>property</code>","text":"<p>The feedback polynomial $p(X)$ of the LFSR.</p>"},{"location":"ref/LFSRSequence/#start_state_polynomial","title":"<code>start_state_polynomial</code>  <code>property</code>","text":"<p>The start state polynomial of the LFSR.</p>"},{"location":"ref/LloydMaxQuantizer/","title":"komm.LloydMaxQuantizer","text":"<p>Lloyd\u2013Max scalar quantizer. It is a scalar quantizer that minimizes the mean-squared error (MSE) between the input signal $X$ and its quantized version. For more details, see Say06, Sec. 9.6.1.</p> <p>Parameters:</p> <ul> <li> <code>input_pdf</code> (<code>Callable[[NDArray[float64]], NDArray[float64]]</code>)         \u2013          <p>The probability density function $f_X(x)$ of the input signal.</p> </li> <li> <code>input_range</code> (<code>tuple[float, float]</code>)         \u2013          <p>The range $(x_\\mathrm{min}, x_\\mathrm{max})$ of the input signal.</p> </li> <li> <code>num_levels</code> (<code>int</code>)         \u2013          <p>The number $L$ of quantization levels. It must be greater than $1$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; uniform_pdf = lambda x: 1/8 * (np.abs(x) &lt;= 4)\n&gt;&gt;&gt; quantizer = komm.LloydMaxQuantizer(\n...     input_pdf=uniform_pdf,\n...     input_range=(-4, 4),\n...     num_levels=8,\n... )\n&gt;&gt;&gt; quantizer.levels\narray([-3.5, -2.5, -1.5, -0.5,  0.5,  1.5,  2.5,  3.5])\n&gt;&gt;&gt; quantizer.thresholds\narray([-3., -2., -1.,  0.,  1.,  2.,  3.])\n</code></pre> <pre><code>&gt;&gt;&gt; gaussian_pdf = lambda x: 1/np.sqrt(2*np.pi) * np.exp(-x**2/2)\n&gt;&gt;&gt; quantizer = komm.LloydMaxQuantizer(\n...     input_pdf=gaussian_pdf,\n...     input_range=(-5, 5),\n...     num_levels=8,\n... )\n&gt;&gt;&gt; quantizer.levels.round(3)\narray([-2.152, -1.344, -0.756, -0.245,  0.245,  0.756,  1.344,  2.152])\n&gt;&gt;&gt; quantizer.thresholds.round(3)\narray([-1.748, -1.05 , -0.501, -0.   ,  0.501,  1.05 ,  1.748])\n</code></pre>"},{"location":"ref/ManchesterPulse/","title":"komm.ManchesterPulse","text":"<p>Manchester pulse. It is a pulse with waveform given by $$     h(t) =     \\begin{cases}         -1, &amp; 0 \\leq t &lt;  1/2, \\\\         1, &amp; 1/2 \\leq t &lt; 1, \\\\         0, &amp; \\text{otherwise},     \\end{cases} $$ and spectrum given by $$     \\hat{h}(f) = \\operatorname{sinc}^2 \\left( \\frac{f}{2} \\right) \\, \\sin^2 \\left( \\frac{\\pi f}{2} \\right). $$</p> <p>The Manchester pulse is depicted below.</p> <p></p> <p>Attributes:</p> <p>(No attributes)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.ManchesterPulse()\n&gt;&gt;&gt; pulse.waveform([-0.50, -0.25,  0.00,  0.25,  0.50,  0.75,  1.00])\narray([ 0.,  0., -1., -1.,  1.,  1.,  0.])\n&gt;&gt;&gt; pulse.spectrum([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.5249, 0.4053, 0.1391, 0.    , 0.1391, 0.4053, 0.5249])\n</code></pre>"},{"location":"ref/Modulation/","title":"komm.Modulation","text":"<p>General modulation scheme. A modulation scheme of order $M = 2^m$ is defined by a constellation $\\mathbf{X}$, which is a real or complex vector of length $M$, and a binary labeling $\\mathbf{Q}$, which is an $M \\times m$ binary matrix whose rows are all distinct. The $i$-th element of $\\mathbf{X}$, for $i \\in [0:M)$, is denoted by $x_i$ and is called the $i$-th constellation symbol. The $i$-th row of $\\mathbf{Q}$, for $i \\in [0:M)$, is called the binary representation of the $i$-th constellation symbol.</p> <p>For more details, see SA15, Sec. 2.5.</p>"},{"location":"ref/Modulation/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>constellation</code> (<code>Array1D[float] | Array1D[complex]</code>)         \u2013          <p>The constellation $\\mathbf{X}$ of the modulation. Must be a 1D-array containing $M$ real or complex numbers.</p> </li> <li> <code>labeling</code> (<code>Array2D[int]</code>)         \u2013          <p>The binary labeling $\\mathbf{Q}$ of the modulation. Must be a 2D-array of shape $(M, m)$ where each row is a distinct binary $m$-tuple.</p> </li> </ul> <p>Examples:</p> <p>The real modulation scheme depicted in the figure below has $M = 4$ and $m = 2$.</p> <p></p> <p>The constellation is given by $$     \\mathbf{X} = \\begin{bmatrix}         -0.5 \\\\         0.0 \\\\         0.5 \\\\         2.0     \\end{bmatrix}, $$ and the binary labeling is given by $$     \\mathbf{Q} = \\begin{bmatrix}         1 &amp; 0 \\\\         1 &amp; 1 \\\\         0 &amp; 1 \\\\         0 &amp; 0     \\end{bmatrix}. $$</p> <pre><code>&gt;&gt;&gt; komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\nModulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n</code></pre> <p>The complex modulation scheme depicted in the figure below has $M = 4$ and $m = 2$.</p> <p></p> <p>The constellation is given by $$     \\mathbf{X} = \\begin{bmatrix}         0  \\\\         -1  \\\\         1  \\\\         \\mathrm{j}     \\end{bmatrix}, $$ and the binary labeling is given by $$     \\mathbf{Q} = \\begin{bmatrix}         0 &amp; 0 \\\\         0 &amp; 1 \\\\         1 &amp; 0 \\\\         1 &amp; 1     \\end{bmatrix}. $$</p> <pre><code>&gt;&gt;&gt; komm.Modulation(constellation=[0, -1, 1, 1j], labeling=[[0, 0], [0, 1], [1, 0], [1, 1]])\nModulation(constellation=[0j, (-1+0j), (1+0j), 1j], labeling=[[0, 0], [0, 1], [1, 0], [1, 1]])\n</code></pre>"},{"location":"ref/Modulation/#constellation","title":"<code>constellation</code>  <code>property</code>","text":"<p>The constellation $\\mathbf{X}$ of the modulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.constellation\narray([-0.5,  0. ,  0.5,  2. ])\n</code></pre>"},{"location":"ref/Modulation/#labeling","title":"<code>labeling</code>  <code>property</code>","text":"<p>The binary labeling $\\mathbf{Q}$ of the modulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.labeling\narray([[1, 0],\n       [1, 1],\n       [0, 1],\n       [0, 0]])\n</code></pre>"},{"location":"ref/Modulation/#order","title":"<code>order</code>  <code>property</code>","text":"<p>The order $M$ of the modulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.order\n4\n</code></pre>"},{"location":"ref/Modulation/#bits_per_symbol","title":"<code>bits_per_symbol</code>  <code>property</code>","text":"<p>The number $m$ of bits per symbol of the modulation. It is given by $m = \\log_2 M$, where $M$ is the order of the modulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.bits_per_symbol\n2\n</code></pre>"},{"location":"ref/Modulation/#energy_per_symbol","title":"<code>energy_per_symbol</code>  <code>property</code>","text":"<p>The average symbol energy $E_\\mathrm{s}$ of the constellation. It assumes equiprobable symbols. It is given by $$     E_\\mathrm{s} = \\frac{1}{M} \\sum_{i \\in [0:M)} |x_i|^2, $$ where $|x_i|^2$ is the energy of constellation symbol $x_i$, and $M$ is the order of the modulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.energy_per_symbol\nnp.float64(1.125)\n</code></pre> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[0, -1, 1, 1j], labeling=[[0, 0], [0, 1], [1, 0], [1, 1]])\n&gt;&gt;&gt; mod.energy_per_symbol\nnp.float64(0.75)\n</code></pre>"},{"location":"ref/Modulation/#energy_per_bit","title":"<code>energy_per_bit</code>  <code>property</code>","text":"<p>The average bit energy $E_\\mathrm{b}$ of the constellation. It assumes equiprobable symbols. It is given by $E_\\mathrm{b} = E_\\mathrm{s} / m$, where $E_\\mathrm{s}$ is the average symbol energy, and $m$ is the number of bits per symbol of the modulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.energy_per_bit\nnp.float64(0.5625)\n</code></pre> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[0, -1, 1, 1j], labeling=[[0, 0], [0, 1], [1, 0], [1, 1]])\n&gt;&gt;&gt; mod.energy_per_bit\nnp.float64(0.375)\n</code></pre>"},{"location":"ref/Modulation/#symbol_mean","title":"<code>symbol_mean</code>  <code>property</code>","text":"<p>The mean $\\mu_\\mathrm{s}$ of the constellation. It assumes equiprobable symbols. It is given by $$     \\mu_\\mathrm{s} = \\frac{1}{M} \\sum_{i \\in [0:M)} x_i. $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.symbol_mean\nnp.float64(0.5)\n</code></pre> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[0, -1, 1, 1j], labeling=[[0, 0], [0, 1], [1, 0], [1, 1]])\n&gt;&gt;&gt; mod.symbol_mean\nnp.complex128(0.25j)\n</code></pre>"},{"location":"ref/Modulation/#minimum_distance","title":"<code>minimum_distance</code>  <code>property</code>","text":"<p>The minimum Euclidean distance $d_\\mathrm{min}$ of the constellation. It is given by $$     d_\\mathrm{min} = \\min_{i, j \\in [0:M), ~ i \\neq j} |x_i - x_j|. $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.minimum_distance\nnp.float64(0.5)\n</code></pre> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[0, -1, 1, 1j], labeling=[[0, 0], [0, 1], [1, 0], [1, 1]])\n&gt;&gt;&gt; mod.minimum_distance\nnp.float64(1.0)\n</code></pre>"},{"location":"ref/Modulation/#modulate","title":"<code>modulate</code>","text":"<p>Modulates a sequence of bits to its corresponding constellation symbols.</p> <p>Parameters:</p> <ul> <li> <code>bits</code> (<code>Array1D[int]</code>)         \u2013          <p>The bits to be modulated. It should be a 1D-array of integers in the set $\\{ 0, 1 \\}$. Its length must be a multiple of $m$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>symbols</code>  (<code>Array1D[complex] | Array1D[float]</code>)          \u2013          <p>The constellation symbols corresponding to <code>bits</code>. It is a 1D-array of real or complex numbers. Its length is equal to the length of <code>bits</code> divided by $m$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; mod.modulate([0, 0, 1, 1, 0, 0, 1, 0])\narray([ 2. ,  0. ,  2. , -0.5])\n</code></pre>"},{"location":"ref/Modulation/#demodulate","title":"<code>demodulate</code>","text":"<p>Demodulates a sequence of received points to a sequence of bits.</p> <p>Parameters:</p> <ul> <li> <code>received</code> (<code>Array1D[complex] | Array1D[float]</code>)         \u2013          <p>The received points to be demodulated. It should be a 1D-array of real or complex numbers. It may be of any length.</p> </li> <li> <code>decision_method</code> (<code>str</code>)         \u2013          <p>The decision method to be used. It should be either <code>'hard'</code> (corresponding to hard-decision decoding) or <code>'soft'</code> (corresponding to soft-decision decoding). The default value is <code>'hard'</code>.</p> </li> <li> <code>kwargs</code>         \u2013          <p>Keyword arguments to be passed to the demodulator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bits_or_soft_bits</code>  (<code>Array1D[int] | Array1D[float]</code>)          \u2013          <p>The (hard or soft) bits corresponding to <code>received</code>. In the case of hard-decision decoding, it is a 1D-array of bits (integers in the set $\\{ 0, 1 \\}$); in the case of of soft-decision decoding, it is a 1D-array of L-values (real numbers, where positive values correspond to bit $0$ and negative values correspond to bit $1$). Its length is equal to the length of <code>received</code> multiplied by $m$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.Modulation(constellation=[-0.5, 0.0, 0.5, 2.0], labeling=[[1, 0], [1, 1], [0, 1], [0, 0]])\n&gt;&gt;&gt; received = [2.17, -0.06, 1.94, -0.61]\n</code></pre> <pre><code>&gt;&gt;&gt; mod.demodulate(received)\narray([0, 0, 1, 1, 0, 0, 1, 0])\n</code></pre> <pre><code>&gt;&gt;&gt; mod.demodulate(received, decision_method='soft', channel_snr=100.0)\narray([ 416.        ,  245.33333333,  -27.5555556 ,  -16.88888889,\n        334.22222222,  184.        , -108.44444444,   32.        ])\n</code></pre>"},{"location":"ref/PAModulation/","title":"komm.PAModulation","text":"<p>Pulse-amplitude modulation (PAM). It is a real modulation scheme in which the constellation symbols are uniformly arranged in the real line and have zero mean. More precisely, the the $i$-th constellation symbol is given by $$     x_i = A \\left( 2i - M + 1 \\right), \\quad i \\in [0 : M), $$ where $M$ is the order (a power of $2$), and $A$ is the base amplitude of the modulation. The PAM constellation is depicted below for $M = 8$.</p> <p></p>"},{"location":"ref/PAModulation/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>order</code> (<code>int</code>)         \u2013          <p>The order $M$ of the modulation. It must be a power of $2$.</p> </li> <li> <code>base_amplitude</code> (<code>Optional[float]</code>)         \u2013          <p>The base amplitude $A$ of the constellation. The default value is <code>1.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling of the modulation. Can be specified either as a 2D-array of integers (see base class for details), or as a string. In the latter case, the string must be either <code>'natural'</code> or <code>'reflected'</code>. The default value is <code>'reflected'</code>, corresponding to the Gray labeling.</p> </li> </ul> <p>Examples:</p> <p>The PAM modulation with order $M = 4$, base amplitude $A = 1$, and Gray labeling is depicted below.</p> <p></p> <pre><code>&gt;&gt;&gt; pam = komm.PAModulation(4)\n&gt;&gt;&gt; pam.constellation\narray([-3., -1.,  1.,  3.])\n&gt;&gt;&gt; pam.labeling\narray([[0, 0],\n       [1, 0],\n       [1, 1],\n       [0, 1]])\n&gt;&gt;&gt; pam.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([-3.,  1., -3., -1., -1.])\n</code></pre>"},{"location":"ref/PSKModulation/","title":"komm.PSKModulation","text":"<p>Phase-shift keying (PSK) modulation. It is a complex modulation scheme in which the constellation symbols are uniformly arranged in a circle. More precisely, the the $i$-th constellation symbol is given by $$     x_i = A \\exp \\left( \\mathrm{j} \\frac{2 \\pi i}{M} \\right) \\exp(\\mathrm{j} \\phi), \\quad i \\in [0 : M), $$ where $M$ is the order (a power of $2$), $A$ is the amplitude, and $\\phi$ is the phase offset of the modulation. The PSK constellation is depicted below for $M = 8$.</p> <p></p>"},{"location":"ref/PSKModulation/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>order</code> (<code>int</code>)         \u2013          <p>The order $M$ of the modulation. It must be a power of $2$.</p> </li> <li> <code>amplitude</code> (<code>Optional[float]</code>)         \u2013          <p>The amplitude $A$ of the constellation. The default value is <code>1.0</code>.</p> </li> <li> <code>phase_offset</code> (<code>Optional[float]</code>)         \u2013          <p>The phase offset $\\phi$ of the constellation. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling of the modulation. Can be specified either as a 2D-array of integers (see base class for details), or as a string. In the latter case, the string must be either <code>'natural'</code> or <code>'reflected'</code>. The default value is <code>'reflected'</code>, corresponding to the Gray labeling.</p> </li> </ul> <p>The PSK modulation with order $M = 4$, base amplitude $A = 1$, phase offset $\\phi = \\pi/4$, and Gray labeling is depicted below.</p> <p></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psk = komm.PSKModulation(4, phase_offset=np.pi/4.0)\n&gt;&gt;&gt; psk.constellation\narray([ 0.70710678+0.70710678j, -0.70710678+0.70710678j, -0.70710678-0.70710678j,  0.70710678-0.70710678j])\n&gt;&gt;&gt; psk.labeling\narray([[0, 0],\n       [1, 0],\n       [1, 1],\n       [0, 1]])\n&gt;&gt;&gt; psk.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([ 0.70710678+0.70710678j, -0.70710678-0.70710678j,  0.70710678+0.70710678j, -0.70710678+0.70710678j, -0.70710678+0.70710678j])\n</code></pre>"},{"location":"ref/Pulse/","title":"komm.Pulse","text":"<p>General pulse [Not implemented yet].</p>"},{"location":"ref/QAModulation/","title":"komm.QAModulation","text":"<p>Quadrature-amplitude modulation (QAM). It is a complex modulation scheme in which the constellation is given as a Cartesian product of two PAM constellations, namely, the in-phase constellation, and the quadrature constellation. More precisely, the $i$-th constellation symbol is given by $$     \\begin{aligned}         x_i = \\left[ A_\\mathrm{I} \\left( 2i_\\mathrm{I} - M_\\mathrm{I} + 1 \\right) + \\mathrm{j} A_\\mathrm{Q} \\left( 2i_\\mathrm{Q} - M_\\mathrm{Q} + 1 \\right) \\right] \\exp(\\mathrm{j}\\phi), \\quad             &amp;  i \\in [0 : M), \\\\             &amp; i_\\mathrm{I} = i \\bmod M_\\mathrm{I}, \\\\             &amp; i_\\mathrm{Q} = \\lfloor i / M_\\mathrm{I} \\rfloor,     \\end{aligned} $$ where $M_\\mathrm{I}$ and $M_\\mathrm{Q}$ are the orders (powers of $2$), and $A_\\mathrm{I}$ and $A_\\mathrm{Q}$ are the base amplitudes of the in-phase and quadrature constellations, respectively. Also, $\\phi$ is the phase offset. The order of the resulting complex-valued constellation is $M = M_\\mathrm{I} M_\\mathrm{Q}$, a power of $2$. The QAM constellation is depicted below for $(M_\\mathrm{I}, M_\\mathrm{Q}) = (4, 4)$ with ($A_\\mathrm{I}, A_\\mathrm{Q}) = (A, A)$; and for $(M_\\mathrm{I}, M_\\mathrm{Q}) = (4, 2)$ with $(A_\\mathrm{I}, A_\\mathrm{Q}) = (A, 2A)$; in both cases, $\\phi = 0$.</p> <p> </p>"},{"location":"ref/QAModulation/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>orders</code> (<code>tuple(int, int) | int</code>)         \u2013          <p>A tuple $(M_\\mathrm{I}, M_\\mathrm{Q})$ with the orders of the in-phase and quadrature constellations, respectively; both $M_\\mathrm{I}$ and $M_\\mathrm{Q}$ must be powers of $2$. If specified as a single integer $M$, then it is assumed that $M_\\mathrm{I} = M_\\mathrm{Q} = \\sqrt{M}$; in this case, $M$ must be an square power of $2$.</p> </li> <li> <code>base_amplitudes</code> (<code>Optional[tuple(float, float) | float]</code>)         \u2013          <p>A tuple $(A_\\mathrm{I}, A_\\mathrm{Q})$ with the base amplitudes of the in-phase and quadrature constellations, respectively. If specified as a single float $A$, then it is assumed that $A_\\mathrm{I} = A_\\mathrm{Q} = A$. The default value is $1.0$.</p> </li> <li> <code>phase_offset</code> (<code>Optional[float]</code>)         \u2013          <p>The phase offset $\\phi$ of the constellation. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling of the modulation. Can be specified either as a 2D-array of integers (see base class for details), or as a string. In the latter case, the string must be either <code>'natural_2d'</code> or <code>'reflected_2d'</code>. The default value is <code>'reflected_2d'</code>, corresponding to the Gray labeling.</p> </li> </ul> <p>Examples:</p> <p>The square $16$-QAM modulation with $(M_\\mathrm{I}, M_\\mathrm{Q}) = (4, 4)$ and $(A_\\mathrm{I}, A_\\mathrm{Q}) = (1, 1)$, and Gray labeling is depicted below.</p> <p></p> <pre><code>&gt;&gt;&gt; qam = komm.QAModulation(16)\n&gt;&gt;&gt; qam.constellation\narray([-3.-3.j, -1.-3.j,  1.-3.j,  3.-3.j,\n       -3.-1.j, -1.-1.j,  1.-1.j,  3.-1.j,\n       -3.+1.j, -1.+1.j,  1.+1.j,  3.+1.j,\n       -3.+3.j, -1.+3.j,  1.+3.j,  3.+3.j])\n&gt;&gt;&gt; qam.labeling\narray([[0, 0, 0, 0], [1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0],\n       [0, 0, 1, 0], [1, 0, 1, 0], [1, 1, 1, 0], [0, 1, 1, 0],\n       [0, 0, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1],\n       [0, 0, 0, 1], [1, 0, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]])\n&gt;&gt;&gt; qam.modulate([0, 0, 1, 1, 0, 0, 1, 0])\narray([-3.+1.j, -3.-1.j])\n</code></pre> <p>The rectangular $8$-QAM modulation with $(M_\\mathrm{I}, M_\\mathrm{Q}) = (4, 2)$ and $(A_\\mathrm{I}, A_\\mathrm{Q}) = (1, 2)$, and Gray labeling is depicted below.</p> <p></p> <pre><code>&gt;&gt;&gt; qam = komm.QAModulation(orders=(4, 2), base_amplitudes=(1.0, 2.0))\n&gt;&gt;&gt; qam.constellation\narray([-3.-2.j, -1.-2.j,  1.-2.j,  3.-2.j,\n       -3.+2.j, -1.+2.j,  1.+2.j,  3.+2.j])\n&gt;&gt;&gt; qam.labeling\narray([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0],\n       [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]])\n&gt;&gt;&gt; qam.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1])\narray([-3.+2.j, -1.-2.j, -1.+2.j])\n</code></pre>"},{"location":"ref/RaisedCosinePulse/","title":"komm.RaisedCosinePulse","text":"<p>Raised cosine pulse. It is a pulse with waveform given by $$     h(t) = \\operatorname{sinc}(t) \\frac{\\cos(\\pi \\alpha t)}{1 - (2 \\alpha t)^2}, $$ where $\\alpha$ is the roll-off factor, which must satisfy $0 \\leq \\alpha \\leq 1$. Its spectrum is given by $$     \\hat{h}(f) = \\begin{cases}         1, &amp; |f| \\leq f_1, \\\\[1ex]         \\dfrac{1}{2} \\left( 1 + \\cos \\left( \\pi \\dfrac{|f| - f_1}{f_2 - f_1}\\right) \\right), &amp; f_1 \\leq |f| \\leq f_2, \\\\[1ex]         0, &amp; \\text{otherwise}.     \\end{cases} $$ where $f_1 = (1 - \\alpha) / 2$ and $f_2 = (1 + \\alpha) / 2$.</p> <p>The raised cosine pulse is depicted below for $\\alpha = 0.25$, and for $\\alpha = 0.75$.</p> <p> </p> <p>For more details, see PS08, Sec. 9.2-1.</p> Notes <ul> <li>For $\\alpha = 0$ it reduces to the sinc pulse.</li> <li>For $\\alpha = 1$ it becomes what is known as the full cosine roll-off pulse.</li> </ul> <p>Attributes:</p> <ul> <li> <code>rolloff</code> (<code>float</code>)         \u2013          <p>The roll-off factor $\\alpha$ of the pulse. Must satisfy $0 \\leq \\alpha \\leq 1$. The default value is <code>1.0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RaisedCosinePulse(rolloff=0.25)\n&gt;&gt;&gt; pulse.waveform([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.2904, 0.6274, 0.897 , 1.    , 0.897 , 0.6274, 0.2904])\n&gt;&gt;&gt; pulse.spectrum([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75])\narray([0. , 0.5, 1. , 1. , 1. , 0.5, 0. ])\n</code></pre>"},{"location":"ref/ReceiveFilter/","title":"komm.ReceiveFilter","text":"<p>Receive filter [Not implemented yet].</p>"},{"location":"ref/RectangularPulse/","title":"komm.RectangularPulse","text":"<p>Rectangular pulse. It is a pulse with waveform given by $$     h(t) =     \\begin{cases}         1, &amp; 0 \\leq t &lt; w, \\\\         0, &amp; \\text{otherwise}.     \\end{cases}     = \\mathrm{rect}\\left(\\frac{t}{w}\\right), $$ where $w$ is the width of the pulse, which must satisfy $0 \\leq w \\leq 1$. Its spectrum is given by $$     \\hat{h}(f) = w \\, \\operatorname{sinc}(w f). $$</p> <p>The rectangular pulse is depicted below for $w = 1$, and for $w = 0.5$.</p> <p> </p> Notes <ul> <li>For $w = 1$ it is also called the NRZ pulse.</li> <li>For $w = 0.5$ it is also called the halfway RZ pulse.</li> </ul> <p>Attributes:</p> <ul> <li> <code>width</code> (<code>Optional[float]</code>)         \u2013          <p>The width $w$ of the pulse. Must satisfy $0 \\leq w \\leq 1$. The default value is <code>1.0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(width=1.0)  # NRZ pulse\n&gt;&gt;&gt; pulse.waveform([-0.50, -0.25,  0.00,  0.25,  0.50,  0.75,  1.00])\narray([0., 0., 1., 1., 1., 1., 0.])\n&gt;&gt;&gt; pulse.spectrum([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.3001, 0.6366, 0.9003, 1.    , 0.9003, 0.6366, 0.3001])\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(width=0.5)  # Halfway RZ pulse\n&gt;&gt;&gt; pulse.waveform([-0.50, -0.25,  0.00,  0.25,  0.50,  0.75,  1.00])\narray([0., 0., 1., 1., 0., 0., 0.])\n&gt;&gt;&gt; pulse.spectrum([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.3921, 0.4502, 0.4872, 0.5   , 0.4872, 0.4502, 0.3921])\n</code></pre>"},{"location":"ref/ReedMullerCode/","title":"komm.ReedMullerCode","text":"<p>Reed\u2013Muller code. It is a linear block code defined by two integers $\\rho$ and $\\mu$, which must satisfy $0 \\leq \\rho &lt; \\mu$. See references for more details. The resulting code is denoted by $\\mathrm{RM}(\\rho, \\mu)$, and has the following parameters:</p> <ul> <li>Length: $n = 2^{\\mu}$</li> <li>Dimension: $k = 1 + {\\mu \\choose 1} + \\cdots + {\\mu \\choose \\rho}$</li> <li>Redundancy: $m = 1 + {\\mu \\choose 1} + \\cdots + {\\mu \\choose \\mu - \\rho - 1}$</li> <li>Minimum distance: $d = 2^{\\mu - \\rho}$</li> </ul> <p>For more details, see LC04, Sec. 4.3.</p> Notes <ul> <li>For $\\rho = 0$ it reduces to a repetition code.</li> <li>For $\\rho = 1$ it reduces to a lengthened simplex code.</li> <li>For $\\rho = \\mu - 2$ it reduces to an extended Hamming code.</li> <li>For $\\rho = \\mu - 1$ it reduces to a single parity check code.</li> </ul> <p>Attributes:</p> <ul> <li> <code>rho</code> (<code>int</code>)         \u2013          <p>The parameter $\\rho$ of the code.</p> </li> <li> <code>mu</code> (<code>int</code>)         \u2013          <p>The parameter $\\mu$ of the code.</p> </li> </ul> <p>The parameters must satisfy $0 \\leq \\rho &lt; \\mu$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.ReedMullerCode(1, 5)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(32, 6, 26)\n&gt;&gt;&gt; code.generator_matrix\narray([[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n       [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],\n       [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n16\n</code></pre>"},{"location":"ref/ReedMullerCode/#reed_partitions","title":"<code>reed_partitions: list[npt.NDArray[np.int_]]</code>  <code>property</code>","text":"<p>The Reed partitions of the code. See LC04, Sec. 4.3.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.ReedMullerCode(2, 4)\n&gt;&gt;&gt; code.reed_partitions[1]\narray([[ 0,  1,  4,  5],\n       [ 2,  3,  6,  7],\n       [ 8,  9, 12, 13],\n       [10, 11, 14, 15]])\n&gt;&gt;&gt; code.reed_partitions[8]\narray([[ 0,  4],\n       [ 1,  5],\n       [ 2,  6],\n       [ 3,  7],\n       [ 8, 12],\n       [ 9, 13],\n       [10, 14],\n       [11, 15]])\n</code></pre>"},{"location":"ref/RepetitionCode/","title":"komm.RepetitionCode","text":"<p>Repetition code. For a given length $n \\geq 1$, it is the linear block code whose only two codewords are $00 \\cdots 0$ and $11 \\cdots 1$. The repetition code has the following parameters:</p> <ul> <li>Length: $n$</li> <li>Dimension: $k = 1$</li> <li>Redundancy: $m = n - 1$</li> <li>Minimum distance: $d = n$</li> </ul> Notes <ul> <li>Its dual is the single parity check code.</li> </ul> <p>Attributes:</p> <ul> <li> <code>n</code> (<code>int</code>)         \u2013          <p>The length $n$ of the code. Must be a positive integer.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.RepetitionCode(5)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(5, 1, 4)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.check_matrix\narray([[1, 1, 0, 0, 0],\n       [1, 0, 1, 0, 0],\n       [1, 0, 0, 1, 0],\n       [1, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n5\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.RepetitionCode(16)\n&gt;&gt;&gt; code.codeword_weight_distribution()\narray([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n&gt;&gt;&gt; code.coset_leader_weight_distribution()\narray([    1,    16,   120,   560,  1820,  4368,  8008, 11440,  6435,\n           0,     0,     0,     0,     0,     0,     0,     0])\n</code></pre>"},{"location":"ref/RootRaisedCosinePulse/","title":"komm.RootRaisedCosinePulse","text":"<p>Root raised cosine pulse. It is a pulse with waveform given by $$     h(t) = \\frac{\\sin ( 2 \\pi f_1 t ) + 4 \\alpha t \\cos ( 2 \\pi f_2 t )}{\\pi t ( 1 - (4 \\alpha t)^2 )}, $$ where $\\alpha$ is the roll-off factor (which must satisfy $0 \\leq \\alpha \\leq 1$), $f_1 = (1 - \\alpha) / 2$, and $f_2 = (1 + \\alpha) / 2$. Its spectrum is given by the square root of the spectrum of the raised cosine pulse.</p> <p>The root raised cosine pulse is depicted below for $\\alpha = 0.25$, and for $\\alpha = 0.75$.</p> <p> </p> <p>Attributes:</p> <ul> <li> <code>rolloff</code> (<code>float</code>)         \u2013          <p>The roll-off factor $\\alpha$ of the pulse. Must satisfy $0 \\leq \\alpha \\leq 1$. The default value is <code>0.0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RootRaisedCosinePulse(rolloff=0.25)\n&gt;&gt;&gt; pulse.waveform([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.2379, 0.6218, 0.9432, 1.0683, 0.9432, 0.6218, 0.2379])\n&gt;&gt;&gt; pulse.spectrum([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.    , 0.7071, 1.    , 1.    , 1.    , 0.7071, 0.    ])\n</code></pre>"},{"location":"ref/ScalarQuantizer/","title":"komm.ScalarQuantizer","text":"<p>General scalar quantizer. It is defined by a list of levels, $v_0, v_1, \\ldots, v_{L-1}$, and a list of thresholds, $t_0, t_1, \\ldots, t_L$, satisfying $$     -\\infty = t_0 &lt; v_0 &lt; t_1 &lt; v_1 &lt; \\cdots &lt; t_{L - 1} &lt; v_{L - 1} &lt; t_L = +\\infty. $$ Given an input $x \\in \\mathbb{R}$, the output of the quantizer is given by $y = v_i$ if and only if $t_i \\leq x &lt; t_{i+1}$, where $i \\in [0:L)$. For more details, see Say06, Ch. 9.</p> <p>To invoke the quantizer, call the object giving the input signal as parameter (see example below).</p> <p>Attributes:</p> <ul> <li> <code>levels</code> (<code>Array1D[float]</code>)         \u2013          <p>The quantizer levels $v_0, v_1, \\ldots, v_{L-1}$. It should be a list floats of length $L$.</p> </li> <li> <code>thresholds</code> (<code>Array1D[float]</code>)         \u2013          <p>The quantizer finite thresholds $t_1, t_2, \\ldots, t_{L-1}$. It should be a list of floats of length $L - 1$.</p> </li> </ul> <p>Examples:</p> <p>The following example considers the $5$-level scalar quantizer whose characteristic (input \u00d7 output) curve is depicted in the figure below.</p> <p></p> <p>The levels are $$     v_0 = -2, ~ v_1 = -1, ~ v_2 = 0, ~ v_3 = 1, ~ v_4 = 2, $$ and the thresholds are $$     t_0 = -\\infty, ~ t_1 = -1.5, ~ t_2 = -0.3, ~ t_3 = 0.8, ~ t_4 = 1.4, ~ t_5 = \\infty. $$</p> <pre><code>&gt;&gt;&gt; quantizer = komm.ScalarQuantizer(levels=[-2.0, -1.0, 0.0, 1.0, 2.0], thresholds=[-1.5, -0.3, 0.8, 1.4])\n&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, num=11)\n&gt;&gt;&gt; y = quantizer(x)\n&gt;&gt;&gt; np.vstack([x, y])\narray([[-2.5, -2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ,  2.5],\n       [-2. , -2. , -1. , -1. , -1. ,  0. ,  0. ,  1. ,  2. ,  2. ,  2. ]])\n</code></pre>"},{"location":"ref/ScalarQuantizer/#num_levels","title":"<code>num_levels: int</code>  <code>property</code>","text":"<p>The number of quantization levels $L$.</p>"},{"location":"ref/SimplexCode/","title":"komm.SimplexCode","text":"<p>Simplex (maximum-length) code. For a given parameter $\\kappa \\geq 2$, it is the linear block code with generator matrix whose columns are all the $2^\\kappa - 1$ nonzero binary $\\kappa$-tuples. The simplex code (also known as maximum-length code) has the following parameters:</p> <ul> <li>Length: $n = 2^\\kappa - 1$</li> <li>Dimension: $k = \\kappa$</li> <li>Redundancy: $m = 2^\\kappa - \\kappa - 1$</li> <li>Minimum distance: $d = 2^{\\kappa - 1}$</li> </ul> <p>In its extended version, the simplex code has the following parameters:</p> <ul> <li>Length: $n = 2^\\kappa$</li> <li>Dimension: $k = \\kappa + 1$</li> <li>Redundancy: $m = 2^\\kappa - \\kappa - 1$</li> <li>Minimum distance: $d = 2^{\\kappa - 1}$</li> </ul> Notes <ul> <li>For $\\kappa = 2$ it reduces to the single parity check code of length $3$.</li> <li>Its dual is the Hamming code.</li> <li>Simplex codes are constant-weight codes.</li> </ul> <p>Attributes:</p> <ul> <li> <code>kappa</code> (<code>int</code>)         \u2013          <p>The parameter $\\kappa$ of the code. Must satisfy $\\kappa \\geq 2$.</p> </li> <li> <code>extended</code> (<code>bool</code>)         \u2013          <p>Whether to use the extended version of the Simplex code. Default is <code>False</code>.</p> </li> </ul> <p>This function constructs the code in systematic form, with the information set on the left.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.SimplexCode(3)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(7, 3, 4)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 1, 1, 0, 1],\n       [0, 1, 0, 1, 0, 1, 1],\n       [0, 0, 1, 0, 1, 1, 1]])\n&gt;&gt;&gt; code.check_matrix\narray([[1, 1, 0, 1, 0, 0, 0],\n       [1, 0, 1, 0, 1, 0, 0],\n       [0, 1, 1, 0, 0, 1, 0],\n       [1, 1, 1, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n4\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.SimplexCode(3, extended=True)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(8, 4, 4)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1, 0, 1],\n       [0, 1, 0, 0, 1, 0, 1, 1],\n       [0, 0, 1, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.check_matrix\narray([[1, 1, 0, 1, 1, 0, 0, 0],\n       [1, 0, 1, 1, 0, 1, 0, 0],\n       [0, 1, 1, 1, 0, 0, 1, 0],\n       [1, 1, 1, 0, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n4\n</code></pre>"},{"location":"ref/SincPulse/","title":"komm.SincPulse","text":"<p>Sinc pulse. It is a pulse with waveform given by $$     h(t) = \\operatorname{sinc}(t) = \\frac{\\sin(\\pi t)}{\\pi t}, $$ and spectrum given by $$     \\hat{h}(f) = \\begin{cases}         1, &amp; |f| &lt; \\frac{1}{2}, \\\\         0, &amp; \\text{otherwise}.     \\end{cases} $$</p> <p>The sinc pulse is depicted below.</p> <p></p> <p>For more details, see PS08, Sec. 9.2-1.</p> <p>Attributes:</p> <p>(No attributes)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.SincPulse()\n&gt;&gt;&gt; pulse.waveform([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75]).round(4)\narray([0.3001, 0.6366, 0.9003, 1.    , 0.9003, 0.6366, 0.3001])\n&gt;&gt;&gt; pulse.spectrum([-0.75, -0.50, -0.25,  0.00,  0.25,  0.50,  0.75])\narray([0., 0., 1., 1., 1., 0., 0.])\n</code></pre>"},{"location":"ref/SingleParityCheckCode/","title":"komm.SingleParityCheckCode","text":"<p>Single parity check code. For a given length $n \\geq 1$, it is the linear block code whose codewords are obtained by extending $n - 1$ information bits with a single parity-check bit. The repetition code has the following parameters:</p> <ul> <li>Length: $n$.</li> <li>Dimension: $k = n - 1$.</li> <li>Redundancy: $m = 1$.</li> <li>Minimum distance: $d = 2$.</li> </ul> Notes <ul> <li>Its dual is the repetition code.</li> </ul> <p>Attributes:</p> <ul> <li> <code>n</code> (<code>int</code>)         \u2013          <p>The length $n$ of the code. Must be a positive integer.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.SingleParityCheckCode(5)\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(5, 4, 1)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1],\n       [0, 1, 0, 0, 1],\n       [0, 0, 1, 0, 1],\n       [0, 0, 0, 1, 1]])\n&gt;&gt;&gt; code.check_matrix\narray([[1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.SingleParityCheckCode(16)\n&gt;&gt;&gt; code.codeword_weight_distribution()\narray([    1,     0,   120,     0,  1820,     0,  8008,     0, 12870,\n           0,  8008,     0,  1820,     0,   120,     0,     1])\n&gt;&gt;&gt; code.coset_leader_weight_distribution()\narray([1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n</code></pre>"},{"location":"ref/SlepianArray/","title":"komm.SlepianArray","text":"<p>Slepian array (standard array) for a linear block code. It is a table with $2^m$ rows and $2^k$ columns, where $m$ is the redundancy, and $k$ is the dimension of the code. Each row corresponds to a coset of the group of codewords, in which:</p> <ul> <li> <p>The first row is the group of codewords itself.</p> </li> <li> <p>The first column contains coset leaders (i.e., elements of minimal weight in its coset).</p> </li> </ul> <p>In this implementation:</p> <ul> <li> <p>A row's index $i$ corresponds to the $m$-bit syndrome obtained by expressing $i$ in binary (MSB on the right).</p> </li> <li> <p>A column's index $j$ corresponds to the $k$-bit message obtained by expressing $j$ in binary (MSB on the right).</p> </li> </ul> <p>For more details, see LC04, Sec. 3.5.</p> <p>Attributes:</p> <ul> <li> <code>code</code> (<code>AbstractBlockCode</code>)         \u2013          <p>The linear block code for which the Slepian array is generated.</p> </li> </ul>"},{"location":"ref/SlepianArray/#entry","title":"<code>entry</code>","text":"<p>The entry at the $i$-th row and $j$-th column of the Slepian array.</p> <p>Parameters:</p> <ul> <li> <code>i</code> (<code>int</code>)         \u2013          <p>The index of the row.</p> </li> <li> <code>j</code> (<code>int</code>)         \u2013          <p>The index of the column.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; sa = komm.SlepianArray(code)\n&gt;&gt;&gt; binlist2str = lambda binlist: \"\".join(str(bit) for bit in binlist)\n&gt;&gt;&gt; m, k = code.redundancy, code.dimension\n&gt;&gt;&gt; for i in range(2**m):\n...     for j in range(2**k):\n...         print(binlist2str(sa.entry(i, j)), end=\" \")\n...     print()\n000000 100011 010101 110110 001110 101101 011011 111000\n000100 100111 010001 110010 001010 101001 011111 111100\n000010 100001 010111 110100 001100 101111 011001 111010\n001000 101011 011101 111110 000110 100101 010011 110000\n000001 100010 010100 110111 001111 101100 011010 111001\n010000 110011 000101 100110 011110 111101 001011 101000\n100000 000011 110101 010110 101110 001101 111011 011000\n100100 000111 110001 010010 101010 001001 111111 011100\n</code></pre>"},{"location":"ref/SlepianArray/#row","title":"<code>row</code>","text":"<p>The $i$-th row of the Slepian array.</p> <p>Parameters:</p> <ul> <li> <code>i</code> (<code>int</code>)         \u2013          <p>The index of the row.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; sa = komm.SlepianArray(code)\n&gt;&gt;&gt; sa.row(0)  # The codewords\narray([[0, 0, 0, 0, 0, 0],\n       [1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [1, 1, 0, 1, 1, 0],\n       [0, 0, 1, 1, 1, 0],\n       [1, 0, 1, 1, 0, 1],\n       [0, 1, 1, 0, 1, 1],\n       [1, 1, 1, 0, 0, 0]])\n</code></pre>"},{"location":"ref/SlepianArray/#col","title":"<code>col</code>","text":"<p>The $j$-th column of the Slepian array.</p> <p>Parameters:</p> <ul> <li> <code>j</code> (<code>int</code>)         \u2013          <p>The index of the column.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(generator_matrix=[[1, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; sa = komm.SlepianArray(code)\n&gt;&gt;&gt; sa.col(0)  # The coset leaders\narray([[0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 1, 0],\n       [0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1],\n       [0, 1, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0, 0],\n       [1, 0, 0, 1, 0, 0]])\n</code></pre>"},{"location":"ref/SystematicBlockCode/","title":"komm.SystematicBlockCode","text":"<p>Systematic linear block code. A systematic linear block code is a linear block code in which the information bits can be found in predefined positions in the codeword, called the information set $\\mathcal{K}$, which is a $k$-sublist of $[0 : n)$; the remaining positions are called the parity set $\\mathcal{M}$, which is a $m$-sublist of $[0 : n)$. In this case, the generator matrix then has the property that the columns indexed by $\\mathcal{K}$ are equal to $I_k$, and the columns indexed by $\\mathcal{M}$ are equal to $P$. The check matrix has the property that the columns indexed by $\\mathcal{M}$ are equal to $I_m$, and the columns indexed by $\\mathcal{K}$ are equal to $P^\\transpose$. The matrix $P \\in \\mathbb{B}^{k \\times m}$ is called the parity submatrix of the code.</p> <p>The constructor expects the parity submatrix the information set.</p> <p>Parameters:</p> <ul> <li> <code>parity_submatrix</code> (<code>Array2D[int]</code>)         \u2013          <p>The parity submatrix $P$ the code, which is a $k \\times m$ binary matrix.</p> </li> <li> <code>information_set</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>Either an array containing the indices of the information positions, which must be a $k$-sublist of $[0 : n)$, or one of the strings <code>'left'</code> or <code>'right'</code>. The default value is <code>'left'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.SystematicBlockCode(parity_submatrix=[[0, 1, 1], [1, 0, 1], [1, 1, 0]])\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.check_matrix\narray([[0, 1, 1, 1, 0, 0],\n       [1, 0, 1, 0, 1, 0],\n       [1, 1, 0, 0, 0, 1]])\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.SystematicBlockCode(parity_submatrix=[[0, 1, 1], [1, 0, 1], [1, 1, 0]], information_set='right')\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[0, 1, 1, 1, 0, 0],\n       [1, 0, 1, 0, 1, 0],\n       [1, 1, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.check_matrix\narray([[1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [0, 0, 1, 1, 1, 0]])\n</code></pre>"},{"location":"ref/TerminatedConvolutionalCode/","title":"komm.TerminatedConvolutionalCode","text":"<p>Terminated convolutional code. It is a linear block code obtained by terminating a $(n_0, k_0)$ convolutional code. A total of $h$ information blocks (each containing $k_0$ information bits) is encoded. The dimension of the resulting block code is thus $k = h k_0$; its length depends on the termination mode employed. There are three possible termination modes:</p> <ul> <li> <p>Direct truncation. The encoder always starts at state $0$, and its output ends immediately after the last information block. The encoder may not necessarily end in state $0$. The resulting block code will have length $n = h n_0$.</p> </li> <li> <p>Zero termination. The encoder always starts and ends at state $0$. To achieve this, a sequence of $k \\mu$ tail bits is appended to the information bits, where $\\mu$ is the memory order of the convolutional code. The resulting block code will have length $n = (h + \\mu) n_0$.</p> </li> <li> <p>Tail-biting. The encoder always starts and ends at the same state. To achieve this, the initial state of the encoder is chosen as a function of the information bits. The resulting block code will have length $n = h n_0$.</p> </li> </ul> <p>For more details, see LC04, Sec. 12.7 and WBR01.</p> <p>Attributes:</p> <ul> <li> <code>convolutional_code</code> (<code>ConvolutionalCode</code>)         \u2013          <p>The convolutional code to be terminated.</p> </li> <li> <code>num_blocks</code> (<code>int</code>)         \u2013          <p>The number $h$ of information blocks.</p> </li> <li> <code>mode</code> (<code>Literal['direct-truncation', 'zero-termination', 'tail-biting']</code>)         \u2013          <p>The termination mode. It must be one of <code>'direct-truncation'</code> | <code>'zero-termination'</code> | <code>'tail-biting'</code>. The default value is <code>'zero-termination'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0b1, 0b11]])\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.TerminatedConvolutionalCode(convolutional_code, num_blocks=3, mode='zero-termination')\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(8, 3, 5)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 0, 1, 0, 0, 0, 0],\n       [0, 0, 1, 1, 0, 1, 0, 0],\n       [0, 0, 0, 0, 1, 1, 0, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n3\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.TerminatedConvolutionalCode(convolutional_code, num_blocks=3, mode='direct-truncation')\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 0, 1, 0, 0],\n       [0, 0, 1, 1, 0, 1],\n       [0, 0, 0, 0, 1, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.TerminatedConvolutionalCode(convolutional_code, num_blocks=3, mode='tail-biting')\n&gt;&gt;&gt; (code.length, code.dimension, code.redundancy)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 0, 1, 0, 0],\n       [0, 0, 1, 1, 0, 1],\n       [0, 1, 0, 0, 1, 1]])\n&gt;&gt;&gt; code.minimum_distance()\n3\n</code></pre>"},{"location":"ref/TransmitFilter/","title":"komm.TransmitFilter","text":"<p>Transmit filter (pulse shaping). Given a sequence of $N$ real or complex symbols $x[n]$, this filter outputs samples of the signal $$     x(t) = \\sum_{n=0}^{N-1} x[n] h(t - n), $$ where $h(t)$ is the waveform of a given pulse, and the samples of the output signal are taken at an integer rate of $\\beta$ samples per symbol. Note that the symbol interval is normalized to $1$.</p> <p>The time span of $x(t)$ is given by $[ n_0, n_1 + N - 1 )$, where $[ n_0, n_1 )$ is the integer-bounded time span of $h(t)$. In turn, $n_0$ and $n_1$ depend on the support of $h(t)$:</p> <ul> <li> <p>If $h(t)$ has finite support $[ t_0, t_1 ]$, then $n_0 = \\lfloor t_0 \\rfloor$ and $n_1 = \\lceil t_1 \\rceil$.</p> </li> <li> <p>If $h(t)$ has infinite support, then $n_0 = -L/2$ and $n_1 = L/2$, where $L$ is a given even positive integer, called the truncation window length.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>pulse</code> (<code>Pulse</code>)         \u2013          <p>The pulse whose waveform is $h(t)$.</p> </li> <li> <code>samples_per_symbol</code> (<code>int</code>)         \u2013          <p>The number $\\beta$ of samples (of the output) per symbol (of the input). Must be a positive integer.</p> </li> <li> <code>truncation</code> (<code>Optional[int]</code>)         \u2013          <p>The truncation window length $L$. Only applies to infinite-duration pulses. Must be an even positive integer. The default value is <code>32</code>.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>symbols</code> (<code>Array1D[float] | Array1D[complex]</code>)         \u2013          <p>The input symbols $x[n]$, of length $N$.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>signal</code> (<code>SameAsInput</code>)         \u2013          <p>The samples of the output signal $x(t)$, of length $(N + n_1 - n_0 - 1) \\beta$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(width=1.0)\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=3)\n&gt;&gt;&gt; tx_filter([1.0, -1.0, 1.0, 1.0])\narray([ 1.,  1.,  1., -1., -1., -1.,  1.,  1.,  1.,  1.,  1.,  1.])\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(width=0.25)\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=3)\n&gt;&gt;&gt; tx_filter([1.0, -1.0, 1.0, 1.0])\narray([ 1.,  0.,  0., -1.,  0.,  0.,  1.,  0.,  0.,  1.,  0.,  0.])\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.SincPulse()\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=4, truncation=4)\n&gt;&gt;&gt; tx_filter([1.0, -1.0, 1.0, 1.0]).reshape((-1, 4)).round(6)\narray([[-0.      , -0.128617, -0.212207, -0.180063],\n       [ 0.      ,  0.428722,  0.848826,  1.08038 ],\n       [ 1.      ,  0.471594, -0.212207, -0.780274],\n       [-1.      , -0.908891, -0.424413,  0.291531],\n       [ 1.      ,  1.380485,  1.485446,  1.329038],\n       [ 1.      ,  0.720253,  0.424413,  0.171489],\n       [ 0.      , -0.180063, -0.212207, -0.128617]])\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse()\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=4, truncation=4)\nTraceback (most recent call last):\n...\nValueError: parameter 'truncation' is only applicable to pulses with infinite support\n</code></pre>"},{"location":"ref/TransmitFilter/#pulse_time_span","title":"<code>pulse_time_span: tuple[int, int]</code>  <code>cached</code> <code>property</code>","text":"<p>The integer-bounded time span $[ n_0, n_1 )$ of the pulse waveform $h(t)$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(0.25)\n&gt;&gt;&gt; pulse.support\n(0.0, 0.25)\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=3)\n&gt;&gt;&gt; tx_filter.pulse_time_span\n(0, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.SincPulse()\n&gt;&gt;&gt; pulse.support\n(-inf, inf)\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=4, truncation=4)\n&gt;&gt;&gt; tx_filter.pulse_time_span\n(-2, 2)\n</code></pre>"},{"location":"ref/TransmitFilter/#taps","title":"<code>taps: npt.NDArray[np.float64]</code>  <code>cached</code> <code>property</code>","text":"<p>The FIR filter taps of the transmit filter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(width=0.25)\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=3)\n&gt;&gt;&gt; tx_filter.taps\narray([1., 0., 0.])\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.SincPulse()\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=4, truncation=4)\n&gt;&gt;&gt; tx_filter.taps.reshape((-1, 4)).round(6)\narray([[-0.      , -0.128617, -0.212207, -0.180063],\n       [ 0.      ,  0.300105,  0.63662 ,  0.900316],\n       [ 1.      ,  0.900316,  0.63662 ,  0.300105],\n       [ 0.      , -0.180063, -0.212207, -0.128617]])\n</code></pre>"},{"location":"ref/TransmitFilter/#time","title":"<code>time</code>","text":"<p>Convenience function to generate the time axis of the output signal given the input symbols.</p> <p>Parameters:</p> <ul> <li> <code>symbols</code> (<code>Array1D[float] | Array1D[complex]</code>)         \u2013          <p>The input symbols $x[n]$, of length $N$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>t</code>  (<code>Array1D[float]</code>)          \u2013          <p>The time axis of the output signal, of length $(N + n_1 - n_0 - 1) \\beta$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse()\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=3)\n&gt;&gt;&gt; tx_filter.time([1.0, -1.0, 1.0, 1.0]).round(2)\narray([0.  , 0.33, 0.67, 1.  , 1.33, 1.67, 2.  , 2.33, 2.67, 3.  , 3.33, 3.67])\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.SincPulse()\n&gt;&gt;&gt; tx_filter = komm.TransmitFilter(pulse=pulse, samples_per_symbol=4, truncation=4)\n&gt;&gt;&gt; tx_filter.time([1.0, -1.0, 1.0, 1.0]).reshape((-1, 4))\narray([[-2.  , -1.75, -1.5 , -1.25],\n       [-1.  , -0.75, -0.5 , -0.25],\n       [ 0.  ,  0.25,  0.5 ,  0.75],\n       [ 1.  ,  1.25,  1.5 ,  1.75],\n       [ 2.  ,  2.25,  2.5 ,  2.75],\n       [ 3.  ,  3.25,  3.5 ,  3.75],\n       [ 4.  ,  4.25,  4.5 ,  4.75]])\n</code></pre>"},{"location":"ref/TunstallCode/","title":"komm.TunstallCode","text":"<p>Binary Tunstall code. It is an optimal (minimal expected rate) variable-to-fixed length code for a given probability mass function. For more details, see Say06, Sec. 3.7.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>ArrayLike</code>)         \u2013          <p>The probability mass function of the source.</p> </li> <li> <code>target_block_size</code> (<code>Optional[int]</code>)         \u2013          <p>The target block size $n$. Must satisfy $2^n \\geq S$, where $S$ is the cardinality of the source alphabet, given by <code>len(pmf)</code>. The default value is $n = \\lceil \\log_2 S \\rceil$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pmf = [0.7, 0.15, 0.15]\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.TunstallCode(pmf)\n&gt;&gt;&gt; code.dec_mapping\n{(0, 0): (0,),\n (0, 1): (1,),\n (1, 0): (2,)}\n&gt;&gt;&gt; code.rate(pmf)\nnp.float64(2.0)\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.TunstallCode(pmf, 3)\n&gt;&gt;&gt; code.dec_mapping\n{(0, 0, 0): (0, 0, 0),\n (0, 0, 1): (0, 0, 1),\n (0, 1, 0): (0, 0, 2),\n (0, 1, 1): (0, 1),\n (1, 0, 0): (0, 2),\n (1, 0, 1): (1,),\n (1, 1, 0): (2,)}\n&gt;&gt;&gt; code.rate(pmf)\nnp.float64(1.3698630137)\n</code></pre>"},{"location":"ref/UniformQuantizer/","title":"komm.UniformQuantizer","text":"<p>Uniform scalar quantizer. It is a scalar quantizer in which the separation between levels is constant, $\\Delta$, and the thresholds are the mid-point between adjacent levels. For more details, see Say06, Sec. 9.4.</p> <p>Attributes:</p> <ul> <li> <code>num_levels</code> (<code>int</code>)         \u2013          <p>The number of quantization levels $L$. It must be greater than $1$.</p> </li> <li> <code>input_range</code> (<code>tuple[float, float]</code>)         \u2013          <p>The range $(x_\\mathrm{min}, x_\\mathrm{max})$ of the input signal. The default is $(-1.0, 1.0)$.</p> </li> <li> <code>choice</code> (<code>Literal['mid-riser', 'mid-tread']</code>)         \u2013          <p>The choice for the uniform quantizer. Must be either <code>'mid-riser'</code> or <code>'mid-tread'</code>. The default is <code>'mid-riser'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; quantizer = komm.UniformQuantizer(num_levels=4, input_range=(-1.0, 1.0), choice='mid-riser')\n&gt;&gt;&gt; quantizer.levels\narray([-0.75, -0.25,  0.25,  0.75])\n&gt;&gt;&gt; quantizer.thresholds\narray([-0.5,  0. ,  0.5])\n</code></pre> <pre><code>&gt;&gt;&gt; quantizer = komm.UniformQuantizer(num_levels=4, input_range=(-1.0, 1.0), choice='mid-tread')\n&gt;&gt;&gt; quantizer.levels\narray([-1. , -0.5,  0. ,  0.5])\n&gt;&gt;&gt; quantizer.thresholds\narray([-0.75, -0.25,  0.25])\n</code></pre> <pre><code>&gt;&gt;&gt; quantizer = komm.UniformQuantizer(num_levels=4, input_range=(0.0, 1.0), choice='mid-tread')\n&gt;&gt;&gt; quantizer.levels\narray([0.  , 0.25, 0.5 , 0.75])\n&gt;&gt;&gt; quantizer.thresholds\narray([0.125, 0.375, 0.625])\n</code></pre>"},{"location":"ref/UniformQuantizer/#quantization_step","title":"<code>quantization_step: float</code>  <code>cached</code> <code>property</code>","text":"<p>The quantization step $\\Delta$.</p>"},{"location":"ref/UniformQuantizer/#levels","title":"<code>levels: npt.NDArray[np.float64]</code>  <code>cached</code> <code>property</code>","text":"<p>The quantizer levels $v_0, v_1, \\ldots, v_{L-1}$.</p>"},{"location":"ref/UniformQuantizer/#thresholds","title":"<code>thresholds: npt.NDArray[np.float64]</code>  <code>cached</code> <code>property</code>","text":"<p>The quantizer finite thresholds $t_1, t_2, \\ldots, t_{L-1}$.</p>"},{"location":"ref/VariableToFixedCode/","title":"komm.VariableToFixedCode","text":"<p>Variable-to-fixed length code. A variable-to-fixed length code with target alphabet $\\mathcal{T}$, source alphabet $\\mathcal{S}$, and target block size $n$ is defined by a (possibly partial) injective decoding mapping $\\mathrm{Dec} : \\mathcal{T}^n \\to \\mathcal{S}^+$, where the domain is the set of all $n$-tuples with entries in $\\mathcal{T}$, and the co-domain is the set of all finite-length, non-empty tuples with entries in $\\mathcal{S}$. Here, we assume that $\\mathcal{T} = [0:T)$ and $\\mathcal{S} = [0:S)$, for integers $T \\geq 2$ and $S \\geq 2$. The elements in the image of $\\mathrm{Dec}$ are called sourcewords.</p> <p>Attributes:</p> <ul> <li> <code>target_cardinality</code> (<code>int</code>)         \u2013          <p>The target cardinality $T$.</p> </li> <li> <code>source_cardinality</code> (<code>int</code>)         \u2013          <p>The source cardinality $S$.</p> </li> <li> <code>target_block_size</code> (<code>int</code>)         \u2013          <p>The target block size $n$.</p> </li> <li> <code>dec_mapping</code> (<code>dict[Word, Word]</code>)         \u2013          <p>The decoding mapping $\\mathrm{Dec}$ of the code. Must be a dictionary of length at most $S^n$ whose keys are $n$-tuples of integers in $[0:T)$ and whose values are distinct non-empty tuples of integers in $[0:S)$.</p> </li> </ul>"},{"location":"ref/VariableToFixedCode/#from_dec_mapping","title":"<code>from_dec_mapping</code>  <code>classmethod</code>","text":"<p>Constructs a variable-to-fixed code from the decoding map $\\Dec$.</p> <p>Parameters:</p> <ul> <li> <code>dec_mapping</code> (<code>dict[Word, Word]</code>)         \u2013          <p>The decoding map $\\Dec$. See the corresponding attribute for more details.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_dec_mapping({(0,0): (0,0,0), (0,1): (0,0,1), (1,0): (0,1), (1,1): (1,)})\n&gt;&gt;&gt; (code.target_cardinality, code.source_cardinality, code.target_block_size)\n(2, 2, 2)\n&gt;&gt;&gt; code.dec_mapping\n{(0, 0): (0, 0, 0),\n (0, 1): (0, 0, 1),\n (1, 0): (0, 1),\n (1, 1): (1,)}\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_dec_mapping({(0,0,0): (1,), (0,0,1): (2,), (0,1,0): (0,1), (0,1,1): (0,2), (1,0,0): (0,0,0), (1,0,1): (0,0,1), (1,1,0): (0,0,2)})\n&gt;&gt;&gt; code.target_cardinality, code.source_cardinality, code.target_block_size\n(2, 3, 3)\n&gt;&gt;&gt; code.dec_mapping\n{(0, 0, 0): (1,),\n (0, 0, 1): (2,),\n (0, 1, 0): (0, 1),\n (0, 1, 1): (0, 2),\n (1, 0, 0): (0, 0, 0),\n (1, 0, 1): (0, 0, 1),\n (1, 1, 0): (0, 0, 2)}\n</code></pre>"},{"location":"ref/VariableToFixedCode/#from_sourcewords","title":"<code>from_sourcewords</code>  <code>classmethod</code>","text":"<p>Constructs a variable-to-fixed code from the target cardinality $T$ and a list of sourcewords.</p> <p>Parameters:</p> <ul> <li> <code>target_cardinality</code> (<code>int</code>)         \u2013          <p>The target cardinality $T$. Must be an integer greater than or equal to $2$.</p> </li> <li> <code>sourcewords</code> (<code>list[Word]</code>)         \u2013          <p>The sourcewords of the code. See the corresponding property for more details.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; (code.target_cardinality, code.source_cardinality, code.target_block_size)\n(2, 2, 2)\n&gt;&gt;&gt; code.dec_mapping\n{(0, 0): (0, 0, 0),\n (0, 1): (0, 0, 1),\n (1, 0): (0, 1),\n (1, 1): (1,)}\n</code></pre>"},{"location":"ref/VariableToFixedCode/#sourcewords","title":"<code>sourcewords: list[Word]</code>  <code>property</code>","text":"<p>The sourcewords of the code. It is a list of length at most $T^n$ containing tuples of integers in $[0:S)$. The tuple in position $i$ of <code>sourcewords</code> is equal to $\\mathrm{Dec}(v)$, where $v$ is the $i$-th element in the lexicographic ordering of $[0:T)^n$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_dec_mapping({(0,0): (0,0,0), (0,1): (0,0,1), (1,0): (0,1), (1,1): (1,)})\n&gt;&gt;&gt; code.sourcewords\n[(0, 0, 0), (0, 0, 1), (0, 1), (1,)]\n</code></pre>"},{"location":"ref/VariableToFixedCode/#inv_dec_mapping","title":"<code>inv_dec_mapping: dict[Word, Word]</code>  <code>property</code>","text":"<p>The inverse decoding mapping $\\mathrm{Dec}^{-1}$ of the code. It is a dictionary of length at most $T^n$ whose keys are all the sourcewords of the code, and whose values are the corresponding target words.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; code.inv_dec_mapping\n{(0, 0, 0): (0, 0),\n (0, 0, 1): (0, 1),\n (0, 1): (1, 0),\n (1,): (1, 1)}\n</code></pre>"},{"location":"ref/VariableToFixedCode/#is_unique_encodable","title":"<code>is_unique_encodable</code>","text":"<p>Returns whether the code is unique encodable or not. [Not implemented yet].</p>"},{"location":"ref/VariableToFixedCode/#is_prefix_free","title":"<code>is_prefix_free</code>","text":"<p>Returns whether the code is prefix-free or not. A code is prefix-free if no sourceword is a prefix of any other sourceword.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; code.is_prefix_free()\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,1,0), (0,1), (1,)])\n&gt;&gt;&gt; code.is_prefix_free()\nFalse\n</code></pre>"},{"location":"ref/VariableToFixedCode/#rate","title":"<code>rate</code>","text":"<p>Computes the expected rate $R$ of the code, considering a given pmf. This quantity is given by $$     R = \\frac{n}{\\bar{k}}, $$ where $n$ is the target block size, and $\\bar{k}$ is the expected sourceword length, assuming iid source symbols drawn from $p_X$. It is measured in $T$-ary digits per source symbol.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The (first-order) probability mass function $p_X$ to be considered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rate</code>  (<code>float</code>)          \u2013          <p>The expected rate $R$ of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; code.rate([2/3, 1/3])\nnp.float64(0.9473684210526315)\n</code></pre>"},{"location":"ref/VariableToFixedDecoder/","title":"komm.VariableToFixedDecoder","text":"<p>Decoder for variable-to-fixed length codes.</p> <p>Attributes:</p> <ul> <li> <code>code</code> (<code>VariableToFixedCode</code>)         \u2013          <p>The code to be considered.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of symbols to be decoded. Must be a 1D-array with elements in $[0:T)$, where $T$ is the target cardinality of the code.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of decoded symbols. It is a 1D-array with elements in $[0:S)$, where $S$ is the source cardinality of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; decoder = komm.VariableToFixedDecoder(code)\n&gt;&gt;&gt; decoder([0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0])\narray([0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0])\n</code></pre>"},{"location":"ref/VariableToFixedEncoder/","title":"komm.VariableToFixedEncoder","text":"<p>Encoder for prefix-free variable-to-fixed length codes.</p> <p>Attributes:</p> <ul> <li> <code>code</code> (<code>VariableToFixedCode</code>)         \u2013          <p>The code to be considered.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>in0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of symbols to be encoded. Must be a 1D-array with elements in $[0:S)$, where $S$ is the source cardinality of the code.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>out0</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of encoded symbols. It is a 1D-array with elements in $[0:T)$, where $T$ is the target cardinality of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; encoder = komm.VariableToFixedEncoder(code)\n&gt;&gt;&gt; encoder([0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0])\narray([0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0])\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode.from_sourcewords(2, [(0,0,0), (0,0,1), (0,1), (0,)])\n&gt;&gt;&gt; encoder = komm.VariableToFixedEncoder(code)\nTraceback (most recent call last):\n...\nValueError: code is not prefix-free\n</code></pre>"},{"location":"ref/WalshHadamardSequence/","title":"komm.WalshHadamardSequence","text":"<p>Walsh\u2013Hadamard sequence. Consider the following recursive matrix construction: $$     H_1 =     \\begin{bmatrix}         +1     \\end{bmatrix}, \\qquad     H_{2^n} =     \\begin{bmatrix}         H_{2^{n-1}} &amp; H_{2^{n-1}} \\\\         H_{2^{n-1}} &amp; -H_{2^{n-1}}     \\end{bmatrix}, $$ for $n = 1, 2, \\ldots$. For example, for $n = 3$, $$     H_8 =     \\begin{bmatrix}         +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 \\\\         +1 &amp; +1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 \\\\     \\end{bmatrix} $$ The above matrix is said to be in natural ordering. If the rows of the matrix are rearranged by first applying the bit-reversal permutation and then the Gray-code permutation, the following matrix is obtained: $$     H_8^{\\mathrm{s}} =     \\begin{bmatrix}         +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 \\\\         +1 &amp; +1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 \\\\     \\end{bmatrix} $$ The above matrix is said to be in sequency ordering. It has the property that row $i$ has exactly $i$ sign changes.</p> <p>The Walsh\u2013Hadamard sequence of length $L$ and index $i \\in [0 : L)$ is a binary sequence whose polar format is the $i$-th row of $H_L$, if assuming natural ordering, or $H_L^{\\mathrm{s}}$, if assuming sequency ordering.</p> References <ol> <li>https://en.wikipedia.org/wiki/Hadamard_matrix</li> <li>https://en.wikipedia.org/wiki/Walsh_matrix</li> </ol>"},{"location":"ref/WalshHadamardSequence/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>length</code> (<code>int</code>)         \u2013          <p>Length $L$ of the Walsh\u2013Hadamard sequence. Must be a power of two.</p> </li> <li> <code>ordering</code> (<code>Optional[str]</code>)         \u2013          <p>Ordering to be assumed. Should be one of <code>'natural'</code>, <code>'sequency'</code>, or <code>'dyadic'</code>. The default value is <code>'natural'</code>.</p> </li> <li> <code>index</code> (<code>Optional[int]</code>)         \u2013          <p>Index of the Walsh\u2013Hadamard sequence, with respect to the ordering assumed. Must be in the set $[0 : L)$. The default value is <code>0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; walsh_hadamard = komm.WalshHadamardSequence(length=64, ordering='sequency', index=60)\n&gt;&gt;&gt; walsh_hadamard.polar_sequence[:16]\narray([ 1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1])\n</code></pre> <pre><code>&gt;&gt;&gt; walsh_hadamard = komm.WalshHadamardSequence(length=128, ordering='natural', index=60)\n&gt;&gt;&gt; walsh_hadamard.polar_sequence[:16]\narray([ 1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1])\n</code></pre>"},{"location":"ref/WalshHadamardSequence/#index","title":"<code>index</code>  <code>property</code>","text":"<p>The index of the Walsh\u2013Hadamard sequence, with respect to the ordering assumed.</p>"},{"location":"ref/WalshHadamardSequence/#ordering","title":"<code>ordering</code>  <code>property</code>","text":"<p>The ordering assumed.</p>"},{"location":"ref/ZChannel/","title":"komm.ZChannel","text":"<p>Z-channel. It is a discrete memoryless channel with input and output alphabets $\\mathcal{X} = \\mathcal{Y} = \\{ 0, 1 \\}$. The channel is characterized by a parameter $p$, called the decay probability. Bit $0$ is always received correctly, but bit $1$ turns into $0$ with probability $p$. Equivalently, the channel can be modeled as $$     Y_n = A_n X_n, $$ where $A_n$ are iid Bernoulli random variables with $\\Pr[A_n = 0] = p$.</p> <p>Attributes:</p> <ul> <li> <code>decay_probability</code> (<code>Optional[float]</code>)         \u2013          <p>The channel decay probability $p$. Must satisfy $0 \\leq p \\leq 1$. The default value is <code>0.0</code>, which corresponds to a noiseless channel.</p> </li> </ul> <p>Input:</p> <ul> <li> <code>input_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The input sequence.</p> </li> </ul> <p>Output:</p> <ul> <li> <code>output_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The output sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; zc = komm.ZChannel(0.1)\n&gt;&gt;&gt; zc([0, 1, 1, 1, 0, 0, 0, 0, 0, 1])\narray([0, 1, 0, 1, 0, 0, 0, 0, 0, 1])\n</code></pre>"},{"location":"ref/ZChannel/#transition_matrix","title":"<code>transition_matrix: npt.NDArray[np.float64]</code>  <code>property</code>","text":"<p>The transition probability matrix of the channel. It is given by $$     p_{Y \\mid X} = \\begin{bmatrix} 1 &amp; 0 \\\\ p &amp; 1-p \\end{bmatrix}. $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zc = komm.ZChannel(0.1)\n&gt;&gt;&gt; zc.transition_matrix\narray([[1. , 0. ],\n       [0.1, 0.9]])\n</code></pre>"},{"location":"ref/ZChannel/#mutual_information","title":"<code>mutual_information</code>","text":"<p>Returns the mutual information $\\mathrm{I}(X ; Y)$ between the input $X$ and the output $Y$ of the channel. It is given by $$     \\mathrm{I}(X ; Y) = \\Hb ( \\pi (1-p) ) - \\pi \\Hb(p), $$ in bits, where $\\pi = \\Pr[X = 1]$, and $\\Hb$ is the binary entropy function.</p> <p>Parameters:</p> <p>Same as the corresponding method of the general class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zc = komm.ZChannel(0.1)\n&gt;&gt;&gt; zc.mutual_information([0.5, 0.5])\nnp.float64(0.7582766571931676)\n</code></pre>"},{"location":"ref/ZChannel/#capacity","title":"<code>capacity</code>","text":"<p>Returns the channel capacity $C$. It is given by $$     C = \\log_2 ( 1 + (1-p) p^{p / (1-p)} ), $$ in bits.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zc = komm.ZChannel(0.1)\n&gt;&gt;&gt; zc.capacity()\nnp.float64(0.7628482520105094)\n</code></pre>"},{"location":"ref/ZadoffChuSequence/","title":"komm.ZadoffChuSequence","text":"<p>Zadoff\u2013Chu sequence. It is a periodic, complex sequence given by $$     z_{L,q}[n] = \\mathrm{e}^{-\\mathrm{j} \\pi q n (n + 1) / L}, $$ where $L$ is the length (and period) of the sequence (which must be an odd integer) and $q \\in [1:L)$ is called the root index of the sequence.</p> <p>Zadoff\u2013Chu sequences have the following properties:</p> <ol> <li> <p>Constant amplitude: The magnitude of the sequence satisfies $$     |z_{L,q}[n]| = 1, \\quad \\forall n. $$</p> </li> <li> <p>Zero autocorrelation: If $q$ is coprime to $L$, then the cyclic autocorrelation of $z_{L,q}$ satisfies $$     \\tilde{R}_{z_{L,q}}[\\ell] = 0, \\quad \\forall \\ell \\neq 0 \\mod L. $$</p> </li> <li> <p>Constant cross-correlation: If $|q' - q|$ is coprime to $L$, then the magnitude of the cyclic cross-correlation of $z_{L,q}$ and $z_{L,q'}$ satisfies $$     |\\tilde{R}_{z_{L,q}, z_{L,q'}}[\\ell]| = \\sqrt{L}, \\quad \\forall \\ell. $$</p> </li> </ol> <p>For more details, see And22.</p> Notes <ul> <li>Theses sequences are also called Frank\u2013Zadoff\u2013Chu sequences.</li> </ul>"},{"location":"ref/ZadoffChuSequence/#__init__","title":"<code>__init__</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>length</code> (<code>int</code>)         \u2013          <p>The length $L$ of the Zadoff\u2013Chu sequence. Must be an odd integer.</p> </li> <li> <code>root_index</code> (<code>Optional[int]</code>)         \u2013          <p>The root index $q$ of the Zadoff\u2013Chu sequence. Must be in $[1:L)$. The default value is $1$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zadoff_chu = ZadoffChuSequence(5, root_index=1)\n&gt;&gt;&gt; zadoff_chu.sequence.round(6)\narray([ 1.      +0.j      ,  0.309017-0.951057j, -0.809017+0.587785j,  0.309017-0.951057j,  1.      +0.j      ])\n&gt;&gt;&gt; zadoff_chu.cyclic_autocorrelation(normalized=True).round(6)\narray([ 1.+0.j, -0.-0.j, -0.-0.j,  0.+0.j, -0.+0.j])\n</code></pre>"},{"location":"ref/ZadoffChuSequence/#length","title":"<code>length</code>  <code>property</code>","text":"<p>The length $L$ of the Zadoff\u2013Chu sequence.</p>"},{"location":"ref/ZadoffChuSequence/#root_index","title":"<code>root_index</code>  <code>property</code>","text":"<p>The root index $q$ of the Zadoff\u2013Chu sequence.</p>"},{"location":"ref/acorr/","title":"komm.acorr","text":"<p>Computes the autocorrelation $R[\\ell]$ of a real or complex sequence $x[n]$. This is defined as $$     R[\\ell] = \\sum_{n \\in \\mathbb{Z}} x[n] x^*_\\ell[n], $$ where $x^*_\\ell[n] = x^*[n - \\ell]$ is the complex conjugate of $x[n]$ shifted by $\\ell$ positions. The autocorrelation $R[\\ell]$ is even symmetric and satisfies $R[\\ell] = 0$ for $|\\ell| \\geq L$, where $L$ is the length of the sequence.</p> <p>Parameters:</p> <ul> <li> <code>seq</code> (<code>Array1D[float | complex]</code>)         \u2013          <p>A 1D-array containing the sequence $x[n]$, of length $L$.</p> </li> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>A 1D-array containing the values of $\\ell$ for which the autocorrelation will be computed. The default value is <code>range(len(seq))</code>, that is, $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>If <code>True</code>, returns the autocorrelation divided by the sequence energy, so that $R[0] = 1$. The default value is <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>acorr</code>  (<code>SameAsInput</code>)          \u2013          <p>The autocorrelation $R[\\ell]$ of the sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.acorr([1.0, 2.0, 3.0, 4.0], shifts=[-2, -1, 0, 1, 2])\narray([11., 20., 30., 20., 11.])\n</code></pre>"},{"location":"ref/binary_entropy/","title":"komm.binary_entropy","text":"<p>Computes the binary entropy function. For a given probability $p$, it is defined as $$     \\Hb(p) = p \\log_2 \\frac{1}{p} + (1 - p) \\log_2 \\frac{1}{1 - p}, $$ and corresponds to the entropy of a Bernoulli random variable with parameter $p$.</p> <p>Parameters:</p> <ul> <li> <code>p</code> (<code>float</code>)         \u2013          <p>A probability value. It must satisfy $0 \\leq p \\leq 1$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>entropy</code>  (<code>float</code>)          \u2013          <p>The value of the binary entropy function $\\Hb(p)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; [komm.binary_entropy(p) for p in [0.0, 0.25, 0.5, 0.75, 1.0]]\n[0.0, 0.8112781244591328, 1.0, 0.8112781244591328, 0.0]\n</code></pre>"},{"location":"ref/binlist2int/","title":"komm.binlist2int","text":"<p>Converts a bit array to its integer representation (LSB first).</p> <p>Parameters:</p> <ul> <li> <code>binlist</code> (<code>ArrayIntLike</code>)         \u2013          <p>A list or array of $0$'s and $1$'s whose $i$-th element stands for the coefficient of $2^i$ in the binary representation of the output integer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>integer</code>  (<code>int</code>)          \u2013          <p>The integer representation of the input bit array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.binlist2int([0, 0, 0, 0, 1])\n16\n</code></pre> <pre><code>&gt;&gt;&gt; komm.binlist2int([0, 1, 0, 1, 1])\n26\n</code></pre> <pre><code>&gt;&gt;&gt; komm.binlist2int([0, 1, 0, 1, 1, 0, 0, 0])\n26\n</code></pre>"},{"location":"ref/cyclic_acorr/","title":"komm.cyclic_acorr","text":"<p>Computes the cyclic autocorrelation $\\tilde{R}[\\ell]$ of a real or complex sequence $x[n]$. This is defined as $$     \\tilde{R}[\\ell] = \\sum_{n \\in [0:L)} x[n] \\tilde{x}^*_\\ell[n], $$ where $\\tilde{x}^*_\\ell[n]$ is the complex conjugate of $x[n]$ cyclic-shifted by $\\ell$ positions, and $L$ is the period of the sequence. The cyclic autocorrelation $\\tilde{R}[\\ell]$ is even symmetric and periodic with period $L$.</p> <p>Parameters:</p> <ul> <li> <code>seq</code> (<code>Array1D[float | complex]</code>)         \u2013          <p>A 1D-array containing the sequence $x[n]$, of length $L$.</p> </li> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>A 1D-array containing the values of $\\ell$ for which the cyclic autocorrelation will be computed. The default value is <code>range(len(seq))</code>, that is, $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>If <code>True</code>, returns the cyclic autocorrelation divided by the sequence energy, so that $R[0] = 1$. The default value is <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cyclic_acorr</code>  (<code>SameAsInput</code>)          \u2013          <p>The cyclic autocorrelation $\\tilde{R}[\\ell]$ of the sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.cyclic_acorr([1.0, 2.0, 3.0, 4.0], shifts=[-2, -1, 0, 1, 2])\narray([22., 24., 30., 24., 22.])\n</code></pre>"},{"location":"ref/entropy/","title":"komm.entropy","text":"<p>Computes the entropy of a random variable with a given pmf. Let $X$ be a random variable with pmf $p_X$ and alphabet $\\mathcal{X}$. Its entropy is given by $$     \\mathrm{H}(X) = \\sum_{x \\in \\mathcal{X}} p_X(x) \\log \\frac{1}{p_X(x)}. $$ By default, the base of the logarithm is $2$, in which case the entropy is measured in bits. For more details, see CT06, Ch. 2.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The probability mass function $p_X$ of the random variable. It must be a valid pmf, that is, all of its values must be non-negative and sum up to $1$.</p> </li> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>The base of the logarithm to be used. It must be a positive float or the string <code>'e'</code>. The default value is <code>2.0</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>entropy</code>  (<code>float</code>)          \u2013          <p>The entropy $\\mathrm{H}(X)$ of the random variable.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.entropy([1/4, 1/4, 1/4, 1/4])\nnp.float64(2.0)\n</code></pre> <pre><code>&gt;&gt;&gt; komm.entropy(pmf=[1/3, 1/3, 1/3], base=3.0)\nnp.float64(1.0)\n</code></pre> <pre><code>&gt;&gt;&gt; komm.entropy([0.5, 0.5], base='e')\nnp.float64(0.6931471805599453)\n</code></pre>"},{"location":"ref/int2binlist/","title":"komm.int2binlist","text":"<p>Converts an integer to its bit array representation (LSB first).</p> <p>Parameters:</p> <ul> <li> <code>integer</code> (<code>int</code>)         \u2013          <p>The input integer. May be any nonnegative integer.</p> </li> <li> <code>width</code> (<code>Optional[int]</code>)         \u2013          <p>If this parameter is specified, the output will be filled with zeros on the right so that its length will be the specified value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>binlist</code>  (<code>Array1D[int]</code>)          \u2013          <p>An array of $0$'s and $1$'s whose $i$-th element stands for the coefficient of $2^i$ in the binary representation of the input integer.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.int2binlist(16)\narray([0, 0, 0, 0, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; komm.int2binlist(26)\narray([0, 1, 0, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; komm.int2binlist(26, width=8)\narray([0, 1, 0, 1, 1, 0, 0, 0])\n</code></pre>"},{"location":"ref/pack/","title":"komm.pack","text":"<p>Packs a given bit array. Splits the bit array into groups of <code>width</code> bits and converts each group to its integer value.</p> <p>Parameters:</p> <ul> <li> <code>bit_array</code> (<code>ArrayIntLike</code>)         \u2013          <p>The input bit array.</p> </li> <li> <code>width</code> (<code>int</code>)         \u2013          <p>The width of each group.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>packed</code>  (<code>Array1D[int]</code>)          \u2013          <p>The packed integer array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.pack([0, 0, 0, 0, 1, 0, 1, 0, 1, 1], width=5)\narray([16, 26])\n</code></pre> <pre><code>&gt;&gt;&gt; komm.pack([0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], width=8)\narray([16, 26])\n</code></pre>"},{"location":"ref/qfunc/","title":"komm.qfunc","text":"<p>Computes the Gaussian Q-function. It is given by $$     \\mathrm{Q}(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_x^\\infty \\mathrm{e}^{-u^2/2} \\, \\mathrm{d}u. $$</p> <p>Parameters:</p> <ul> <li> <code>x</code> (<code>float | ArrayND[float]</code>)         \u2013          <p>The input to the function. May be any float or array of floats.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>y</code>  (<code>SameAsInput</code>)          \u2013          <p>The value $y = \\mathrm{Q}(x)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.qfunc(0.0)\nnp.float64(0.5)\n</code></pre> <pre><code>&gt;&gt;&gt; komm.qfunc([[-1.0], [0.0], [1.0]])\narray([[0.84134475],\n       [0.5       ],\n       [0.15865525]])\n</code></pre>"},{"location":"ref/qfuncinv/","title":"komm.qfuncinv","text":"<p>Computes the inverse Gaussian Q-function.</p> <p>Parameters:</p> <ul> <li> <code>y</code> (<code>float | ArrayND[float]</code>)         \u2013          <p>The input to the function. Should be a float or array of floats in the real interval $[0, 1]$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>x</code>  (<code>SameAsInput</code>)          \u2013          <p>The value $x = \\mathrm{Q^{-1}}(y)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.qfuncinv(0.5)\nnp.float64(0.0)\n</code></pre> <pre><code>&gt;&gt;&gt; komm.qfuncinv([[0.841344746], [0.5], [0.158655254]])\narray([[-1.],\n       [ 0.],\n       [ 1.]])\n</code></pre>"},{"location":"ref/unpack/","title":"komm.unpack","text":"<p>Unpacks a given integer array. Unpacks a given integer array by converting each integer to its bit array representation, using the specified <code>width</code> for each group, and concatenating the results.</p> <p>Parameters:</p> <ul> <li> <code>bit_array</code> (<code>ArrayIntLike</code>)         \u2013          <p>The input integer array.</p> </li> <li> <code>width</code> (<code>int</code>)         \u2013          <p>The width of each group.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>unpacked</code>  (<code>Array1D[int]</code>)          \u2013          <p>The unpacked bit array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.unpack([16, 26], width=5)\narray([0, 0, 0, 0, 1, 0, 1, 0, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; komm.unpack([16, 26], width=8)\narray([0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0])\n</code></pre>"}]}
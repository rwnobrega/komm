{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to Komm!</p> <p>Komm is an open-source library for Python 3 providing tools for analysis and simulation of analog and digital communication systems. This project is inspired by---but is not meant to be compatible with---the MATLAB\u00ae Communications System Toolbox\u2122. Other sources of inspiration include GNU Radio, CommPy, and SageMath. Komm is licensed under the GNU General Public License v3.0.</p> <p>For installation instructions and source code, please check the project's development page.</p> <p>This software is still under development. Contributions are very welcome!</p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Home</li> <li>Library reference</li> <li>Algebra<ul> <li>BinaryPolynomial</li> <li>BinaryPolynomialFraction</li> <li>FiniteBifield</li> <li>RationalPolynomial</li> <li>RationalPolynomialFraction</li> </ul> </li> <li>Channels<ul> <li>AWGNChannel</li> <li>DiscreteMemorylessChannel</li> <li>BinarySymmetricChannel</li> <li>BinaryErasureChannel</li> </ul> </li> <li>Error control<ul> <li>Block coding</li> <li>BlockCode</li> <li>HammingCode</li> <li>SimplexCode</li> <li>GolayCode</li> <li>RepetitionCode</li> <li>SingleParityCheckCode</li> <li>CordaroWagnerCode</li> <li>ReedMullerCode</li> <li>CyclicCode</li> <li>BCHCode</li> <li>Convolutional coding</li> <li>ConvolutionalCode</li> <li>ConvolutionalStreamEncoder</li> <li>ConvolutionalStreamDecoder</li> <li>TerminatedConvolutionalCode</li> </ul> </li> <li>Finite-state machines<ul> <li>FiniteStateMachine</li> </ul> </li> <li>Modulation<ul> <li>Real modulation schemes</li> <li>RealModulation</li> <li>PAModulation</li> <li>Complex modulation schemes</li> <li>ComplexModulation</li> <li>ASKModulation</li> <li>PSKModulation</li> <li>APSKModulation</li> <li>QAModulation</li> </ul> </li> <li>Pulse formatting<ul> <li>Pulses</li> <li>RectangularPulse</li> <li>ManchesterPulse</li> <li>SincPulse</li> <li>RaisedCosinePulse</li> <li>RootRaisedCosinePulse</li> <li>GaussianPulse</li> <li>Filtering</li> <li>TransmitFilter</li> <li>ReceiveFilter</li> </ul> </li> <li>Quantization<ul> <li>ScalarQuantizer</li> <li>LloydMaxQuantizer</li> <li>UniformQuantizer</li> </ul> </li> <li>Sequences<ul> <li>Binary sequences</li> <li>BinarySequence</li> <li>BarkerSequence</li> <li>WalshHadamardSequence</li> <li>LFSRSequence</li> <li>GoldSequence</li> <li>KasamiSequence</li> <li>Other sequences</li> <li>ZadoffChuSequence</li> </ul> </li> <li>Source coding<ul> <li>Sources</li> <li>DiscreteMemorylessSource</li> <li>Lossless coding</li> <li>FixedToVariableCode</li> <li>HuffmanCode</li> <li>VariableToFixedCode</li> <li>TunstallCode</li> </ul> </li> <li>Utilities<ul> <li>binlist2int</li> <li>int2binlist</li> <li>pack</li> <li>unpack</li> <li>qfunc</li> <li>qfuncinv</li> <li>entropy</li> </ul> </li> </ul>"},{"location":"ref/","title":"Library reference","text":""},{"location":"ref/#algebra","title":"Algebra","text":"<ul> <li><code>BinaryPolynomial</code> \u2013 Binary polynomial.</li> <li><code>BinaryPolynomialFraction</code> \u2013 Binary polynomial fraction.</li> <li><code>FiniteBifield</code> \u2013 Finite field with binary characteristic.</li> <li><code>RationalPolynomial</code> \u2013 Rational polynomial.</li> <li><code>RationalPolynomialFraction</code> \u2013 Rational polynomial fraction.</li> </ul>"},{"location":"ref/#channels","title":"Channels","text":"<ul> <li><code>AWGNChannel</code> \u2013 Additive white Gaussian noise (AWGN) channel.</li> <li><code>DiscreteMemorylessChannel</code> \u2013 Discrete memoryless channel (DMC).</li> <li><code>BinarySymmetricChannel</code> \u2013 Binary symmetric channel (BSC).</li> <li><code>BinaryErasureChannel</code> \u2013 Binary erasure channel (BEC).</li> </ul>"},{"location":"ref/#error-control","title":"Error control","text":""},{"location":"ref/#block-coding","title":"Block coding","text":"<ul> <li><code>BlockCode</code> \u2013 General binary linear block code.</li> <li><code>HammingCode</code> \u2013 Hamming code.</li> <li><code>SimplexCode</code> \u2013 Simplex (maximum-length) code.</li> <li><code>GolayCode</code> \u2013 Binary Golay code.</li> <li><code>RepetitionCode</code> \u2013 Repetition code.</li> <li><code>SingleParityCheckCode</code> \u2013 Single parity check code.</li> <li><code>CordaroWagnerCode</code> \u2013 Cordaro\u2013Wagner code.</li> <li><code>ReedMullerCode</code> \u2013 Reed\u2013Muller code.</li> <li><code>CyclicCode</code> \u2013 General binary cyclic code.</li> <li><code>BCHCode</code> \u2013 Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code.</li> </ul>"},{"location":"ref/#convolutional-coding","title":"Convolutional coding","text":"<ul> <li><code>ConvolutionalCode</code> \u2013 Binary convolutional code.</li> <li><code>ConvolutionalStreamEncoder</code> \u2013 Convolutional stream encoder.</li> <li><code>ConvolutionalStreamDecoder</code> \u2013 Convolutional stream decoder using Viterbi algorithm.</li> <li><code>TerminatedConvolutionalCode</code> \u2013 Terminated convolutional code.</li> </ul>"},{"location":"ref/#finite-state-machines","title":"Finite-state machines","text":"<ul> <li><code>FiniteStateMachine</code> \u2013 Finite-state machine (Mealy machine).</li> </ul>"},{"location":"ref/#modulation","title":"Modulation","text":""},{"location":"ref/#real-modulation-schemes","title":"Real modulation schemes","text":"<ul> <li><code>RealModulation</code> \u2013 General real modulation scheme.</li> <li><code>PAModulation</code> \u2013 Pulse-amplitude modulation (PAM).</li> </ul>"},{"location":"ref/#complex-modulation-schemes","title":"Complex modulation schemes","text":"<ul> <li><code>ComplexModulation</code> \u2013 General complex modulation scheme.</li> <li><code>ASKModulation</code> \u2013 Amplitude-shift keying (ASK) modulation.</li> <li><code>PSKModulation</code> \u2013 Phase-shift keying (PSK) modulation.</li> <li><code>APSKModulation</code> \u2013 Amplitude- and phase-shift keying (APSK) modulation.</li> <li><code>QAModulation</code> \u2013 Quadrature-amplitude modulation (QAM).</li> </ul>"},{"location":"ref/#pulse-formatting","title":"Pulse formatting","text":""},{"location":"ref/#pulses","title":"Pulses","text":"<ul> <li><code>RectangularPulse</code> \u2013 Rectangular pulse.</li> <li><code>ManchesterPulse</code> \u2013 Manchester pulse.</li> <li><code>SincPulse</code> \u2013 Sinc pulse.</li> <li><code>RaisedCosinePulse</code> \u2013 Raised cosine pulse.</li> <li><code>RootRaisedCosinePulse</code> \u2013 Root raised cosine pulse.</li> <li><code>GaussianPulse</code> \u2013 Gaussian pulse.</li> </ul>"},{"location":"ref/#filtering","title":"Filtering","text":"<ul> <li><code>TransmitFilter</code> \u2013 Transmit filter.</li> <li><code>ReceiveFilter</code> \u2013 Receive filter [Not implemented yet].</li> </ul>"},{"location":"ref/#quantization","title":"Quantization","text":"<ul> <li><code>ScalarQuantizer</code> \u2013 General scalar quantizer.</li> <li><code>LloydMaxQuantizer</code> \u2013 Lloyd\u2013Max scalar quantizer [Not implemented yet].</li> <li><code>UniformQuantizer</code> \u2013 Uniform scalar quantizer.</li> </ul>"},{"location":"ref/#sequences","title":"Sequences","text":""},{"location":"ref/#binary-sequences","title":"Binary sequences","text":"<ul> <li><code>BinarySequence</code> \u2013 General binary sequence.</li> <li><code>BarkerSequence</code> \u2013 Barker sequence.</li> <li><code>WalshHadamardSequence</code> \u2013 Walsh\u2013Hadamard sequence.</li> <li><code>LFSRSequence</code> \u2013 Linear-feedback shift register (LFSR) sequence.</li> <li><code>GoldSequence</code> \u2013 Gold sequence [Not implemented yet].</li> <li><code>KasamiSequence</code> \u2013 Kasami sequence [Not implemented yet].</li> </ul>"},{"location":"ref/#other-sequences","title":"Other sequences","text":"<ul> <li><code>ZadoffChuSequence</code> \u2013 Zadoff\u2013Chu sequence [Not implemented yet].</li> </ul>"},{"location":"ref/#source-coding","title":"Source coding","text":""},{"location":"ref/#sources","title":"Sources","text":"<ul> <li><code>DiscreteMemorylessSource</code> \u2013 Discrete memoryless source (DMS).</li> </ul>"},{"location":"ref/#lossless-coding","title":"Lossless coding","text":"<ul> <li><code>FixedToVariableCode</code> \u2013 Binary, prefix-free, fixed-to-variable length code.</li> <li><code>HuffmanCode</code> \u2013 Huffman code.</li> <li><code>VariableToFixedCode</code> \u2013 Binary, prefix-free, variable-to-fixed length code.</li> <li><code>TunstallCode</code> \u2013 Tunstall code.</li> </ul>"},{"location":"ref/#utilities","title":"Utilities","text":"<ul> <li><code>binlist2int</code> \u2013 Converts a bit array to its integer representation.</li> <li><code>int2binlist</code> \u2013 Converts an integer to its bit array representation.</li> <li><code>pack</code> \u2013 Packs a given integer array.</li> <li><code>unpack</code> \u2013 Unpacks a given bit array.</li> <li><code>qfunc</code> \u2013 Computes the Gaussian Q-function.</li> <li><code>qfuncinv</code> \u2013 Computes the inverse Gaussian Q-function.</li> <li><code>entropy</code> \u2013 Computes the entropy of a random variable with a given pmf.</li> </ul>"},{"location":"ref/APSKModulation/","title":"komm.APSKModulation","text":"<p>         Bases: <code>ComplexModulation</code></p> <p>Amplitude- and phase-shift keying (APSK) modulation. It is a complex modulation scheme in which the constellation is the union of component PSK constellations, called rings. More precisely, $$     \\mathcal{S} = \\bigcup_{k \\in [0 : K)} \\mathcal{S}_k, $$ where $K$ is the number of rings and $$     \\mathcal{S}_k = \\left\\{ A_k \\exp \\left( \\mathrm{j} \\frac{2 \\pi i}{M_k} \\right) \\exp(\\mathrm{j} \\phi_k) : i \\in [0 : M_k) \\right\\}, $$ where $M_k$ is the order, $A_k$ is the amplitude, and $\\phi_k$ is the phase offset of the $k$-th ring, for $k \\in [0 : K)$. The size of the resulting complex-valued constellation is $M = M_0 + M_1 + \\cdots + M_{K-1}$. The order $M_k$ of each ring need not be a power of $2$; however, the order $M$ of the constructed APSK modulation must be. The APSK constellation is depicted below for $(M_0, M_1) = (8, 8)$ with $(A_0, A_1) = (A, 2A)$ and $(\\phi_0, \\phi_1) = (0, \\pi/8)$.</p> <p></p>"},{"location":"ref/APSKModulation/#__init__","title":"<code>__init__(orders, amplitudes, phase_offsets=0.0, labeling='natural')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>orders</code> (<code>Tuple[int, ...]</code>)         \u2013          <p>A $K$-tuple with the orders $M_k$ of each ring, for $k \\in [0 : K)$. The sum $M_0 + M_1 + \\cdots + M_{K-1}$ must be a power of $2$.</p> </li> <li> <code>amplitudes</code> (<code>Tuple[float, ...]</code>)         \u2013          <p>A $K$-tuple with the amplitudes $A_k$ of each ring, for $k \\in [0 : K)$.</p> </li> <li> <code>phase_offsets</code> (<code>Optional[Tuple[float, ...] | float]</code>)         \u2013          <p>A $K$-tuple with the phase offsets $\\phi_k$ of each ring, for $k \\in [0 : K)$. If specified as a single float $\\phi$, then it is assumed that $\\phi_k = \\phi$ for all $k \\in [0 : K)$. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling $\\mathcal{Q}$ of the modulation. Can be specified either as a 1D-array of integers, in which case must be permutation of $[0 : M)$, or as a string, in which case must be equal to <code>'natural'</code>. The default value is <code>'natural'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; apsk = komm.APSKModulation(orders=(8,8), amplitudes=(1.0, 2.0), phase_offsets=(0.0, np.pi/8))\n&gt;&gt;&gt; np.round(apsk.constellation, 4)\narray([ 1.    +0.j    ,  0.7071+0.7071j,  0.    +1.j    , -0.7071+0.7071j,\n       -1.    +0.j    , -0.7071-0.7071j, -0.    -1.j    ,  0.7071-0.7071j,\n        1.8478+0.7654j,  0.7654+1.8478j, -0.7654+1.8478j, -1.8478+0.7654j,\n       -1.8478-0.7654j, -0.7654-1.8478j,  0.7654-1.8478j,  1.8478-0.7654j])\n</code></pre>"},{"location":"ref/ASKModulation/","title":"komm.ASKModulation","text":"<p>         Bases: <code>ComplexModulation</code></p> <p>Amplitude-shift keying (ASK) modulation. It is a complex modulation scheme in which the points of the constellation $\\mathcal{S}$ are uniformly arranged in a ray. More precisely, $$     \\mathcal{S} = \\{ iA \\exp(\\mathrm{j}\\phi): i \\in [0 : M) \\}, $$ where $M$ is the order (a power of $2$), $A$ is the base amplitude, and $\\phi$ is the phase offset of the modulation.  The ASK constellation is depicted below for $M = 4$.</p> <p></p>"},{"location":"ref/ASKModulation/#__init__","title":"<code>__init__(order, base_amplitude=1.0, phase_offset=0.0, labeling='reflected')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>order</code> (<code>int</code>)         \u2013          <p>The order $M$ of the modulation. It must be a power of $2$.</p> </li> <li> <code>base_amplitude</code> (<code>Optional[float]</code>)         \u2013          <p>The base amplitude $A$ of the constellation. The default value is <code>1.0</code>.</p> </li> <li> <code>phase_offset</code> (<code>Optional[float]</code>)         \u2013          <p>The phase offset $\\phi$ of the constellation. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling $\\mathcal{Q}$ of the modulation. Can be specified either as a 1D-array of integers, in which case must be permutation of $[0 : M)$, or as a string, in which case must be one of <code>'natural'</code> or <code>'reflected'</code>. The default value is <code>'reflected'</code> (Gray code).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ask = komm.ASKModulation(4, base_amplitude=2.0)\n&gt;&gt;&gt; ask.constellation\narray([0.+0.j, 2.+0.j, 4.+0.j, 6.+0.j])\n&gt;&gt;&gt; ask.labeling\narray([0, 1, 3, 2])\n&gt;&gt;&gt; ask.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([0.+0.j, 4.+0.j, 0.+0.j, 2.+0.j, 2.+0.j])\n&gt;&gt;&gt; ask.demodulate([(0.99+0.3j), (1.01-0.5j), (4.99+0.7j), (5.01-0.9j)])\narray([0, 0, 1, 0, 1, 1, 0, 1])\n</code></pre>"},{"location":"ref/AWGNChannel/","title":"komm.AWGNChannel","text":"<p>Additive white Gaussian noise (AWGN) channel. It is defined by $$     Y_n = X_n + Z_n, $$ where $X_n$ is the channel input signal, $Y_n$ is the channel output signal, and $Z_n$ is the noise, which is iid according to a Gaussian distribution with zero mean. The channel signal-to-noise ratio is calculated by $$     \\snr = \\frac{P}{N}, $$ where $P = \\mathrm{E}[X^2_n]$ is the average power of the input signal, and $N = \\mathrm{E}[Z^2_n]$ is the average power (and variance) of the noise. For more details, see CT06, Ch. 9.</p> <p>To invoke the channel, call the object giving the input signal as parameter (see example in the constructor below).</p>"},{"location":"ref/AWGNChannel/#__init__","title":"<code>__init__(snr=np.inf, signal_power=1.0)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>snr</code> (<code>Optional[float]</code>)         \u2013          <p>The channel signal-to-noise ratio $\\snr$ (linear, not decibel). The default value is <code>np.inf</code>, which corresponds to a noiseless channel.</p> </li> <li> <code>signal_power</code> (<code>Optional[float | str]</code>)         \u2013          <p>The input signal power $P$. If equal to the string <code>'measured'</code>, then every time the channel is invoked the input signal power will be computed from the input itself (i.e., its squared Euclidean norm). The default value is <code>1.0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; awgn = komm.AWGNChannel(snr=100.0, signal_power=5.0)\n&gt;&gt;&gt; x = [1.0, 3.0, -3.0, -1.0, -1.0, 1.0, 3.0, 1.0, -1.0, 3.0]\n&gt;&gt;&gt; y = awgn(x); y\narray([ 0.91623839,  2.66229342, -2.96852259, -1.07689368, -0.89296933,\n        0.80128101,  3.34942297,  1.24031682, -0.84460601,  2.96762221])\n</code></pre>"},{"location":"ref/AWGNChannel/#komm._channels.AWGNChannel.AWGNChannel.snr","title":"<code>snr</code>  <code>property</code> <code>writable</code>","text":"<p>The signal-to-noise ratio $\\snr$ (linear, not decibel) of the channel.</p>"},{"location":"ref/AWGNChannel/#komm._channels.AWGNChannel.AWGNChannel.signal_power","title":"<code>signal_power</code>  <code>property</code> <code>writable</code>","text":"<p>The input signal power $P$.</p>"},{"location":"ref/AWGNChannel/#capacity","title":"<code>capacity()</code>","text":"<p>Returns the channel capacity $C$. It is given by $C = \\frac{1}{2}\\log_2(1 + \\snr)$, in bits per dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; awgn = komm.AWGNChannel(snr=63.0)\n&gt;&gt;&gt; awgn.capacity()\n3.0\n</code></pre>"},{"location":"ref/BCHCode/","title":"komm.BCHCode","text":"<p>         Bases: <code>CyclicCode</code></p> <p>Bose\u2013Chaudhuri\u2013Hocquenghem (BCH) code. It is a cyclic code specified by two integers $\\mu$ and $\\tau$ which must satisfy $1 \\leq \\tau &lt; 2^{\\mu - 1}$. The parameter $\\tau$ is called the designed error-correcting capability of the BCH code; it will be internally replaced by the true error-correcting capability $t$ of the code. See references for more details. The resulting code is denoted by $\\bch(\\mu, \\tau)$, and has the following parameters:</p> <ul> <li>Length: $n = 2^{\\mu} - 1$</li> <li>Dimension: $k \\geq n - \\mu \\tau$</li> <li>Redundancy: $m \\leq \\mu \\tau$</li> <li>Minimum distance: $d \\geq 2\\tau + 1$</li> </ul> <p>For more details, see LC04, Ch. 6.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BCHCode(5, 3)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(31, 16, 7)\n&gt;&gt;&gt; code.generator_polynomial\nBinaryPolynomial(0b1000111110101111)\n</code></pre> <pre><code>&gt;&gt;&gt; # The true error-correcting capability is equal to the designed one:\n&gt;&gt;&gt; code = komm.BCHCode(7, 15); code\nBCHCode(7, 15)\n&gt;&gt;&gt; # The true error-correcting capability is greater than the designed one:\n&gt;&gt;&gt; code = komm.BCHCode(7, 16); code\nBCHCode(7, 21)\n</code></pre>"},{"location":"ref/BCHCode/#__init__","title":"<code>__init__(mu, tau)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>mu</code> (<code>int</code>)         \u2013          <p>The parameter $\\mu$ of the code.</p> </li> <li> <code>tau</code> (<code>int</code>)         \u2013          <p>The designed error-correcting capability $\\tau$ of the BCH code. It will be internally replaced by the true error-correcting capability $t$ of the code.</p> </li> </ul>"},{"location":"ref/BarkerSequence/","title":"komm.BarkerSequence","text":"<p>         Bases: <code>BinarySequence</code></p> <p>Barker sequence. A Barker sequence is a binary sequence with autocorrelation $R[\\ell]$ satisfying $|R[\\ell]| \\leq 1$, for $\\ell \\neq 0$. The only known Barker sequences (up to negation and reversion) are shown in the table below.</p> Length $L$ Barker sequence $b[n]$ $2$ $01$ and $00$ $3$ $001$ $4$ $0010$ and $0001$ $5$ $00010$ $7$ $0001101$ $11$ $00011101101$ $13$ $0000011001010$ References <ol> <li>https://en.wikipedia.org/wiki/Barker_code</li> </ol>"},{"location":"ref/BarkerSequence/#__init__","title":"<code>__init__(length)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>length</code> (<code>int</code>)         \u2013          <p>Length of the Barker sequence. Must be in the set $\\{ 2, 3, 4, 5, 7, 11, 13 \\}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; barker = komm.BarkerSequence(length=13)\n&gt;&gt;&gt; barker.polar_sequence\narray([ 1,  1,  1,  1,  1, -1, -1,  1,  1, -1,  1, -1,  1])\n&gt;&gt;&gt; barker.autocorrelation()\narray([13,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1])\n</code></pre>"},{"location":"ref/BinaryErasureChannel/","title":"komm.BinaryErasureChannel","text":"<p>         Bases: <code>DiscreteMemorylessChannel</code></p> <p>Binary erasure channel (BEC). It is a discrete memoryless channel with input alphabet $\\mathcal{X} = \\{ 0, 1 \\}$, output alphabet $\\mathcal{Y} = \\{ 0, 1, 2 \\}$, and transition probability matrix given by $$     p_{Y \\mid X} =     \\begin{bmatrix}         1 - \\epsilon &amp; 0 &amp; \\epsilon \\\\         0 &amp; 1 - \\epsilon &amp; \\epsilon     \\end{bmatrix}, $$ where the parameter $\\epsilon$ is called the erasure probability of the channel. For more details, see CT06, Sec. 7.1.5.</p> <p>To invoke the channel, call the object giving the input signal as parameter (see example in the constructor below).</p>"},{"location":"ref/BinaryErasureChannel/#__init__","title":"<code>__init__(erasure_probability=0.0)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>erasure_probability</code> (<code>Optional[float]</code>)         \u2013          <p>The channel erasure probability $\\epsilon$. Must satisfy $0 \\leq \\epsilon \\leq 1$. Default value is <code>0.0</code>, which corresponds to a noiseless channel.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bec = komm.BinaryErasureChannel(0.1)\n&gt;&gt;&gt; x = [1, 1, 1, 0, 0, 0, 1, 0, 1, 0]\n&gt;&gt;&gt; y = bec(x); y\narray([1, 1, 1, 2, 0, 0, 1, 0, 1, 0])\n</code></pre>"},{"location":"ref/BinaryErasureChannel/#komm._channels.BinaryErasureChannel.BinaryErasureChannel.erasure_probability","title":"<code>erasure_probability</code>  <code>property</code> <code>writable</code>","text":"<p>The erasure probability $\\epsilon$ of the channel.</p>"},{"location":"ref/BinaryErasureChannel/#capacity","title":"<code>capacity()</code>","text":"<p>Returns the channel capacity $C$. It is given by $C = 1 - \\epsilon$. See CT06, Sec. 7.1.5.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bec = komm.BinaryErasureChannel(0.25)\n&gt;&gt;&gt; bec.capacity()\n0.75\n</code></pre>"},{"location":"ref/BinaryPolynomial/","title":"komm.BinaryPolynomial","text":"<p>Binary polynomial. A binary polynomial is a polynomial whose coefficients are elements in the finite field $\\mathbb{F}_2 = \\{ 0, 1 \\}$. This class supports addition, multiplication, division, and exponentiation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly1 = komm.BinaryPolynomial(0b10100)  # X^4 + X^2\n&gt;&gt;&gt; poly2 = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly1 + poly2  # X^3 + X^2 + X\nBinaryPolynomial(0b1110)\n&gt;&gt;&gt; poly1 * poly2  # X^8 + X^7 + X^6 + X^3\nBinaryPolynomial(0b111001000)\n&gt;&gt;&gt; poly1**2  # X^8 + X^4\nBinaryPolynomial(0b100010000)\n</code></pre>"},{"location":"ref/BinaryPolynomial/#__init__","title":"<code>__init__(integer)</code>","text":"<p>Default constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>integer</code> (<code>int</code>)         \u2013          <p>An integer whose binary digits represent the coefficients of the polynomial\u2014the leftmost bit standing for the highest degree term. For example, the binary polynomial $X^4 + X^3 + X$ is represented by the integer <code>0b11010</code> = <code>0o32</code> = <code>26</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\nBinaryPolynomial(0b11010)\n</code></pre> <p>See also the class methods <code>from_coefficients</code> and <code>from_exponents</code> for alternative ways to construct a binary polynomial.</p>"},{"location":"ref/BinaryPolynomial/#from_coefficients","title":"<code>from_coefficients(coefficients)</code>  <code>classmethod</code>","text":"<p>Constructs a binary polynomial from its coefficients.</p> <p>Parameters:</p> <ul> <li> <code>coefficients</code> (<code>Array1D[int]</code>)         \u2013          <p>The coefficients of the binary polynomial\u2014the $i$-th element of the array standing for the coefficient of $X^i$. For example, <code>[0, 1, 0, 1, 1]</code> represents the binary polynomial $X^4 + X^3 + X$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.BinaryPolynomial.from_coefficients([0, 1, 0, 1, 1])  # X^4 + X^3 + X\nBinaryPolynomial(0b11010)\n</code></pre>"},{"location":"ref/BinaryPolynomial/#from_exponents","title":"<code>from_exponents(exponents)</code>  <code>classmethod</code>","text":"<p>Constructs a binary polynomial from its exponents.</p> <p>Parameters:</p> <ul> <li> <code>exponents</code> (<code>Array1D[int]</code>)         \u2013          <p>The exponents of the nonzero terms of the binary polynomial. For example, <code>[1, 3, 4]</code> represents the binary polynomial $X^4 + X^3 + X$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.BinaryPolynomial.from_exponents([1, 3, 4])  # X^4 + X^3 + X\nBinaryPolynomial(0b11010)\n</code></pre>"},{"location":"ref/BinaryPolynomial/#komm._algebra.BinaryPolynomial.BinaryPolynomial.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>The degree of the polynomial.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.degree\n4\n</code></pre>"},{"location":"ref/BinaryPolynomial/#coefficients","title":"<code>coefficients(width=None)</code>","text":"<p>Returns the coefficients of the binary polynomial.</p> <p>Parameters:</p> <ul> <li> <code>width</code> (<code>Optional[int]</code>)         \u2013          <p>If this parameter is specified, the output will be filled with zeros on the right so that the its length will be the specified value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>coefficients</code>  (<code>Array1D[int]</code>)          \u2013          <p>Coefficients of the binary polynomial. The $i$-th element of the array stands for the coefficient of $X^i$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.coefficients()\narray([0, 1, 0, 1, 1])\n&gt;&gt;&gt; poly.coefficients(width=8)\narray([0, 1, 0, 1, 1, 0, 0, 0])\n</code></pre>"},{"location":"ref/BinaryPolynomial/#exponents","title":"<code>exponents()</code>","text":"<p>Returns the exponents of the binary polynomial.</p> <p>Returns:</p> <ul> <li> <code>exponents</code>  (<code>Array1D[int]</code>)          \u2013          <p>Exponents of the nonzero terms of the binary polynomial. The exponents are returned in ascending order.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.exponents()\narray([1, 3, 4])\n</code></pre>"},{"location":"ref/BinaryPolynomial/#evaluate","title":"<code>evaluate(point)</code>","text":"<p>Evaluates the polynomial at a given point. Uses Horner's method.</p> <p>Parameters:</p> <ul> <li> <code>point</code> (<code>RingElement</code>)         \u2013          <p>Any Python object supporting the operations of addition, subtraction, and multiplication.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>result</code>  (<code>RingElement</code>)          \u2013          <p>The result of evaluating the binary polynomial at <code>point</code>. It has the same type as <code>point</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.BinaryPolynomial(0b11010)  # X^4 + X^3 + X\n&gt;&gt;&gt; poly.evaluate(7)  # same as 7**4 + 7**3 + 7\n2751\n&gt;&gt;&gt; point = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; poly.evaluate(point)  # same as point**4 + point**3 + point\narray([[  3,  26],\n       [111, 324]])\n</code></pre>"},{"location":"ref/BinaryPolynomial/#xgcd","title":"<code>xgcd(poly1, poly2)</code>  <code>classmethod</code>","text":"<p>Performs the extended Euclidean algorithm on two given binary polynomials.</p>"},{"location":"ref/BinaryPolynomial/#gcd","title":"<code>gcd(*poly_list)</code>  <code>classmethod</code>","text":"<p>Computes the greatest common divisor (gcd) of the arguments.</p>"},{"location":"ref/BinaryPolynomial/#lcm","title":"<code>lcm(*poly_list)</code>  <code>classmethod</code>","text":"<p>Computes the least common multiple (lcm) of the arguments.</p>"},{"location":"ref/BinaryPolynomialFraction/","title":"komm.BinaryPolynomialFraction","text":"<p>Binary polynomial fraction. A binary polynomial fraction is a ratio of two binary polynomials.</p>"},{"location":"ref/BinaryPolynomialFraction/#komm._algebra.BinaryPolynomialFraction.BinaryPolynomialFraction.numerator","title":"<code>numerator</code>  <code>property</code>","text":"<p>The numerator of the polynomial fraction.</p>"},{"location":"ref/BinaryPolynomialFraction/#komm._algebra.BinaryPolynomialFraction.BinaryPolynomialFraction.denominator","title":"<code>denominator</code>  <code>property</code>","text":"<p>The denominator of the polynomial fraction.</p>"},{"location":"ref/BinaryPolynomialFraction/#inverse","title":"<code>inverse()</code>","text":"<p>Returns the multiplicative inverse the polynomial fraction.</p>"},{"location":"ref/BinarySequence/","title":"komm.BinarySequence","text":"<p>General binary sequence. It may be represented either in bit format, denoted by $b[n]$, with elements in the set $\\{ 0, 1 \\}$, or in polar format, denoted by $a[n]$, with elements in the set $\\{ \\pm 1 \\}$. The correspondences $0 \\mapsto +1$ and $1 \\mapsto -1$ from bit format to polar format is assumed.</p>"},{"location":"ref/BinarySequence/#__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for the class. It expects exactly one the following parameters:</p> <p>Parameters:</p> <ul> <li> <code>bit_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The binary sequence in bit format. Must be a 1D-array with elements in $\\{ 0, 1 \\}$.</p> </li> <li> <code>polar_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The binary sequence in polar format. Must be a 1D-array with elements in $\\{ \\pm 1 \\}$.</p> </li> </ul>"},{"location":"ref/BinarySequence/#komm._sequences.BinarySequence.BinarySequence.bit_sequence","title":"<code>bit_sequence</code>  <code>property</code>","text":"<p>The binary sequence in bit format, $b[n] \\in \\{ 0, 1 \\}$.</p>"},{"location":"ref/BinarySequence/#komm._sequences.BinarySequence.BinarySequence.polar_sequence","title":"<code>polar_sequence</code>  <code>property</code>","text":"<p>The binary sequence in polar format, $a[n] \\in \\{ \\pm 1 \\}$.</p>"},{"location":"ref/BinarySequence/#komm._sequences.BinarySequence.BinarySequence.length","title":"<code>length</code>  <code>property</code>","text":"<p>The length (or period) $L$ of the binary sequence.</p>"},{"location":"ref/BinarySequence/#autocorrelation","title":"<code>autocorrelation(shifts=None, normalized=False)</code>","text":"<p>Returns the autocorrelation $R[\\ell]$ of the binary sequence. This is defined as $$     R[\\ell] = \\sum_{n \\in \\mathbb{Z}} a[n] a_\\ell[n], $$ where $a[n]$ is the binary sequence in polar format, and $a_\\ell[n] = a[n - \\ell]$ is the sequence $a[n]$ shifted by $\\ell$ positions. The autocorrelation $R[\\ell]$ is even and satisfies $R[\\ell] = 0$ for $|\\ell| \\geq L$, where $L$ is the length of the binary sequence.</p> <p>Parameters:</p> <ul> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>A 1D-array containing the values of $\\ell$ for which the autocorrelation will be computed. The default value is <code>range(L)</code>, that is, $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>If <code>True</code>, returns the autocorrelation divided by $L$, where $L$ is the length of the binary sequence, so that $R[0] = 1$. The default value is <code>False</code>.</p> </li> </ul>"},{"location":"ref/BinarySequence/#cyclic_autocorrelation","title":"<code>cyclic_autocorrelation(shifts=None, normalized=False)</code>","text":"<p>Returns the cyclic autocorrelation $\\tilde{R}[\\ell]$ of the binary sequence. This is defined as $$     \\tilde{R}[\\ell] = \\sum_{n \\in [0:L)} a[n] \\tilde{a}_\\ell[n], $$ where $a[n]$ is the binary sequence in polar format, and $\\tilde{a}_\\ell[n]$ is the sequence $a[n]$ cyclic-shifted by $\\ell$ positions. The cyclic autocorrelation $\\tilde{R}[\\ell]$ is even and periodic with period $L$, where $L$ is the period of the binary sequence.</p> <p>Parameters:</p> <ul> <li> <code>shifts</code> (<code>Optional[Array1D[int]]</code>)         \u2013          <p>A 1D-array containing the values of $\\ell$ for which the cyclic autocorrelation will be computed. The default value is <code>range(L)</code>, that is, $[0 : L)$.</p> </li> <li> <code>normalized</code> (<code>Optional[bool]</code>)         \u2013          <p>If <code>True</code>, returns the cyclic autocorrelation divided by $L$, where $L$ is the length of the binary sequence, so that $\\tilde{R}[0] = 1$. The default value is <code>False</code>.</p> </li> </ul>"},{"location":"ref/BinarySymmetricChannel/","title":"komm.BinarySymmetricChannel","text":"<p>         Bases: <code>DiscreteMemorylessChannel</code></p> <p>Binary symmetric channel (BSC). It is a discrete memoryless channel with input and output alphabets given by $\\mathcal{X} = \\mathcal{Y} = \\{ 0, 1 \\}$, and transition probability matrix given by $$     p_{Y \\mid X} = \\begin{bmatrix} 1-p &amp; p \\\\ p &amp; 1-p \\end{bmatrix}, $$ where the parameter $p$ is called the crossover probability of the channel. Equivalently, a BSC with crossover probability $p$ may be defined by $$     Y_n = X_n + Z_n, $$ where $Z_n$ are iid Bernoulli random variables with $\\Pr[Z_n = 1] = p$. For more details, see CT06, Sec. 7.1.4.</p> <p>To invoke the channel, call the object giving the input signal as parameter (see example below).</p>"},{"location":"ref/BinarySymmetricChannel/#__init__","title":"<code>__init__(crossover_probability=0.0)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>crossover_probability</code> (<code>Optional[float]</code>)         \u2013          <p>The channel crossover probability $p$. Must satisfy $0 \\leq p \\leq 1$. The default value is <code>0.0</code>, which corresponds to a noiseless channel.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bsc = komm.BinarySymmetricChannel(0.1)\n&gt;&gt;&gt; x = [0, 1, 1, 1, 0, 0, 0, 0, 0, 1]\n&gt;&gt;&gt; y = bsc(x); y\narray([0, 1, 1, 1, 0, 0, 0, 1, 0, 0])\n</code></pre>"},{"location":"ref/BinarySymmetricChannel/#komm._channels.BinarySymmetricChannel.BinarySymmetricChannel.crossover_probability","title":"<code>crossover_probability</code>  <code>property</code> <code>writable</code>","text":"<p>The crossover probability $p$ of the channel.</p>"},{"location":"ref/BinarySymmetricChannel/#capacity","title":"<code>capacity()</code>","text":"<p>Returns the channel capacity $C$. It is given by $C = 1 - \\mathcal{H}(p)$. See CT06, Sec. 7.1.4.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bsc = komm.BinarySymmetricChannel(0.25)\n&gt;&gt;&gt; bsc.capacity()\n0.18872187554086717\n</code></pre>"},{"location":"ref/BlockCode/","title":"komm.BlockCode","text":"<p>General binary linear block code. It is characterized by its generator matrix $G$, a binary $k \\times n$ matrix, and by its parity-check matrix $H$, a binary $m \\times n$ matrix. Those matrix are related by $G H^\\top = 0$. The parameters $k$, $m$, and $n$ are called the code dimension, redundancy, and length, respectively, and are related by $k + m = n$. For more details, see LC04, Ch. 3.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.BlockCode(parity_submatrix=[[0, 1, 1], [1, 0, 1], [1, 1, 0]])\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [0, 0, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.parity_check_matrix\narray([[0, 1, 1, 1, 0, 0],\n       [1, 0, 1, 0, 1, 0],\n       [1, 1, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.codeword_table\narray([[0, 0, 0, 0, 0, 0],\n       [1, 0, 0, 0, 1, 1],\n       [0, 1, 0, 1, 0, 1],\n       [1, 1, 0, 1, 1, 0],\n       [0, 0, 1, 1, 1, 0],\n       [1, 0, 1, 1, 0, 1],\n       [0, 1, 1, 0, 1, 1],\n       [1, 1, 1, 0, 0, 0]])\n&gt;&gt;&gt; code.codeword_weight_distribution\narray([1, 0, 0, 4, 3, 0, 0])\n&gt;&gt;&gt; code.coset_leader_table\narray([[0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 1, 0],\n       [0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1],\n       [0, 1, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0, 0],\n       [1, 0, 0, 1, 0, 0]])\n&gt;&gt;&gt; code.coset_leader_weight_distribution\narray([1, 6, 1, 0, 0, 0, 0])\n&gt;&gt;&gt; (code.packing_radius, code.covering_radius)\n(1, 2)\n</code></pre>"},{"location":"ref/BlockCode/#__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for the class. It expects one of the following formats:</p> <p>Via generator matrix</p> <p><code>komm.BlockCode(generator_matrix=generator_matrix)</code></p> <p>Parameters:</p> <ul> <li> <code>generator_matrix</code> (<code>Array2D[int]</code>)         \u2013          <p>Generator matrix $G$ for the code, which is a $k \\times n$ binary matrix.</p> </li> </ul> <p>Via parity-check matrix</p> <p><code>komm.BlockCode(parity_check_matrix=parity_check_matrix)</code></p> <p>Parameters:</p> <ul> <li> <code>parity_check_matrix</code> (<code>Array2D[int]</code>)         \u2013          <p>Parity-check matrix $H$ for the code, which is an $m \\times n$ binary matrix.</p> </li> </ul> <p>Via parity submatrix and information set</p> <p><code>komm.BlockCode(parity_submatrix=parity_submatrix, information_set=information_set)</code></p> <p>Parameters:</p> <ul> <li> <code>parity_submatrix</code> (<code>Array2D[int]</code>)         \u2013          <p>Parity submatrix $P$ for the code, which is a $k \\times m$ binary matrix.</p> </li> <li> <code>information_set</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>Either an array containing the indices of the information positions, which must be a $k$-sublist of $[0 : n)$, or one of the strings <code>'left'</code> or <code>'right'</code>. The default value is <code>'left'</code>.</p> </li> </ul>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.length","title":"<code>length</code>  <code>property</code>","text":"<p>The length $n$ of the code.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.dimension","title":"<code>dimension</code>  <code>property</code>","text":"<p>The dimension $k$ of the code.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.redundancy","title":"<code>redundancy</code>  <code>property</code>","text":"<p>The redundancy $m$ of the code.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.rate","title":"<code>rate</code>  <code>property</code>","text":"<p>The rate $R = k/n$ of the code.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.minimum_distance","title":"<code>minimum_distance</code>  <code>cached</code> <code>property</code>","text":"<p>The minimum distance $d$ of the code. This is equal to the minimum Hamming weight of the non-zero codewords.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.packing_radius","title":"<code>packing_radius</code>  <code>cached</code> <code>property</code>","text":"<p>The packing radius of the code. This is also called the error-correcting capability of the code, and is equal to $\\lfloor (d - 1) / 2 \\rfloor$.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.covering_radius","title":"<code>covering_radius</code>  <code>cached</code> <code>property</code>","text":"<p>The covering radius of the code. This is equal to the maximum Hamming weight of the coset leaders.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.generator_matrix","title":"<code>generator_matrix</code>  <code>cached</code> <code>property</code>","text":"<p>The generator matrix $G$ of the code. It as a $k \\times n$ binary matrix, where $k$ is the code dimension, and $n$ is the code length.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.parity_check_matrix","title":"<code>parity_check_matrix</code>  <code>cached</code> <code>property</code>","text":"<p>The parity-check matrix $H$ of the code. It as an $m \\times n$ binary matrix, where $m$ is the code redundancy, and $n$ is the code length.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.codeword_table","title":"<code>codeword_table</code>  <code>cached</code> <code>property</code>","text":"<p>The codeword table of the code. This is a $2^k \\times n$ matrix whose rows are all the codewords. The codeword in row $i$ corresponds to the message whose binary representation (MSB in the right) is $i$.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.codeword_weight_distribution","title":"<code>codeword_weight_distribution</code>  <code>cached</code> <code>property</code>","text":"<p>The codeword weight distribution of the code. This is an array of shape $(n + 1)$ in which element in position $w$ is equal to the number of codewords of Hamming weight $w$, for $w \\in [0 : n]$.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.coset_leader_table","title":"<code>coset_leader_table</code>  <code>cached</code> <code>property</code>","text":"<p>The coset leader table of the code. This is a $2^m \\times n$ matrix whose rows are all the coset leaders. The coset leader in row $i$ corresponds to the syndrome whose binary representation (MSB in the right) is $i$. This may be used as a LUT for syndrome-based decoding.</p>"},{"location":"ref/BlockCode/#komm._error_control_block.BlockCode.BlockCode.coset_leader_weight_distribution","title":"<code>coset_leader_weight_distribution</code>  <code>cached</code> <code>property</code>","text":"<p>The coset leader weight distribution of the code. This is an array of shape $(n + 1)$ in which element in position $w$ is equal to the number of coset leaders of weight $w$, for $w \\in [0 : n]$.</p>"},{"location":"ref/BlockCode/#encode","title":"<code>encode(message, method=None)</code>","text":"<p>Encodes a given message to its corresponding codeword.</p> <p>Parameters:</p> <ul> <li> <code>message</code> (<code>Array1D[int]</code>)         \u2013          <p>The message to be encoded. Its length must be $k$.</p> </li> <li> <code>method</code> (<code>Optional[str]</code>)         \u2013          <p>The encoding method to be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>codeword</code>  (<code>Array1D[int]</code>)          \u2013          <p>The codeword corresponding to <code>message</code>. Its length is equal to $n$.</p> </li> </ul>"},{"location":"ref/BlockCode/#message_from_codeword","title":"<code>message_from_codeword(codeword)</code>","text":"<p>Returns the message corresponding to a given codeword. In other words, applies the inverse encoding map.</p> <p>Parameters:</p> <ul> <li> <code>codeword</code> (<code>Array1D[int]</code>)         \u2013          <p>A codeword from the code. Its length must be $n$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>message</code>  (<code>Array1D[int]</code>)          \u2013          <p>The message corresponding to <code>codeword</code>. Its length is equal to $k$.</p> </li> </ul>"},{"location":"ref/BlockCode/#decode","title":"<code>decode(recvword, method=None, **kwargs)</code>","text":"<p>Decodes a received word to a message.</p> <p>Parameters:</p> <ul> <li> <code>recvword</code> (<code>Array1D[int] | Array1D[float]</code>)         \u2013          <p>The word to be decoded. If using a hard-decision decoding method, then the elements of the array must be bits (integers in $\\{ 0, 1 \\}$). If using a soft-decision decoding method, then the elements of the array must be soft-bits (floats standing for log-probability ratios, in which positive values represent bit $0$ and negative values represent bit $1$). Its length must be $n$.</p> </li> <li> <code>method</code> (<code>Optional[str]</code>)         \u2013          <p>The decoding method to be used.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Keyword arguments to be passed to the decoding method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>message_hat</code>  (<code>Array1D[int]</code>)          \u2013          <p>The message decoded from <code>recvword</code>. Its length is equal to $k$.</p> </li> </ul>"},{"location":"ref/ComplexModulation/","title":"komm.ComplexModulation","text":"<p>         Bases: <code>Modulation</code></p> <p>General complex modulation scheme. A complex modulation scheme of order $M$ is defined by a constellation $\\mathcal{S}$, which is an ordered subset (a list) of complex numbers, with $|\\mathcal{S}| = M$, and a binary labeling $\\mathcal{Q}$, which is a permutation of $[0: M)$. The order $M$ of the modulation must be a power of $2$.</p>"},{"location":"ref/ComplexModulation/#__init__","title":"<code>__init__(constellation, labeling)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>constellation</code> (<code>Array1D[complex]</code>)         \u2013          <p>The constellation $\\mathcal{S}$ of the modulation. Must be a 1D-array containing $M$ complex numbers.</p> </li> <li> <code>labeling</code> (<code>Array1D[int]</code>)         \u2013          <p>The binary labeling $\\mathcal{Q}$ of the modulation. Must be a 1D-array of integers corresponding to a permutation of $[0 : M)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.ComplexModulation(constellation=[0.0, -1, 1, 1j], labeling=[0, 1, 2, 3])\n&gt;&gt;&gt; mod.constellation\narray([ 0.+0.j, -1.+0.j,  1.+0.j,  0.+1.j])\n&gt;&gt;&gt; mod.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([ 0.+0.j,  0.+1.j,  0.+0.j, -1.+0.j, -1.+0.j])\n</code></pre>"},{"location":"ref/ConvolutionalCode/","title":"komm.ConvolutionalCode","text":"<p>Binary convolutional code. It is characterized by a matrix of feedforward polynomials $P(D)$, of shape $k \\times n$, and (optionally) by a vector of feedback polynomials $q(D)$, of length $k$. The element in row $i$ and column $j$ of $P(D)$ is denoted by $p_{i,j}(D)$, and the element in position $i$ of $q(D)$ is denoted by $q_i(D)$; they are binary polynomials in $D$. The parameters $k$ and $n$ are the number of input and output bits per block, respectively.</p> <p>The transfer function matrix (also known as transform-domain generator matrix) $G(D)$ of the convolutional code, of shape $k \\times n$, is such that the element in row $i$ and column $j$ is given by $$     g_{i,j}(D) = \\frac{p_{i,j}(D)}{q_{i}(D)}, $$ for $i \\in [0 : k)$ and $j \\in [0 : n)$.</p> Constraint lengths and related parameters <p>The constraint lengths of the code are defined by $$     \\nu_i = \\max \\{ \\deg p_{i,0}(D), \\deg p_{i,1}(D), \\ldots, \\deg p_{i,n-1}(D), \\deg q_i(D) \\}, $$ for $i \\in [0 : k)$.</p> <p>The overall constraint length of the code is defined by $$     \\nu = \\sum_{0 \\leq i &lt; k} \\nu_i. $$</p> <p>The memory order of the code is defined by $$     \\mu = \\max_{0 \\leq i &lt; k} \\nu_i. $$</p> Space-state representation <p>A convolutional code may also be described via the space-state representation. Let $\\mathbf{u}_t = (u_t^{(0)}, u_t^{(1)}, \\ldots, u_t^{(k-1)})$ be the input block, $\\mathbf{v}_t = (v_t^{(0)}, v_t^{(1)}, \\ldots, v_t^{(n-1)})$ be the output block, and $\\mathbf{s}_t = (s_t^{(0)}, s_t^{(1)}, \\ldots, s_t^{(\\nu-1)})$ be the state, all defined at time instant $t$. Then, $$ \\begin{aligned}     \\mathbf{s}_{t+1} &amp; = \\mathbf{s}_t A + \\mathbf{u}_t B, \\\\     \\mathbf{v}_{t} &amp; = \\mathbf{s}_t C + \\mathbf{u}_t D, \\end{aligned} $$ where $A$ is the $\\nu \\times \\nu$ state matrix, $B$ is the $k \\times \\nu$ control matrix, $C$ is the $\\nu \\times n$ observation matrix, and $D$ is the $k \\times n$ transition matrix.</p> Tables of convolutional codes <p>The tables below LC04, Sec. 12.3 lists optimal convolutional codes with parameters $(n,k) = (2,1)$ and $(n,k) = (3,1)$, for small values of the overall constraint length $\\nu$.</p> Parameters $(n, k, \\nu)$ Transfer function matrix $G(D)$ $(2, 1, 1)$ <code>[[0o1, 0o3]]</code> $(2, 1, 2)$ <code>[[0o5, 0o7]]</code> $(2, 1, 3)$ <code>[[0o13, 0o17]]</code> $(2, 1, 4)$ <code>[[0o27, 0o31]]</code> $(2, 1, 5)$ <code>[[0o53, 0o75]]</code> $(2, 1, 6)$ <code>[[0o117, 0o155]]</code> $(2, 1, 7)$ <code>[[0o247, 0o371]]</code> $(2, 1, 8)$ <code>[[0o561, 0o753]]</code> Parameters $(n, k, \\nu)$ Transfer function matrix $G(D)$ $(3, 1, 1)$ <code>[[0o1, 0o3, 0o3]]</code> $(3, 1, 2)$ <code>[[0o5, 0o7, 0o7]]</code> $(3, 1, 3)$ <code>[[0o13, 0o15, 0o17]]</code> $(3, 1, 4)$ <code>[[0o25, 0o33, 0o37]]</code> $(3, 1, 5)$ <code>[[0o47, 0o53, 0o75]]</code> $(3, 1, 6)$ <code>[[0o117, 0o127, 0o155]]</code> $(3, 1, 7)$ <code>[[0o255, 0o331, 0o367]]</code> $(3, 1, 8)$ <code>[[0o575, 0o623, 0o727]]</code> <p>For more details, see JZ15 and LC04, Chs. 11, 12.</p>"},{"location":"ref/ConvolutionalCode/#__init__","title":"<code>__init__(feedforward_polynomials, feedback_polynomials=None)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>feedforward_polynomials</code> (<code>Array2D[BinaryPolynomial, int]</code>)         \u2013          <p>The matrix of feedforward polynomials $P(D)$, which is a $k \\times n$ matrix whose entries are either binary polynomials or integers to be converted to the former.</p> </li> <li> <code>feedback_polynomials</code> (<code>Optional[Array1D[BinaryPolynomial, int]]</code>)         \u2013          <p>The vector of feedback polynomials $q(D)$, which is a $k$-vector whose entries are either binary polynomials or integers to be converted to the former. The default value corresponds to no feedback, that is, $q_i(D) = 1$ for all $i \\in [0 : k)$.</p> </li> </ul> <p>Examples:</p> <p>The convolutional code with encoder depicted in the figure below has parameters $(n, k, \\nu) = (2, 1, 6)$; its transfer function matrix is given by $$     G(D) =     \\begin{bmatrix}         D^6 + D^3 + D^2 + D + 1  &amp;  D^6 + D^5 + D^3 + D^2 + 1     \\end{bmatrix}, $$ yielding <code>feedforward_polynomials = [[0b1001111, 0b1101101]] = [[0o117, 0o155]] = [[79, 109]]</code>.</p> <p></p> <pre><code>&gt;&gt;&gt; code = komm.ConvolutionalCode(feedforward_polynomials=[[0o117, 0o155]])\n&gt;&gt;&gt; (code.num_output_bits, code.num_input_bits, code.overall_constraint_length)\n(2, 1, 6)\n</code></pre> <p>The convolutional code with encoder depicted in the figure below has parameters $(n, k, \\nu) = (3, 2, 7)$; its transfer function matrix is given by $$     G(D) =     \\begin{bmatrix}         D^4 + D^3 + 1  &amp;  D^4 + D^2 + D + 1  &amp;  0 \\\\         0  &amp;  D^3 + D  &amp;  D^3 + D^2 + 1     \\end{bmatrix}, $$ yielding <code>feedforward_polynomials = [[0b11001, 0b10111, 0b00000], [0b0000, 0b1010, 0b1101]] = [[0o31, 0o27, 0o00], [0o00, 0o12, 0o15]] = [[25, 23, 0], [0, 10, 13]]</code>.</p> <p></p> <pre><code>&gt;&gt;&gt; code = komm.ConvolutionalCode(feedforward_polynomials=[[0o31, 0o27, 0o00], [0o00, 0o12, 0o15]])\n&gt;&gt;&gt; (code.num_output_bits, code.num_input_bits, code.overall_constraint_length)\n(3, 2, 7)\n</code></pre> <p>The convolutional code with feedback encoder depicted in the figure below has parameters $(n, k, \\nu) = (2, 1, 4)$; its transfer function matrix is given by $$     G(D) =     \\begin{bmatrix}         1  &amp;  \\dfrac{D^4 + D^3 + 1}{D^4 + D^2 + D + 1}     \\end{bmatrix}, $$ yielding <code>feedforward_polynomials = [[0b10111, 0b11001]] = [[0o27, 0o31]] = [[23, 25]]</code> and <code>feedback_polynomials = [0o27]</code>.</p> <p></p> <pre><code>&gt;&gt;&gt; code = komm.ConvolutionalCode(feedforward_polynomials=[[0o27, 0o31]], feedback_polynomials=[0o27])\n&gt;&gt;&gt; (code.num_output_bits, code.num_input_bits, code.overall_constraint_length)\n(2, 1, 4)\n</code></pre>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.num_input_bits","title":"<code>num_input_bits</code>  <code>property</code>","text":"<p>The number of input bits per block, $k$.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.num_output_bits","title":"<code>num_output_bits</code>  <code>property</code>","text":"<p>The number of output bits per block, $n$.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.constraint_lengths","title":"<code>constraint_lengths</code>  <code>property</code>","text":"<p>The constraint lengths $\\nu_i$ of the code, for $i \\in [0 : k)$. This is a $k$-array of integers.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.overall_constraint_length","title":"<code>overall_constraint_length</code>  <code>property</code>","text":"<p>The overall constraint length $\\nu$ of the code.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.memory_order","title":"<code>memory_order</code>  <code>property</code>","text":"<p>The memory order $\\mu$ of the code.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.feedforward_polynomials","title":"<code>feedforward_polynomials</code>  <code>property</code>","text":"<p>The matrix of feedforward polynomials $P(D)$ of the code. This is a $k \\times n$ array of binary polynomials.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.feedback_polynomials","title":"<code>feedback_polynomials</code>  <code>property</code>","text":"<p>The vector of feedback polynomials $q(D)$ of the code. This is a $k$-array of binary polynomials.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.transfer_function_matrix","title":"<code>transfer_function_matrix</code>  <code>property</code>","text":"<p>The transfer function matrix $G(D)$ of the code. This is a $k \\times n$ array of binary polynomial fractions.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.finite_state_machine","title":"<code>finite_state_machine</code>  <code>property</code>","text":"<p>The finite-state machine of the code.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.state_matrix","title":"<code>state_matrix</code>  <code>property</code>","text":"<p>The state matrix $A$ of the state-space representation. This is a $\\nu \\times \\nu$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.control_matrix","title":"<code>control_matrix</code>  <code>property</code>","text":"<p>The control matrix $B$ of the state-space representation. This is a $k \\times \\nu$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.observation_matrix","title":"<code>observation_matrix</code>  <code>property</code>","text":"<p>The observation matrix $C$ of the state-space representation. This is a $\\nu \\times n$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalCode/#komm._error_control_convolutional.ConvolutionalCode.ConvolutionalCode.transition_matrix","title":"<code>transition_matrix</code>  <code>property</code>","text":"<p>The transition matrix $D$ of the state-space representation. This is a $k \\times n$ array of integers in $\\{ 0, 1 \\}$.</p>"},{"location":"ref/ConvolutionalStreamDecoder/","title":"komm.ConvolutionalStreamDecoder","text":"<p>Convolutional stream decoder using Viterbi algorithm. Decode a (hard or soft) bit stream given a convolutional code, assuming a traceback length (path memory) of $\\tau$. At time $t$, the decoder chooses the path survivor with best metric at time $t - \\tau$ and outputs the corresponding information bits. The output stream has a delay equal to $k \\tau$, where $k$ is the number of input bits of the convolutional code. As a rule of thumb, the traceback length is chosen as $\\tau = 5\\mu$, where $\\mu$ is the memory order of the convolutional code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0o7, 0o5]])\n&gt;&gt;&gt; convolutional_decoder = komm.ConvolutionalStreamDecoder(convolutional_code, traceback_length=10)\n&gt;&gt;&gt; convolutional_decoder([1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1])\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n&gt;&gt;&gt; convolutional_decoder(np.zeros(2*10, dtype=int))\narray([1, 0, 1, 1, 1, 0, 1, 1, 0, 0])\n</code></pre>"},{"location":"ref/ConvolutionalStreamDecoder/#__init__","title":"<code>__init__(convolutional_code, traceback_length, initial_state=0, input_type='hard')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>convolutional_code</code> (<code>ConvolutionalCode</code>)         \u2013          <p>The convolutional code.</p> </li> <li> <code>traceback_length</code> (<code>int</code>)         \u2013          <p>The traceback length (path memory) $\\tau$ of the decoder.</p> </li> <li> <code>initial_state</code> (<code>Optional[int]</code>)         \u2013          <p>Initial state of the encoder. The default value is <code>0</code>.</p> </li> </ul>"},{"location":"ref/ConvolutionalStreamEncoder/","title":"komm.ConvolutionalStreamEncoder","text":"<p>Convolutional stream encoder. Encode a bit stream using a given convolutional code. The internal state of the encoder is maintained across each call.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0o7, 0o5]])\n&gt;&gt;&gt; convolutional_encoder = komm.ConvolutionalStreamEncoder(convolutional_code)\n&gt;&gt;&gt; convolutional_encoder([1, 1, 1, 1])\narray([1, 1, 0, 1, 1, 0, 1, 0])\n&gt;&gt;&gt; convolutional_encoder([1, 1, 1, 1])\narray([1, 0, 1, 0, 1, 0, 1, 0])\n</code></pre>"},{"location":"ref/ConvolutionalStreamEncoder/#__init__","title":"<code>__init__(convolutional_code, initial_state=0)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>convolutional_code</code> (<code>ConvolutionalCode</code>)         \u2013          <p>The convolutional code.</p> </li> <li> <code>initial_state</code> (<code>Optional[int]</code>)         \u2013          <p>Initial state of the encoder. The default value is <code>0</code>.</p> </li> </ul>"},{"location":"ref/CordaroWagnerCode/","title":"komm.CordaroWagnerCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Cordaro\u2013Wagner code. It is the $(n, 2)$ linear block code which is optimum for the BSC with sufficiently small crossover probability. For more details, see CW67.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.CordaroWagnerCode(11)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(11, 2, 7)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n       [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.codeword_weight_distribution\narray([1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0])\n&gt;&gt;&gt; code.coset_leader_weight_distribution\narray([  1,  11,  55, 165, 226,  54,   0,   0,   0,   0,   0,   0])\n</code></pre>"},{"location":"ref/CordaroWagnerCode/#__init__","title":"<code>__init__(n)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>n</code> (<code>int</code>)         \u2013          <p>The length $n$ of the code. Must satisfy $n \\geq 2$.</p> </li> </ul>"},{"location":"ref/CyclicCode/","title":"komm.CyclicCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>General binary cyclic code. A cyclic code is a linear block code such that, if $c$ is a codeword, then every cyclic shift of $c$ is also a codeword. It is characterized by its generator polynomial $g(X)$, of degree $m$ (the redundancy of the code), and by its parity-check polynomial $h(X)$, of degree $k$ (the dimension of the code). Those polynomials are related by $g(X) h(X) = X^n + 1$, where $n = k + m$ is the length of the code.</p> <p>Examples of generator polynomials can be found in the table below.</p> Code $(n, k, d)$ Generator polynomial $g(X)$ Integer representation Hamming $(7,4,3)$ $X^3 + X + 1$ <code>0b1011 = 0o13 = 11</code> Simplex $(7,3,4)$ $X^4 + X^2 + X +   1$ <code>0b10111 = 0o27 = 23</code> BCH $(15,5,7)$ $X^{10} + X^8 + X^5 + X^4 + X^2 + X + 1$ <code>0b10100110111 = 0o2467 = 1335</code> Golay $(23,12,7)$ $X^{11} + X^9 + X^7 + X^6 + X^5 + X + 1$ <code>0b101011100011 = 0o5343 = 2787</code> <p>For more details, see LC04, Ch. 5.</p>"},{"location":"ref/CyclicCode/#__init__","title":"<code>__init__(length, systematic=True, **kwargs)</code>","text":"<p>Constructor for the class. It expects one of the following formats:</p> <p>Via generator polynomial</p> <p><code>komm.CyclicCode(length, generator_polynomial=generator_polynomial, systematic=True)</code></p> <p>Parameters:</p> <ul> <li> <code>generator_polynomial</code> (<code>BinaryPolynomial | int</code>)         \u2013          <p>The generator polynomial $g(X)$ of the code, of degree $m$ (the redundancy of the code), specified either as a binary polynomial or as an integer to be converted to the former.</p> </li> </ul> <p>Via parity-check polynomial</p> <p><code>komm.CyclicCode(length, parity_check_polynomial=parity_check_polynomial, systematic=True)</code></p> <p>Parameters:</p> <ul> <li> <code>parity_check_polynomial</code> (<code>BinaryPolynomial | int</code>)         \u2013          <p>The parity-check polynomial $h(X)$ of the code, of degree $k$ (the dimension of the code), specified either as a binary polynomial or as an integer to be converted to the former.</p> </li> </ul> <p>The following parameters are common to both formats:</p> <p>Parameters:</p> <ul> <li> <code>length</code> (<code>int</code>)         \u2013          <p>The length $n$ of the code.</p> </li> <li> <code>systematic</code> (<code>Optional[bool]</code>)         \u2013          <p>Whether the encoder is systematic. Default is <code>True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.CyclicCode(length=23, generator_polynomial=0b101011100011)  # Golay (23, 12)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(23, 12, 7)\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.CyclicCode(length=23, parity_check_polynomial=0b1010010011111)  # Golay (23, 12)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(23, 12, 7)\n</code></pre>"},{"location":"ref/CyclicCode/#komm._error_control_block.CyclicCode.CyclicCode.generator_polynomial","title":"<code>generator_polynomial</code>  <code>property</code>","text":"<p>The generator polynomial $g(X)$ of the cyclic code. It is a binary polynomial of degree $m$, where $m$ is the redundancy of the code.</p>"},{"location":"ref/CyclicCode/#komm._error_control_block.CyclicCode.CyclicCode.parity_check_polynomial","title":"<code>parity_check_polynomial</code>  <code>property</code>","text":"<p>The parity-check polynomial $h(X)$ of the cyclic code. It is a binary polynomial of degree $k$, where $k$ is the dimension of the code.</p>"},{"location":"ref/CyclicCode/#komm._error_control_block.CyclicCode.CyclicCode.meggitt_table","title":"<code>meggitt_table</code>  <code>cached</code> <code>property</code>","text":"<p>The Meggitt table for the cyclic code. It is a dictionary where the keys are syndromes and the values are error patterns. See XiD03, Sec. 3.4.</p>"},{"location":"ref/DiscreteMemorylessChannel/","title":"komm.DiscreteMemorylessChannel","text":"<p>Discrete memoryless channel (DMC). It is defined by an input alphabet $\\mathcal{X}$, an output alphabet $\\mathcal{Y}$, and a transition probability matrix $p_{Y \\mid X}$. Here, for simplicity, the input and output alphabets are always taken as $\\mathcal{X} = \\{ 0, 1, \\ldots, |\\mathcal{X}| - 1 \\}$ and $\\mathcal{Y} = \\{ 0, 1, \\ldots, |\\mathcal{Y}| - 1 \\}$, respectively. The transition probability matrix $p_{Y \\mid X}$, of size $|\\mathcal{X}|$-by-$|\\mathcal{Y}|$, gives the conditional probability of receiving $Y = y$ given that $X = x$ is transmitted. For more details, see CT06, Ch. 7.</p> <p>To invoke the channel, call the object giving the input signal as parameter (see example in the constructor below).</p>"},{"location":"ref/DiscreteMemorylessChannel/#__init__","title":"<code>__init__(transition_matrix)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>transition_matrix</code> (<code>Array2D[float]</code>)         \u2013          <p>The channel transition probability matrix $p_{Y \\mid X}$. The element in row $x \\in \\mathcal{X}$ and column $y \\in \\mathcal{Y}$ must be equal to $p_{Y \\mid X}(y \\mid x)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dmc = komm.DiscreteMemorylessChannel([[0.9, 0.05, 0.05], [0.0, 0.5, 0.5]])\n&gt;&gt;&gt; x = [0, 1, 0, 1, 1, 1, 0, 0, 0, 1]\n&gt;&gt;&gt; y = dmc(x); y\narray([0, 2, 0, 2, 1, 1, 0, 0, 0, 2])\n</code></pre>"},{"location":"ref/DiscreteMemorylessChannel/#komm._channels.DiscreteMemorylessChannel.DiscreteMemorylessChannel.transition_matrix","title":"<code>transition_matrix</code>  <code>property</code> <code>writable</code>","text":"<p>The channel transition probability matrix $p_{Y \\mid X}$.</p>"},{"location":"ref/DiscreteMemorylessChannel/#komm._channels.DiscreteMemorylessChannel.DiscreteMemorylessChannel.input_cardinality","title":"<code>input_cardinality</code>  <code>property</code>","text":"<p>The channel input cardinality $|\\mathcal{X}|$.</p>"},{"location":"ref/DiscreteMemorylessChannel/#komm._channels.DiscreteMemorylessChannel.DiscreteMemorylessChannel.output_cardinality","title":"<code>output_cardinality</code>  <code>property</code>","text":"<p>The channel output cardinality $|\\mathcal{Y}|$.</p>"},{"location":"ref/DiscreteMemorylessChannel/#mutual_information","title":"<code>mutual_information(input_pmf, base=2.0)</code>","text":"<p>Computes the mutual information $\\mathrm{I}(X ; Y)$ between the input $X$ and the output $Y$ of the channel. It is given by $$     \\mathrm{I}(X ; Y) = \\mathrm{H}(X) - \\mathrm{H}(X \\mid Y), $$ where $\\mathrm{H}(X)$ is the the entropy of $X$ and $\\mathrm{H}(X \\mid Y)$ is the conditional entropy of $X$ given $Y$. By default, the base of the logarithm is $2$, in which case the mutual information is measured in bits. See CT06, Ch. 2.</p> <p>Parameters:</p> <ul> <li> <code>input_pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The probability mass function $p_X$ of the channel input $X$. It must be a valid pmf, that is, all of its values must be non-negative and sum up to $1$.</p> </li> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>The base of the logarithm to be used. It must be a positive float or the string <code>'e'</code>. The default value is <code>2.0</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mutual_information</code>  (<code>float</code>)          \u2013          <p>The mutual information $\\mathrm{I}(X ; Y)$ between the input $X$ and the output $Y$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dmc = komm.DiscreteMemorylessChannel([[0.6, 0.3, 0.1], [0.7, 0.1, 0.2], [0.5, 0.05, 0.45]])\n&gt;&gt;&gt; dmc.mutual_information([1/3, 1/3, 1/3])\n0.12381109879798724\n&gt;&gt;&gt; dmc.mutual_information([1/3, 1/3, 1/3], base=3)\n0.07811610605402552\n</code></pre>"},{"location":"ref/DiscreteMemorylessChannel/#capacity","title":"<code>capacity(base=2.0)</code>","text":"<p>Returns the channel capacity $C$. It is given by $C = \\max_{p_X} \\mathrm{I}(X;Y)$. This method computes the channel capacity via the Arimoto\u2013Blahut algorithm. See CT06, Sec. 10.8.</p> <p>Parameters:</p> <ul> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>The base of the logarithm to be used. It must be a positive float or the string <code>'e'</code>. The default value is <code>2.0</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>capacity</code>  (<code>float</code>)          \u2013          <p>The channel capacity $C$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dmc = komm.DiscreteMemorylessChannel([[0.6, 0.3, 0.1], [0.7, 0.1, 0.2], [0.5, 0.05, 0.45]])\n&gt;&gt;&gt; dmc.capacity()\n0.1616318609548566\n&gt;&gt;&gt; dmc.capacity(base=3)\n0.10197835020154389\n</code></pre>"},{"location":"ref/DiscreteMemorylessSource/","title":"komm.DiscreteMemorylessSource","text":"<p>Discrete memoryless source (DMS). It is defined by an alphabet $\\mathcal{X}$ and a probability mass function (pmf) $p_X$. Here, for simplicity, the alphabet is always taken as $\\mathcal{X} = \\{ 0, 1, \\ldots, |\\mathcal{X}| - 1 \\}$. The pmf $p_X$ gives the probability of the source emitting the symbol $X = x$.</p> <p>To invoke the source, call the object giving the number of symbols to be emitted as parameter (see example in the constructor below).</p>"},{"location":"ref/DiscreteMemorylessSource/#__init__","title":"<code>__init__(pmf)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The source probability mass function $p_X$. The element in position $x \\in \\mathcal{X}$ must be equal to $p_X(x)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dms = komm.DiscreteMemorylessSource([0.5, 0.4, 0.1])\n&gt;&gt;&gt; dms(10)\narray([1, 2, 1, 0, 0, 1, 1, 0, 1, 1])\n</code></pre>"},{"location":"ref/DiscreteMemorylessSource/#komm._sources.DiscreteMemorylessSource.DiscreteMemorylessSource.pmf","title":"<code>pmf</code>  <code>property</code> <code>writable</code>","text":"<p>The source probability mass function $p_X$.</p>"},{"location":"ref/DiscreteMemorylessSource/#komm._sources.DiscreteMemorylessSource.DiscreteMemorylessSource.cardinality","title":"<code>cardinality</code>  <code>property</code>","text":"<p>The cardinality $|\\mathcal{X}|$ of the source alphabet.</p>"},{"location":"ref/DiscreteMemorylessSource/#entropy","title":"<code>entropy(base=2.0)</code>","text":"<p>Returns the source entropy $\\mathrm{H}(X)$.</p> <p>Parameters:</p> <ul> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>The base of the logarithm to be used. It must be a positive float or the string <code>'e'</code>. The default value is <code>2.0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dms = komm.DiscreteMemorylessSource([1/2, 1/4, 1/8, 1/8])\n&gt;&gt;&gt; dms.entropy()\n1.75\n&gt;&gt;&gt; dms.entropy(base=4)\n0.875\n</code></pre>"},{"location":"ref/FiniteBifield/","title":"komm.FiniteBifield","text":"<p>Finite field with binary characteristic. Objects of this class represent a finite field $\\mathrm{GF}(2^k)$ (also known as Galois field), with characteristic $2$ and degree $k$.</p> <p>To construct elements of the finite field, call the finite field object. For example, <code>field(0b1101)</code> will construct the element whose polynomial representation is $X^3 + X^2 + 1$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = komm.FiniteBifield(4)\n&gt;&gt;&gt; x = field(0b1011)\n&gt;&gt;&gt; y = field(0b1100)\n&gt;&gt;&gt; x + y\n0b111\n&gt;&gt;&gt; x * y\n0b1101\n&gt;&gt;&gt; x / y\n0b10\n</code></pre>"},{"location":"ref/FiniteBifield/#__init__","title":"<code>__init__(degree, modulus=None)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>degree</code> (<code>int</code>)         \u2013          <p>Degree $k$ of the finite field. Must be a positive integer.</p> </li> <li> <code>modulus</code> (<code>Optional[BinaryPolynomial | int]</code>)         \u2013          <p>Modulus (primitive polynomial) $p(X)$ of the field, specified either as a binary polynomial or as an integer to be converted to the former. Must be an irreducible polynomial. If not specified, the modulus is chosen from the table below LC04, p.42.</p> Degree $k$ Modulus $p(X)$ Degree $k$ Modulus $p(X)$ $1$ <code>0b11</code> $9$ <code>0b1000010001</code> $2$ <code>0b111</code> $10$ <code>0b10000001001</code> $3$ <code>0b1011</code> $11$ <code>0b100000000101</code> $4$ <code>0b10011</code> $12$ <code>0b1000001010011</code> $5$ <code>0b100101</code> $13$ <code>0b10000000011011</code> $6$ <code>0b1000011</code> $14$ <code>0b100010001000011</code> $7$ <code>0b10001001</code> $15$ <code>0b1000000000000011</code> $8$ <code>0b100011101</code> $16$ <code>0b10001000000001011</code> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = komm.FiniteBifield(4)\n&gt;&gt;&gt; field\nFiniteBifield(4)\n&gt;&gt;&gt; (field.characteristic, field.degree, field.order)\n(2, 4, 16)\n&gt;&gt;&gt; field.modulus\nBinaryPolynomial(0b10011)\n</code></pre> <pre><code>&gt;&gt;&gt; field = komm.FiniteBifield(4, modulus=0b11001)\n&gt;&gt;&gt; field\nFiniteBifield(4, modulus=0b11001)\n&gt;&gt;&gt; (field.characteristic, field.degree, field.order)\n(2, 4, 16)\n&gt;&gt;&gt; field.modulus\nBinaryPolynomial(0b11001)\n</code></pre>"},{"location":"ref/FiniteBifield/#komm._algebra.FiniteBifield.FiniteBifield.characteristic","title":"<code>characteristic</code>  <code>property</code>","text":"<p>The characteristic $2$ of the finite field.</p>"},{"location":"ref/FiniteBifield/#komm._algebra.FiniteBifield.FiniteBifield.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>The degree $k$ of the finite field.</p>"},{"location":"ref/FiniteBifield/#komm._algebra.FiniteBifield.FiniteBifield.modulus","title":"<code>modulus</code>  <code>property</code>","text":"<p>The modulus (primitive polynomial) $p(X)$ of the finite field.</p>"},{"location":"ref/FiniteBifield/#komm._algebra.FiniteBifield.FiniteBifield.order","title":"<code>order</code>  <code>property</code>","text":"<p>The order (number of elements) of the finite field. It is given by $2^k$.</p>"},{"location":"ref/FiniteBifield/#komm._algebra.FiniteBifield.FiniteBifield.primitive_element","title":"<code>primitive_element</code>  <code>property</code>","text":"<p>A primitive element $\\alpha$ of the finite field. It satisfies $p(\\alpha) = 0$, where $p(X)$ is the modulus (primitive polynomial) of the finite field.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field1 = komm.FiniteBifield(3, modulus=0b1011)\n&gt;&gt;&gt; alpha1 = field1.primitive_element\n&gt;&gt;&gt; [alpha1**i for i in range(7)]\n[0b1, 0b10, 0b100, 0b11, 0b110, 0b111, 0b101]\n&gt;&gt;&gt; field2 = komm.FiniteBifield(3, modulus=0b1101)\n&gt;&gt;&gt; alpha2 = field2.primitive_element\n&gt;&gt;&gt; [alpha2**i for i in range(7)]\n[0b1, 0b10, 0b100, 0b101, 0b111, 0b11, 0b110]\n</code></pre>"},{"location":"ref/FiniteBifield/#inverse","title":"<code>inverse(x)</code>","text":"<p>Returns the multiplicative inverse of a given element.</p>"},{"location":"ref/FiniteBifield/#logarithm","title":"<code>logarithm(x, base=None)</code>","text":"<p>Returns the logarithm of a given element, with respect to a given base. If no base is given, the primitive element is used as the base.</p>"},{"location":"ref/FiniteBifield/#power","title":"<code>power(x, exponent)</code>","text":"<p>Returns a given power of a given element.</p>"},{"location":"ref/FiniteBifield/#conjugates","title":"<code>conjugates(x)</code>  <code>staticmethod</code>","text":"<p>Returns the conjugates of a given element. See LC04, Sec. 2.5.</p>"},{"location":"ref/FiniteBifield/#minimal_polynomial","title":"<code>minimal_polynomial(x)</code>  <code>staticmethod</code>","text":"<p>Returns the minimal polynomial of a given element. See LC04, Sec. 2.5.</p>"},{"location":"ref/FiniteBifield/#__call__","title":"<code>__call__(value)</code>","text":"<p>Constructs elements of the finite field.</p>"},{"location":"ref/FiniteStateMachine/","title":"komm.FiniteStateMachine","text":"<p>Finite-state machine (Mealy machine). It is defined by a set of states $\\mathcal{S}$, an input alphabet $\\mathcal{X}$, an output alphabet $\\mathcal{Y}$, and a transition function $T : \\mathcal{S} \\times \\mathcal{X} \\to \\mathcal{S} \\times \\mathcal{Y}$. Here, for simplicity, the set of states, the input alphabet, and the output alphabet are always taken as $\\mathcal{S} = \\{ 0, 1, \\ldots, |\\mathcal{S}| - 1 \\}$, $\\mathcal{X} = \\{ 0, 1, \\ldots, |\\mathcal{X}| - 1 \\}$, and $\\mathcal{Y} = \\{ 0, 1, \\ldots, |\\mathcal{Y}| - 1 \\}$, respectively.</p> <p>For example, consider the finite-state machine whose state diagram depicted in the figure below.</p> <p></p> <p>It has set of states $\\mathcal{S} = \\{ 0, 1, 2, 3 \\}$, input alphabet $\\mathcal{X} = \\{ 0, 1 \\}$, output alphabet $\\mathcal{Y} = \\{ 0, 1, 2, 3 \\}$, and transition function $T$ given by the table below.</p> State Input Next state Output $0$ $0$ $0$ $0$ $0$ $1$ $1$ $3$ $1$ $0$ $2$ $1$ $1$ $1$ $3$ $2$ $2$ $0$ $0$ $3$ $2$ $1$ $1$ $0$ $3$ $0$ $2$ $2$ $3$ $1$ $3$ $1$"},{"location":"ref/FiniteStateMachine/#__init__","title":"<code>__init__(next_states, outputs)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>next_states</code> (<code>Array2D[int]</code>)         \u2013          <p>The matrix of next states of the machine, of shape $|\\mathcal{S}| \\times |\\mathcal{X}|$. The element in row $s$ and column $x$ should be the next state of the machine (an element in $\\mathcal{S}$), given that the current state is $s \\in \\mathcal{S}$ and the input is $x \\in \\mathcal{X}$.</p> </li> <li> <code>outputs</code> (<code>Array2D[int]</code>)         \u2013          <p>The matrix of outputs of the machine, of shape $|\\mathcal{S}| \\times |\\mathcal{X}|$. The element in row $s$ and column $x$ should be the output of the machine (an element in $\\mathcal{Y}$), given that the current state is $s \\in \\mathcal{S}$ and the input is $x \\in \\mathcal{X}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n</code></pre>"},{"location":"ref/FiniteStateMachine/#komm._finite_state_machine.FiniteStateMachine.FiniteStateMachine.num_states","title":"<code>num_states</code>  <code>property</code>","text":"<p>The number of states of the machine.</p>"},{"location":"ref/FiniteStateMachine/#komm._finite_state_machine.FiniteStateMachine.FiniteStateMachine.num_input_symbols","title":"<code>num_input_symbols</code>  <code>property</code>","text":"<p>The size (cardinality) of the input alphabet $\\mathcal{X}$.</p>"},{"location":"ref/FiniteStateMachine/#komm._finite_state_machine.FiniteStateMachine.FiniteStateMachine.num_output_symbols","title":"<code>num_output_symbols</code>  <code>property</code>","text":"<p>The size (cardinality) of the output alphabet $\\mathcal{Y}$.</p>"},{"location":"ref/FiniteStateMachine/#komm._finite_state_machine.FiniteStateMachine.FiniteStateMachine.next_states","title":"<code>next_states</code>  <code>property</code>","text":"<p>The matrix of next states of the machine. It has shape $|\\mathcal{S}| \\times |\\mathcal{X}|$. The element in row $s$ and column $x$ is the next state of the machine (an element in $\\mathcal{S}$), given that the current state is $s \\in \\mathcal{S}$ and the input is $x \\in \\mathcal{X}$.</p>"},{"location":"ref/FiniteStateMachine/#komm._finite_state_machine.FiniteStateMachine.FiniteStateMachine.outputs","title":"<code>outputs</code>  <code>property</code>","text":"<p>The matrix of outputs of the machine. It has shape $|\\mathcal{S}| \\times |\\mathcal{X}|$. The element in row $s$ and column $x$ is the output of the machine (an element in $\\mathcal{Y}$), given that the current state is $s \\in \\mathcal{S}$ and the input is $x \\in \\mathcal{X}$.</p>"},{"location":"ref/FiniteStateMachine/#komm._finite_state_machine.FiniteStateMachine.FiniteStateMachine.input_edges","title":"<code>input_edges</code>  <code>property</code>","text":"<p>The matrix of input edges of the machine. It has shape $|\\mathcal{S}| \\times |\\mathcal{S}|$. If there is an edge from $s_0 \\in \\mathcal{S}$ to $s_1 \\in \\mathcal{S}$, then the element in row $s_0$ and column $s_1$ is the input associated with that edge (an element of $\\mathcal{X}$); if there is no such edge, then the element is $-1$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n&gt;&gt;&gt; fsm.input_edges\narray([[ 0,  1, -1, -1],\n       [-1, -1,  0,  1],\n       [ 0,  1, -1, -1],\n       [-1, -1,  0,  1]])\n</code></pre>"},{"location":"ref/FiniteStateMachine/#komm._finite_state_machine.FiniteStateMachine.FiniteStateMachine.output_edges","title":"<code>output_edges</code>  <code>property</code>","text":"<p>The matrix of output edges of the machine. It has shape $|\\mathcal{S}| \\times |\\mathcal{S}|$. If there is an edge from $s_0 \\in \\mathcal{S}$ to $s_1 \\in \\mathcal{S}$, then the element in row $s_0$ and column $s_1$ is the output associated with that edge (an element of $\\mathcal{Y}$); if there is no such edge, then the element is $-1$.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n&gt;&gt;&gt; fsm.output_edges\narray([[ 0,  3, -1, -1],\n       [-1, -1,  1,  2],\n       [ 3,  0, -1, -1],\n       [-1, -1,  2,  1]])\n</code></pre>"},{"location":"ref/FiniteStateMachine/#process","title":"<code>process(input_sequence, initial_state)</code>","text":"<p>Returns the output sequence corresponding to a given input sequence. It assumes the machine starts at a given initial state $s_\\mathrm{i}$. The input sequence and the output sequence are denoted by $\\mathbf{x} = (x_0, x_1, \\ldots, x_{L-1}) \\in \\mathcal{X}^L$ and $\\mathbf{y} = (y_0, y_1, \\ldots, y_{L-1}) \\in \\mathcal{Y}^L$, respectively.</p> <p>Parameters:</p> <ul> <li> <code>input_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The input sequence $\\mathbf{x} \\in \\mathcal{X}^L$. It should be a 1D-array with elements in $\\mathcal{X}$.</p> </li> <li> <code>initial_state</code> (<code>int</code>)         \u2013          <p>The initial state $s_\\mathrm{i}$ of the machine. Should be an integer in $\\mathcal{S}$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>output_sequence</code>  (<code>Array1D[int]</code>)          \u2013          <p>The output sequence $\\mathbf{y} \\in \\mathcal{Y}^L$ corresponding to <code>input_sequence</code>, assuming the machine starts at the state given by <code>initial_state</code>. It is a 1D-array with elements in $\\mathcal{Y}$.</p> </li> <li> <code>final_state</code>  (<code>int</code>)          \u2013          <p>The final state $s_\\mathrm{f}$ of the machine. It is an integer in $\\mathcal{S}$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fsm = komm.FiniteStateMachine(next_states=[[0,1], [2,3], [0,1], [2,3]], outputs=[[0,3], [1,2], [3,0], [2,1]])\n&gt;&gt;&gt; input_sequence, initial_state = [1, 1, 0, 1, 0], 0\n&gt;&gt;&gt; output_sequence, final_state = fsm.process(input_sequence, initial_state)\n&gt;&gt;&gt; output_sequence\narray([3, 2, 2, 0, 1])\n&gt;&gt;&gt; final_state\n2\n</code></pre>"},{"location":"ref/FiniteStateMachine/#viterbi","title":"<code>viterbi(observed_sequence, metric_function, initial_metrics=None)</code>","text":"<p>Applies the Viterbi algorithm on a given observed sequence. The Viterbi algorithm finds the most probable input sequence $\\hat{\\mathbf{x}}(s) \\in \\mathcal{X}^L$ ending in state $s$, for all $s \\in \\mathcal{S}$, given an observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$. It is assumed uniform input priors. See LC04, Sec. 12.1.</p> <p>Parameters:</p> <ul> <li> <code>observed_sequence</code> (<code>Array1D</code>)         \u2013          <p>The observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$.</p> </li> <li> <code>metric_function</code> (<code>function</code>)         \u2013          <p>The metric function $\\mathcal{Y} \\times \\mathcal{Z} \\to \\mathbb{R}$.</p> </li> <li> <code>initial_metrics</code> (<code>Optional[Array1D[float]]</code>)         \u2013          <p>The initial metrics for each state. It must be a 1D-array of length $|\\mathcal{S}|$. The default value is <code>0.0</code> for all states.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>input_sequences_hat</code>  (<code>Array2D[int]</code>)          \u2013          <p>The most probable input sequence $\\hat{\\mathbf{x}}(s) \\in \\mathcal{X}^L$ ending in state $s$, for all $s \\in \\mathcal{S}$. It is a 2D-array of shape $L \\times |\\mathcal{S}|$, in which column $s$ is equal to $\\hat{\\mathbf{x}}(s)$.</p> </li> <li> <code>final_metrics</code>  (<code>Array1D[float]</code>)          \u2013          <p>The final metrics for each state. It is a 1D-array of length $|\\mathcal{S}|$.</p> </li> </ul>"},{"location":"ref/FiniteStateMachine/#viterbi_streaming","title":"<code>viterbi_streaming(observed_sequence, metric_function, memory)</code>","text":"<p>Applies the streaming version of the Viterbi algorithm on a given observed sequence. The path memory (or traceback length) is denoted by $\\tau$. It chooses the survivor with best metric and selects the information block on this path. See LC04, Sec. 12.3.</p> <p>Parameters:</p> <ul> <li> <code>observed_sequence</code> (<code>Array1D</code>)         \u2013          <p>The observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$.</p> </li> <li> <code>metric_function</code> (<code>function</code>)         \u2013          <p>The metric function $\\mathcal{Y} \\times \\mathcal{Z} \\to \\mathbb{R}$.</p> </li> <li> <code>memory</code> (<code>dict</code>)         \u2013          <p>The metrics for each state. It must be a dictionary containing two keys: <code>'paths'</code>, a 2D-array of integers of shape $|\\mathcal{S}| \\times (\\tau + 1)$; and <code>'metrics'</code>, a 2D-array of floats of shape $|\\mathcal{S}| \\times (\\tau + 1)$. This dictionary is updated in-place by this method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>input_sequence_hat</code>  (<code>Array1D[int]</code>)          \u2013          <p>The most probable input sequence $\\hat{\\mathbf{x}} \\in \\mathcal{X}^L$</p> </li> </ul>"},{"location":"ref/FiniteStateMachine/#forward_backward","title":"<code>forward_backward(observed_sequence, metric_function, input_priors=None, initial_state_distribution=None, final_state_distribution=None)</code>","text":"<p>Applies the forward-backward algorithm on a given observed sequence. The forward-backward algorithm computes the posterior pmf of each input $x_0, x_1, \\ldots, x_{L-1} \\in \\mathcal{X}$ given an observed sequence $\\mathbf{z} = (z_0, z_1, \\ldots, z_{L-1}) \\in \\mathcal{Z}^L$. The prior pmf of each input may also be provided. See LC04, 12.6.</p> <p>Parameters:</p> <ul> <li> <code>observed_sequence</code> (<code>Array1D</code>)         \u2013          <p>The observed sequence $\\mathbf{z} \\in \\mathcal{Z}^L$.</p> </li> <li> <code>metric_function</code> (<code>function</code>)         \u2013          <p>The metric function $\\mathcal{Y} \\times \\mathcal{Z} \\to \\mathbb{R}$.</p> </li> <li> <code>input_priors</code> (<code>Optional[Array2D[float]]</code>)         \u2013          <p>The prior pmf of each input, of shape $L \\times |\\mathcal{X}|$. The element in row $t \\in [0 : L)$ and column $x \\in \\mathcal{X}$ should be $p(x_t = x)$. The default value yields uniform priors.</p> </li> <li> <code>initial_state_distribution</code> (<code>Optional[Array1D[float]]</code>)         \u2013          <p>The pmf of the initial state of the machine. It must be a 1D-array of length $|\\mathcal{S}|$. The default value is uniform over all states.</p> </li> <li> <code>final_state_distribution</code> (<code>Optional[Array1D[float]]</code>)         \u2013          <p>The pmf of the final state of the machine. It must be a 1D-array of length $|\\mathcal{S}|$. The default value is uniform over all states.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>input_posteriors</code>  (<code>Array2D[float]</code>)          \u2013          <p>The posterior pmf of each input, given the observed sequence, of shape $L \\times |\\mathcal{X}|$. The element in row $t \\in [0 : L)$ and column $x \\in \\mathcal{X}$ is $p(x_t = x \\mid \\mathbf{z})$.</p> </li> </ul>"},{"location":"ref/FixedToVariableCode/","title":"komm.FixedToVariableCode","text":"<p>Binary, prefix-free, fixed-to-variable length code. Let $\\mathcal{X} = \\{0, 1, \\ldots, |\\mathcal{X} - 1| \\}$ be the alphabet of some discrete source. A binary fixed-to-variable length code of source block size $k$ is defined by an encoding mapping $\\Enc : \\mathcal{X}^k \\to \\{ 0, 1 \\}^+$, where $\\{ 0, 1 \\}^+$ denotes the set of all finite-length, non-empty binary strings. The elements in the image of $\\Enc$ are called codewords.</p> Warning <p>Only prefix-free codes are considered, in which no codeword is a prefix of any other codeword.</p>"},{"location":"ref/FixedToVariableCode/#__init__","title":"<code>__init__(codewords, source_cardinality=None)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>codewords</code> (<code>List[Tuple[int]]</code>)         \u2013          <p>The codewords of the code. Must be a list of length $|\\mathcal{X}|^k$ containing tuples of integers in $\\{ 0, 1 \\}$. The tuple in position $i$ of <code>codewords</code> should be equal to $\\Enc(u)$, where $u$ is the $i$-th element in the lexicographic ordering of $\\mathcal{X}^k$.</p> </li> <li> <code>source_cardinality</code> (<code>Optional[int]</code>)         \u2013          <p>The cardinality $|\\mathcal{X}|$ of the source alphabet. The default value is <code>len(codewords)</code>, yielding a source block size $k = 1$.</p> </li> </ul> Note <p>The source block size $k$ is inferred from <code>codewords</code> and <code>source_cardinality</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode(codewords=[(0,), (1,0), (1,1)])\n&gt;&gt;&gt; (code.source_cardinality, code.source_block_size)\n(3, 1)\n&gt;&gt;&gt; pprint(code.enc_mapping)\n{(0,): (0,), (1,): (1, 0), (2,): (1, 1)}\n&gt;&gt;&gt; pprint(code.dec_mapping)\n{(0,): (0,), (1, 0): (1,), (1, 1): (2,)}\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode(codewords=[(0,), (1,0,0), (1,1), (1,0,1)], source_cardinality=2)\n&gt;&gt;&gt; (code.source_cardinality, code.source_block_size)\n(2, 2)\n&gt;&gt;&gt; pprint(code.enc_mapping)\n{(0, 0): (0,), (0, 1): (1, 0, 0), (1, 0): (1, 1), (1, 1): (1, 0, 1)}\n&gt;&gt;&gt; pprint(code.dec_mapping)\n{(0,): (0, 0), (1, 0, 0): (0, 1), (1, 0, 1): (1, 1), (1, 1): (1, 0)}\n</code></pre>"},{"location":"ref/FixedToVariableCode/#komm._source_coding.FixedToVariableCode.FixedToVariableCode.source_cardinality","title":"<code>source_cardinality</code>  <code>property</code>","text":"<p>The cardinality $|\\mathcal{X}|$ of the source alphabet.</p>"},{"location":"ref/FixedToVariableCode/#komm._source_coding.FixedToVariableCode.FixedToVariableCode.source_block_size","title":"<code>source_block_size</code>  <code>property</code>","text":"<p>The source block size $k$.</p>"},{"location":"ref/FixedToVariableCode/#komm._source_coding.FixedToVariableCode.FixedToVariableCode.enc_mapping","title":"<code>enc_mapping</code>  <code>property</code>","text":"<p>The encoding mapping $\\Enc$ of the code.</p>"},{"location":"ref/FixedToVariableCode/#komm._source_coding.FixedToVariableCode.FixedToVariableCode.dec_mapping","title":"<code>dec_mapping</code>  <code>property</code>","text":"<p>The decoding mapping $\\Dec$ of the code.</p>"},{"location":"ref/FixedToVariableCode/#rate","title":"<code>rate(pmf)</code>","text":"<p>Computes the expected rate $R$ of the code, assuming a given pmf. This quantity is given by $$     R = \\frac{\\bar{n}}{k}, $$ where $\\bar{n}$ is the expected codeword length, assuming iid source symbols drawn from $p_X$, and $k$ is the source block size. It is measured in bits per source symbol.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The (first-order) probability mass function $p_X$ to be assumed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rate</code>  (<code>float</code>)          \u2013          <p>The expected rate $R$ of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode([(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.rate([0.5, 0.25, 0.25])\n1.5\n</code></pre>"},{"location":"ref/FixedToVariableCode/#encode","title":"<code>encode(symbol_sequence)</code>","text":"<p>Encodes a sequence of symbols to its corresponding sequence of bits.</p> <p>Parameters:</p> <ul> <li> <code>symbol_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of symbols to be encoded. Must be a 1D-array with elements in $\\mathcal{X} = \\{0, 1, \\ldots, |\\mathcal{X} - 1| \\}$. Its length must be a multiple of $k$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bit_sequence</code>  (<code>Array1D[int]</code>)          \u2013          <p>The sequence of bits corresponding to <code>symbol_sequence</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode([(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.encode([1, 0, 1, 0, 2, 0])\narray([1, 0, 0, 1, 0, 0, 1, 1, 0])\n</code></pre>"},{"location":"ref/FixedToVariableCode/#decode","title":"<code>decode(bit_sequence)</code>","text":"<p>Decodes a sequence of bits to its corresponding sequence of symbols.</p> <p>Parameters:</p> <ul> <li> <code>bit_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of bits to be decoded. Must be a 1D-array with elements in $\\{ 0, 1 \\}$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>symbol_sequence</code>  (<code>Array1D[int]</code>)          \u2013          <p>The sequence of symbols corresponding to <code>bit_sequence</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.FixedToVariableCode([(0,), (1,0), (1,1)])\n&gt;&gt;&gt; code.decode([1, 0, 0, 1, 0, 0, 1, 1, 0])\narray([1, 0, 1, 0, 2, 0])\n</code></pre>"},{"location":"ref/GaussianPulse/","title":"komm.GaussianPulse","text":"<p>         Bases: <code>FormattingPulse</code></p> <p>Gaussian pulse. It is a formatting pulse with impulse response given by $$     h(t) = \\mathrm{e}^{-\\frac{1}{2} (2 \\pi \\bar{B} t)^2} $$ where the $\\bar{B} = B / \\sqrt{\\ln 2}$, and $B$ is the half-power bandwidth of the filter.</p> <p>The Gaussian pulse is depicted below for $B = 0.5$, and for $B = 1$.</p> <p> </p>"},{"location":"ref/GaussianPulse/#__init__","title":"<code>__init__(half_power_bandwidth, length_in_symbols)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>half_power_bandwidth</code> (<code>float</code>)         \u2013          <p>The half-power bandwidth $B$ of the pulse.</p> </li> <li> <code>length_in_symbols</code> (<code>int</code>)         \u2013          <p>The length (span) of the truncated impulse response, in symbols.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.GaussianPulse(half_power_bandwidth=0.5, length_in_symbols=4)\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.GaussianPulse(half_power_bandwidth=1.0, length_in_symbols=2)\n</code></pre>"},{"location":"ref/GaussianPulse/#komm._pulses.GaussianPulse.GaussianPulse.half_power_bandwidth","title":"<code>half_power_bandwidth</code>  <code>property</code>","text":"<p>The half-power bandwidth $B$ of the pulse.</p>"},{"location":"ref/GaussianPulse/#komm._pulses.GaussianPulse.GaussianPulse.length_in_symbols","title":"<code>length_in_symbols</code>  <code>property</code>","text":"<p>The length (span) of the truncated impulse response.</p>"},{"location":"ref/GolayCode/","title":"komm.GolayCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Binary Golay code. It has the following parameters:</p> <ul> <li>Length: $23$</li> <li>Dimension: $12$</li> <li>Minimum distance: $7$</li> </ul> <p>This class constructs the code in systematic form, with the information set on the left.</p> Notes <ul> <li>The binary Golay code is a perfect code.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.GolayCode()\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(23, 12, 7)\n&gt;&gt;&gt; recvword = np.zeros(23, dtype=int); recvword[[2, 10, 19]] = 1\n&gt;&gt;&gt; code.decode(recvword)  # Golay code can correct up to 3 errors.\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n&gt;&gt;&gt; recvword = np.zeros(23, dtype=int); recvword[[2, 3, 10, 19]] = 1\n&gt;&gt;&gt; code.decode(recvword)  # Golay code cannot correct more than 3 errors.\narray([0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0])\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.GolayCode(extended=True)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(24, 12, 8)\n</code></pre>"},{"location":"ref/GolayCode/#__init__","title":"<code>__init__(extended=False)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>extended</code> (<code>Optional[bool]</code>)         \u2013          <p>If <code>True</code>, constructs the code in extended version. The default value is <code>False</code>.</p> </li> </ul>"},{"location":"ref/GoldSequence/","title":"komm.GoldSequence","text":"<p>         Bases: <code>BinarySequence</code></p> <p>Gold sequence [Not implemented yet].</p>"},{"location":"ref/HammingCode/","title":"komm.HammingCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Hamming code. For a given redundancy $m$, it is the linear block code with parity-check matrix whose columns are all the $2^m - 1$ nonzero binary $m$-tuples. The Hamming code has the following parameters:</p> <ul> <li>Length: $n = 2^m - 1$</li> <li>Redundancy: $m$</li> <li>Dimension: $k = 2^m - m - 1$</li> <li>Minimum distance: $d = 3$</li> </ul> <p>This class constructs the code in systematic form, with the information set on the left.</p> <p>For more details, see LC04, Sec. 4.1.</p> Notes <ul> <li>For $m = 2$ it reduces to the repetition code of length $3$.</li> <li>Its dual is the simplex code.</li> <li>Hamming codes are perfect codes.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.HammingCode(3)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(7, 4, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1, 0],\n       [0, 1, 0, 0, 1, 0, 1],\n       [0, 0, 1, 0, 0, 1, 1],\n       [0, 0, 0, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.parity_check_matrix\narray([[1, 1, 0, 1, 1, 0, 0],\n       [1, 0, 1, 1, 0, 1, 0],\n       [0, 1, 1, 1, 0, 0, 1]])\n&gt;&gt;&gt; code.encode([1, 0, 1, 1])\narray([1, 0, 1, 1, 0, 1, 0])\n&gt;&gt;&gt; code.decode([0, 1, 0, 0, 0, 1, 1])\narray([1, 1, 0, 0])\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.HammingCode(3, extended=True)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(8, 4, 4)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1, 1, 0, 1],\n       [0, 1, 0, 0, 1, 0, 1, 1],\n       [0, 0, 1, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 1, 1, 1, 0]])\n&gt;&gt;&gt; code.parity_check_matrix\narray([[1, 1, 0, 1, 1, 0, 0, 0],\n       [1, 0, 1, 1, 0, 1, 0, 0],\n       [0, 1, 1, 1, 0, 0, 1, 0],\n       [1, 1, 1, 0, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.encode([1, 0, 1, 1])\narray([1, 0, 1, 1, 0, 1, 0, 0])\n&gt;&gt;&gt; code.decode([0, 1, 0, 0, 0, 1, 1, 0])\narray([1, 1, 0, 0])\n</code></pre>"},{"location":"ref/HammingCode/#__init__","title":"<code>__init__(m, extended=False)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>m</code> (<code>int</code>)         \u2013          <p>The redundancy $m$ of the code. Must satisfy $m \\geq 2$.</p> </li> <li> <code>extended</code> (<code>Optional[bool]</code>)         \u2013          <p>If <code>True</code>, constructs the code in extended version. The default value is <code>False</code>.</p> </li> </ul>"},{"location":"ref/HuffmanCode/","title":"komm.HuffmanCode","text":"<p>         Bases: <code>FixedToVariableCode</code></p> <p>Huffman code. It is an optimal (minimal expected rate) fixed-to-variable length code for a given probability mass function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.HuffmanCode([0.7, 0.15, 0.15])\n&gt;&gt;&gt; pprint(code.enc_mapping)\n{(0,): (0,), (1,): (1, 1), (2,): (1, 0)}\n</code></pre> <pre><code>&gt;&gt;&gt; code = komm.HuffmanCode([0.7, 0.15, 0.15], source_block_size=2)\n&gt;&gt;&gt; pprint(code.enc_mapping)\n{(0, 0): (1,),\n (0, 1): (0, 0, 0, 0),\n (0, 2): (0, 1, 1),\n (1, 0): (0, 1, 0),\n (1, 1): (0, 0, 0, 1, 1, 1),\n (1, 2): (0, 0, 0, 1, 1, 0),\n (2, 0): (0, 0, 1),\n (2, 1): (0, 0, 0, 1, 0, 1),\n (2, 2): (0, 0, 0, 1, 0, 0)}\n</code></pre>"},{"location":"ref/HuffmanCode/#__init__","title":"<code>__init__(pmf, source_block_size=1, policy='high')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The probability mass function used to construct the code.</p> </li> <li> <code>source_block_size</code> (<code>Optional[int]</code>)         \u2013          <p>The source block size $k$. The default value is $k = 1$.</p> </li> <li> <code>policy</code> (<code>Optional[str]</code>)         \u2013          <p>The policy to be used when constructing the code. It must be either <code>'high'</code> (move combined symbols as high as possible) or <code>'low'</code> (move combined symbols as low as possible). The default value is <code>'high'</code>.</p> </li> </ul>"},{"location":"ref/HuffmanCode/#komm._source_coding.HuffmanCode.HuffmanCode.pmf","title":"<code>pmf</code>  <code>property</code>","text":"<p>The probability mass function used to construct the code.</p>"},{"location":"ref/KasamiSequence/","title":"komm.KasamiSequence","text":"<p>         Bases: <code>BinarySequence</code></p> <p>Kasami sequence [Not implemented yet].</p>"},{"location":"ref/LFSRSequence/","title":"komm.LFSRSequence","text":"<p>         Bases: <code>BinarySequence</code></p> <p>Linear-feedback shift register (LFSR) sequence. It is a binary sequence obtained from the output of a LFSR. The LFSR feedback taps are specified as a binary polynomial $p(X)$ of degree $n$, called the feedback polynomial. More specifically: if bit $i$ of the LFSR is tapped, for $i \\in [1 : n]$, then the coefficient of $X^i$ in $p(X)$ is $1$; otherwise, it is $0$; moreover, the coefficient of $X^0$ in $p(X)$ is always $1$. For example, the feedback polynomial corresponding to the LFSR in the figure below is $p(X) = X^5 + X^2 + 1$, whose integer representation is <code>0b100101</code>.</p> <p></p> <p>The start state of the machine is specified by the so called start state polynomial. More specifically, the coefficient of $X^i$ in the start state polynomial is equal to the initial value of bit $i$ of the LFSR.</p> Maximum-length sequences <p>If the feedback polynomial $p(X)$ is primitive, then the corresponding LFSR sequence will be a maximum-length sequence (MLS). Such sequences have the following cyclic autocorrelation: $$     R[\\ell] =     \\begin{cases}         L, &amp; \\ell = 0, \\, \\pm L, \\, \\pm 2L, \\ldots, \\\\         -1, &amp; \\text{otherwise},     \\end{cases} $$ where $L$ is the length of the sequence.</p> References <ol> <li>https://en.wikipedia.org/wiki/Linear-feedback_shift_register</li> <li>https://en.wikipedia.org/wiki/Maximum_length_sequence</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lfsr = komm.LFSRSequence(feedback_polynomial=0b100101)\n&gt;&gt;&gt; lfsr.bit_sequence\narray([0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1])\n&gt;&gt;&gt; lfsr.cyclic_autocorrelation()\narray([31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])\n</code></pre>"},{"location":"ref/LFSRSequence/#__init__","title":"<code>__init__(feedback_polynomial, start_state_polynomial=1)</code>","text":"<p>Default constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>feedback_polynomial</code> (<code>BinaryPolynomial | int</code>)         \u2013          <p>The feedback polynomial of the LFSR, specified either as a binary polynomial or as an integer to be converted to the former.</p> </li> <li> <code>start_state_polynomial</code> (<code>Optional[BinaryPolynomial | int]</code>)         \u2013          <p>The start state polynomial of the LFSR, specified either as a binary polynomial or as an integer to be converted to the former. The default value is <code>0b1</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.LFSRSequence(feedback_polynomial=0b10011)\nLFSRSequence(feedback_polynomial=0b10011)\n</code></pre> <p>See also the class method <code>maximum_length_sequence</code> for a more convenient way to construct a maximum-length sequence.</p>"},{"location":"ref/LFSRSequence/#maximum_length_sequence","title":"<code>maximum_length_sequence(degree, start_state_polynomial=1)</code>  <code>classmethod</code>","text":"<p>Constructs a maximum-length sequences (MLS) of a given degree. The feedback polynomial $p(X)$ is chosen according to the following table of primitive polynomials.</p> Degree $n$ Feedback polynomial $p(X)$ Degree $n$ Feedback polynomial $p(X)$ $1$ <code>0b11</code> $9$ <code>0b1000010001</code> $2$ <code>0b111</code> $10$ <code>0b10000001001</code> $3$ <code>0b1011</code> $11$ <code>0b100000000101</code> $4$ <code>0b10011</code> $12$ <code>0b1000001010011</code> $5$ <code>0b100101</code> $13$ <code>0b10000000011011</code> $6$ <code>0b1000011</code> $14$ <code>0b100010001000011</code> $7$ <code>0b10001001</code> $15$ <code>0b1000000000000011</code> $8$ <code>0b100011101</code> $16$ <code>0b10001000000001011</code> <p>Parameters:</p> <ul> <li> <code>degree</code> (<code>int</code>)         \u2013          <p>The degree $n$ of the MLS. Only degrees in the range $[1 : 16]$ are implemented.</p> </li> <li> <code>start_state_polynomial</code> (<code>Optional[BinaryPolynomial | int]</code>)         \u2013          <p>See the corresponding parameter of the default constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.LFSRSequence.maximum_length_sequence(degree=4)\nLFSRSequence(feedback_polynomial=0b10011)\n</code></pre>"},{"location":"ref/LFSRSequence/#komm._sequences.LFSRSequence.LFSRSequence.feedback_polynomial","title":"<code>feedback_polynomial</code>  <code>property</code>","text":"<p>The feedback polynomial $p(X)$ of the LFSR.</p>"},{"location":"ref/LFSRSequence/#komm._sequences.LFSRSequence.LFSRSequence.start_state_polynomial","title":"<code>start_state_polynomial</code>  <code>property</code>","text":"<p>The start state polynomial of the LFSR.</p>"},{"location":"ref/LloydMaxQuantizer/","title":"komm.LloydMaxQuantizer","text":"<p>         Bases: <code>ScalarQuantizer</code></p> <p>Lloyd\u2013Max scalar quantizer [Not implemented yet].</p>"},{"location":"ref/ManchesterPulse/","title":"komm.ManchesterPulse","text":"<p>         Bases: <code>FormattingPulse</code></p> <p>Manchester pulse. It is a formatting pulse with impulse response given by $$     h(t) =     \\begin{cases}         -1, &amp; 0 \\leq t &lt;  1/2, \\\\         1, &amp; 1/2 \\leq t &lt; 1, \\\\         0, &amp; \\text{otherwise}.     \\end{cases} $$ The Manchester pulse is depicted below.</p> <p></p>"},{"location":"ref/ManchesterPulse/#__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the class. It expects no parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.ManchesterPulse()\n</code></pre>"},{"location":"ref/PAModulation/","title":"komm.PAModulation","text":"<p>         Bases: <code>RealModulation</code></p> <p>Pulse-amplitude modulation (PAM). It is a real modulation scheme in which the points of the constellation $\\mathcal{S}$ are uniformly arranged in the real line. More precisely, $$     \\mathcal{S} = \\{ \\pm (2i + 1)A : i \\in [0 : M) \\}, $$ where $M$ is the order (a power of $2$), and $A$ is the base amplitude. The PAM constellation is depicted below for $M = 8$.</p> <p></p>"},{"location":"ref/PAModulation/#__init__","title":"<code>__init__(order, base_amplitude=1.0, labeling='reflected')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>order</code> (<code>int</code>)         \u2013          <p>The order $M$ of the modulation. It must be a power of $2$.</p> </li> <li> <code>base_amplitude</code> (<code>Optional[float]</code>)         \u2013          <p>The base amplitude $A$ of the constellation. The default value is <code>1.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling $\\mathcal{Q}$ of the modulation. Can be specified either as a 1D-array of integers, in which case must be permutation of $[0 : M)$, or as a string, in which case must be one of <code>'natural'</code> or <code>'reflected'</code>. The default value is <code>'reflected'</code> (Gray code).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pam = komm.PAModulation(4, base_amplitude=2.0)\n&gt;&gt;&gt; pam.constellation\narray([-6., -2.,  2.,  6.])\n&gt;&gt;&gt; pam.labeling\narray([0, 1, 3, 2])\n&gt;&gt;&gt; pam.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([-6.,  2., -6., -2., -2.])\n</code></pre>"},{"location":"ref/PSKModulation/","title":"komm.PSKModulation","text":"<p>         Bases: <code>ComplexModulation</code></p> <p>Phase-shift keying (PSK) modulation. It is a complex modulation scheme in which the points of the constellation $\\mathcal{S}$ are uniformly arranged in a circle. More precisely, $$     \\mathcal{S} = \\left \\{ A \\exp \\left( \\mathrm{j} \\frac{2 \\pi i}{M} \\right) \\exp(\\mathrm{j} \\phi) : i \\in [0 : M) \\right \\} $$ where $M$ is the order (a power of $2$), $A$ is the amplitude, and $\\phi$ is the phase offset of the modulation. The PSK constellation is depicted below for $M = 8$.</p> <p></p>"},{"location":"ref/PSKModulation/#__init__","title":"<code>__init__(order, amplitude=1.0, phase_offset=0.0, labeling='reflected')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>order</code> (<code>int</code>)         \u2013          <p>The order $M$ of the modulation. It must be a power of $2$.</p> </li> <li> <code>amplitude</code> (<code>Optional[float]</code>)         \u2013          <p>The amplitude $A$ of the constellation. The default value is <code>1.0</code>.</p> </li> <li> <code>phase_offset</code> (<code>Optional[float]</code>)         \u2013          <p>The phase offset $\\phi$ of the constellation. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling $\\mathcal{Q}$ of the modulation. Can be specified either as a 1D-array of integers, in which case must be permutation of $[0 : M)$, or as a string, in which case must be one of <code>'natural'</code> or <code>'reflected'</code>. The default value is <code>'reflected'</code> (Gray code).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psk = komm.PSKModulation(4, phase_offset=np.pi/4)\n&gt;&gt;&gt; psk.constellation\narray([ 0.70710678+0.70710678j, -0.70710678+0.70710678j, -0.70710678-0.70710678j,  0.70710678-0.70710678j])\n&gt;&gt;&gt; psk.labeling\narray([0, 1, 3, 2])\n&gt;&gt;&gt; psk.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([ 0.70710678+0.70710678j, -0.70710678-0.70710678j,  0.70710678+0.70710678j, -0.70710678+0.70710678j, -0.70710678+0.70710678j])\n</code></pre>"},{"location":"ref/QAModulation/","title":"komm.QAModulation","text":"<p>         Bases: <code>ComplexModulation</code></p> <p>Quadrature-amplitude modulation (QAM). It is a complex modulation scheme in which the constellation $\\mathcal{S}$ is given as a Cartesian product of two PAM constellations, namely, the in-phase constellation, and the quadrature constellation. More precisely, $$     \\mathcal{S} = \\{ [\\pm(2i_\\mathrm{I} + 1)A_\\mathrm{I} \\pm \\mathrm{j}(2i_\\mathrm{Q} + 1)A_\\mathrm{Q}] \\exp(\\mathrm{j}\\phi) : i_\\mathrm{I} \\in [0 : M_\\mathrm{I}), i_\\mathrm{Q} \\in [0 : M_\\mathrm{Q}) \\}, $$ where $M_\\mathrm{I}$ and $M_\\mathrm{Q}$ are the orders (powers of $2$), and $A_\\mathrm{I}$ and $A_\\mathrm{Q}$ are the base amplitudes of the in-phase and quadrature constellations, respectively. Also, $\\phi$ is the phase offset. The size of the resulting complex-valued constellation is $M = M_\\mathrm{I} M_\\mathrm{Q}$, a power of $2$. The QAM constellation is depicted below for $(M_\\mathrm{I}, M_\\mathrm{Q}) = (4, 4)$ with $A_\\mathrm{I} = A_\\mathrm{Q} = A$, and for $(M_\\mathrm{I}, M_\\mathrm{Q}) = (4, 2)$ with $A_\\mathrm{I} = A$ and $A_\\mathrm{Q} = 2A$; in both cases, $\\phi = 0$.</p> <p> </p>"},{"location":"ref/QAModulation/#__init__","title":"<code>__init__(orders, base_amplitudes=1.0, phase_offset=0.0, labeling='reflected_2d')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>orders</code> (<code>Tuple(int, int) | int</code>)         \u2013          <p>A tuple $(M_\\mathrm{I}, M_\\mathrm{Q})$ with the orders of the in-phase and quadrature constellations, respectively; both $M_\\mathrm{I}$ and $M_\\mathrm{Q}$ must be powers of $2$. If specified as a single integer $M$, then it is assumed that $M_\\mathrm{I} = M_\\mathrm{Q} = \\sqrt{M}$; in this case, $M$ must be an square power of $2$.</p> </li> <li> <code>base_amplitudes</code> (<code>Optional[Tuple(float, float) | float]</code>)         \u2013          <p>A tuple $(A_\\mathrm{I}, A_\\mathrm{Q})$ with the base amplitudes of the in-phase and quadrature constellations, respectively.  If specified as a single float $A$, then it is assumed that $A_\\mathrm{I} = A_\\mathrm{Q} = A$. The default value is $1.0$.</p> </li> <li> <code>phase_offset</code> (<code>Optional[float]</code>)         \u2013          <p>The phase offset $\\phi$ of the constellation. The default value is <code>0.0</code>.</p> </li> <li> <code>labeling</code> (<code>Optional[Array1D[int] | str]</code>)         \u2013          <p>The binary labeling $\\mathcal{Q}$ of the modulation. Can be specified either as a 1D-array of integers, in which case must be permutation of $[0 : M)$, or as a string, in which case must be one of <code>'natural'</code> or <code>'reflected_2d'</code>. The default value is <code>'reflected_2d'</code> (Gray code).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qam = komm.QAModulation(16)\n&gt;&gt;&gt; qam.constellation\narray([-3.-3.j, -1.-3.j,  1.-3.j,  3.-3.j,\n       -3.-1.j, -1.-1.j,  1.-1.j,  3.-1.j,\n       -3.+1.j, -1.+1.j,  1.+1.j,  3.+1.j,\n       -3.+3.j, -1.+3.j,  1.+3.j,  3.+3.j])\n&gt;&gt;&gt; qam.labeling\narray([ 0,  1,  3,  2,  4,  5,  7,  6, 12, 13, 15, 14,  8,  9, 11, 10])\n&gt;&gt;&gt; qam.modulate([0, 0, 1, 1, 0, 0, 1, 0])\narray([-3.+1.j, -3.-1.j])\n</code></pre> <pre><code>&gt;&gt;&gt; qam = komm.QAModulation(orders=(4, 2), base_amplitudes=(1.0, 2.0))\n&gt;&gt;&gt; qam.constellation\narray([-3.-2.j, -1.-2.j,  1.-2.j,  3.-2.j, -3.+2.j, -1.+2.j,  1.+2.j,  3.+2.j])\n&gt;&gt;&gt; qam.labeling\narray([0, 1, 3, 2, 4, 5, 7, 6])\n&gt;&gt;&gt; qam.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1])\narray([-3.+2.j, -1.-2.j, -1.+2.j])\n</code></pre>"},{"location":"ref/RaisedCosinePulse/","title":"komm.RaisedCosinePulse","text":"<p>         Bases: <code>FormattingPulse</code></p> <p>Raised cosine pulse. It is a formatting pulse with impulse response given by $$     h(t) = \\operatorname{sinc}(t) \\frac{\\cos(\\pi \\alpha t)}{1 - (2 \\alpha t)^2}, $$ where $\\alpha$ is the roll-off factor. The raised cosine pulse is depicted below for $\\alpha = 0.25$, and for $\\alpha = 0.75$.</p> <p> </p> <p>For  $\\alpha = 0$, the raised cosine pulse reduces to the sinc pulse.</p>"},{"location":"ref/RaisedCosinePulse/#__init__","title":"<code>__init__(rolloff, length_in_symbols)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>rolloff</code> (<code>float</code>)         \u2013          <p>The roll-off factor $\\alpha$ of the pulse. Must satisfy $0 \\leq \\alpha \\leq 1$.</p> </li> <li> <code>length_in_symbols</code> (<code>int</code>)         \u2013          <p>The length (span) of the truncated impulse response, in symbols.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RaisedCosinePulse(rolloff=0.25, length_in_symbols=16)\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.RaisedCosinePulse(rolloff=0.75, length_in_symbols=16)\n</code></pre>"},{"location":"ref/RaisedCosinePulse/#komm._pulses.RaisedCosinePulse.RaisedCosinePulse.rolloff","title":"<code>rolloff</code>  <code>property</code>","text":"<p>The roll-off factor $\\alpha$ of the pulse.</p>"},{"location":"ref/RaisedCosinePulse/#komm._pulses.RaisedCosinePulse.RaisedCosinePulse.length_in_symbols","title":"<code>length_in_symbols</code>  <code>property</code>","text":"<p>The length (span) of the truncated impulse response.</p>"},{"location":"ref/RationalPolynomial/","title":"komm.RationalPolynomial","text":"<p>Rational polynomial. A rational polynomial is a polynomial whose coefficients are all rational numbers. This class supports addition, subtraction, multiplication, division, and exponentiation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly1 = komm.RationalPolynomial(['1/2', '0', '3'])  # 1/2 + 3 X^2\n&gt;&gt;&gt; poly1\nRationalPolynomial(['1/2', '0', '3'])\n&gt;&gt;&gt; poly2 = komm.RationalPolynomial(['1/3', '2/3'])  # 1/3 + (2/3) X\n&gt;&gt;&gt; poly2\nRationalPolynomial(['1/3', '2/3'])\n&gt;&gt;&gt; poly1 + poly2  # 5/6 + (2/3) X + 3 X^2\nRationalPolynomial(['5/6', '2/3', '3'])\n&gt;&gt;&gt; poly1 * poly2  # 1/6 + (1/3) X + X^2 + 2 X^3\nRationalPolynomial(['1/6', '1/3', '1', '2'])\n</code></pre>"},{"location":"ref/RationalPolynomial/#__init__","title":"<code>__init__(coefficients)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>coefficients</code> (<code>Array1D[int | str | Fraction]</code>)         \u2013          <p>The coefficients of the rational polynomial\u2014the $i$-th element of the array standing for the coefficient of $X^i$. For example, <code>['1/2', '0', '3']</code> represents the rational polynomial $1/2 + 3 X^2$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.RationalPolynomial(['1/2', '0', '3'])  # 1/2 + 3 X^2\nRationalPolynomial(['1/2', '0', '3'])\n</code></pre>"},{"location":"ref/RationalPolynomial/#monomial","title":"<code>monomial(degree, coefficient=1)</code>  <code>classmethod</code>","text":"<p>Constructs a monomial. This is an polynomial of the form $cX^d$.</p> <p>Parameters:</p> <ul> <li> <code>degree</code> (<code>int</code>)         \u2013          <p>The degree $d$ of the monomial.</p> </li> <li> <code>coefficient</code> (<code>Optional[int]</code>)         \u2013          <p>The coefficient $c$ of the monomial. The default value is $1$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.RationalPolynomial.monomial(4, 2)  # 2 X^4\nRationalPolynomial(['0', '0', '0', '0', '2'])\n</code></pre>"},{"location":"ref/RationalPolynomial/#coefficients","title":"<code>coefficients(width=None)</code>","text":"<p>Returns the coefficients of the polynomial.</p> <p>Parameters:</p> <ul> <li> <code>width</code> (<code>Optional[int]</code>)         \u2013          <p>If this parameter is specified, the output will be filled with zeros on the right so that the its length will be the specified value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>coefficients</code>  (<code>Array1D[int]</code>)          \u2013          <p>Coefficients of the polynomial. The $i$-th element of the array stands for the coefficient of $X^i$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.RationalPolynomial(['0', '1/3', '2/3'])  # (1/3) X + (2/3) X^2\n&gt;&gt;&gt; poly.coefficients()\narray([Fraction(0, 1), Fraction(1, 3), Fraction(2, 3)], dtype=object)\n&gt;&gt;&gt; poly.coefficients(width=5)\narray([Fraction(0, 1), Fraction(1, 3), Fraction(2, 3), Fraction(0, 1), Fraction(0, 1)], dtype=object)\n</code></pre>"},{"location":"ref/RationalPolynomial/#komm._algebra.RationalPolynomial.RationalPolynomial.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>The degree of the polynomial.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.RationalPolynomial([1, 0, 3])  # 1 + 3 X^2\n&gt;&gt;&gt; poly.degree\n2\n</code></pre>"},{"location":"ref/RationalPolynomial/#evaluate","title":"<code>evaluate(point)</code>","text":"<p>Evaluates the polynomial at a given point. Uses Horner's method.</p> <p>Parameters:</p> <ul> <li> <code>point</code> (<code>RingElement</code>)         \u2013          <p>Any Python object supporting the operations of addition, subtraction, and multiplication.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>result</code>  (<code>RingElement</code>)          \u2013          <p>The result of evaluating the binary polynomial at <code>point</code>. It has the same type as <code>point</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = komm.RationalPolynomial([0, 1, 0, -1, 2])  # X - X^3 + 2 X^4\n&gt;&gt;&gt; poly.evaluate(7)  # same as 7 - 7**3 + 2 * 7**4\nFraction(4466, 1)\n&gt;&gt;&gt; point = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; poly.evaluate(point)  # same as point - point**3 + 2 * point**4\narray([[Fraction(2, 1), Fraction(26, 1)],\n       [Fraction(138, 1), Fraction(452, 1)]], dtype=object)\n</code></pre>"},{"location":"ref/RationalPolynomial/#gcd","title":"<code>gcd(*poly_list)</code>  <code>classmethod</code>","text":"<p>Computes the greatest common divisor (gcd) of the arguments.</p>"},{"location":"ref/RationalPolynomial/#lcm","title":"<code>lcm(*poly_list)</code>  <code>classmethod</code>","text":"<p>Computes the least common multiple (lcm) of the arguments.</p>"},{"location":"ref/RationalPolynomialFraction/","title":"komm.RationalPolynomialFraction","text":"<p>Rational polynomial fraction. A rational polynomial fraction is a ratio of two rational polynomials.</p>"},{"location":"ref/RationalPolynomialFraction/#komm._algebra.RationalPolynomialFraction.RationalPolynomialFraction.numerator","title":"<code>numerator</code>  <code>property</code>","text":"<p>The numerator of the fraction.</p>"},{"location":"ref/RationalPolynomialFraction/#komm._algebra.RationalPolynomialFraction.RationalPolynomialFraction.denominator","title":"<code>denominator</code>  <code>property</code>","text":"<p>The denominator of the fraction.</p>"},{"location":"ref/RationalPolynomialFraction/#inverse","title":"<code>inverse()</code>","text":"<p>Returns the multiplicative inverse the fraction.</p>"},{"location":"ref/RealModulation/","title":"komm.RealModulation","text":"<p>         Bases: <code>Modulation</code></p> <p>General real modulation scheme. A real modulation scheme of order $M$ is defined by a constellation $\\mathcal{S}$, which is an ordered subset (a list) of real numbers, with $|\\mathcal{S}| = M$, and a binary labeling $\\mathcal{Q}$, which is a permutation of $[0: M)$. The order $M$ of the modulation must be a power of $2$.</p>"},{"location":"ref/RealModulation/#__init__","title":"<code>__init__(constellation, labeling)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>constellation</code> (<code>Array1D[float]</code>)         \u2013          <p>The constellation $\\mathcal{S}$ of the modulation. Must be a 1D-array containing $M$ real numbers.</p> </li> <li> <code>labeling</code> (<code>Array1D[int]</code>)         \u2013          <p>The binary labeling $\\mathcal{Q}$ of the modulation. Must be a 1D-array of integers corresponding to a permutation of $[0 : M)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mod = komm.RealModulation(constellation=[-0.5, 0, 0.5, 2], labeling=[0, 1, 3, 2])\n&gt;&gt;&gt; mod.constellation\narray([-0.5,  0. ,  0.5,  2. ])\n&gt;&gt;&gt; mod.modulate([0, 0, 1, 1, 0, 0, 1, 0, 1, 0])\narray([-0.5,  0.5, -0.5,  0. ,  0. ])\n</code></pre>"},{"location":"ref/ReceiveFilter/","title":"komm.ReceiveFilter","text":"<p>Receive filter [Not implemented yet].</p>"},{"location":"ref/RectangularPulse/","title":"komm.RectangularPulse","text":"<p>         Bases: <code>FormattingPulse</code></p> <p>Rectangular pulse. It is a formatting pulse with impulse response given by $$     h(t) =     \\begin{cases}         1, &amp; 0 \\leq t &lt; w, \\\\         0, &amp; \\text{otherwise}.     \\end{cases}, $$ where $w$ is the width of the pulse, which must satisfy $0 \\leq w \\leq 1$. The rectangular pulse is depicted below for $w = 1$ (called the NRZ pulse), and for $w = 0.5$ (called the halfway RZ pulse).</p> <p> </p>"},{"location":"ref/RectangularPulse/#__init__","title":"<code>__init__(width=1.0)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>width</code> (<code>Optional[float]</code>)         \u2013          <p>The width $w$ of the pulse. Must satisfy $0 \\leq w \\leq 1$. The default value is <code>1.0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(width=1.0)  # NRZ pulse\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.RectangularPulse(width=0.5)  # Halfway RZ pulse\n</code></pre>"},{"location":"ref/RectangularPulse/#komm._pulses.RectangularPulse.RectangularPulse.width","title":"<code>width</code>  <code>property</code>","text":"<p>The width $w$ of the pulse.</p>"},{"location":"ref/ReedMullerCode/","title":"komm.ReedMullerCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Reed\u2013Muller code. It is a linear block code defined by two integers $\\rho$ and $\\mu$, which must satisfy $0 \\leq \\rho &lt; \\mu$. See references for more details. The resulting code is denoted by $\\mathrm{RM}(\\rho, \\mu)$, and has the following parameters:</p> <ul> <li>Length: $n = 2^{\\mu}$</li> <li>Dimension: $k = 1 + {\\mu \\choose 1} + \\cdots + {\\mu \\choose \\rho}$</li> <li>Redundancy: $m = 1 + {\\mu \\choose 1} + \\cdots + {\\mu \\choose \\mu - \\rho - 1}$</li> <li>Minimum distance: $d = 2^{\\mu - \\rho}$</li> </ul> <p>For more details, see LC04, Sec. 4.3.</p> Notes <ul> <li>For $\\rho = 0$ it reduces to a repetition code.</li> <li>For $\\rho = 1$ it reduces to a lengthened simplex code.</li> <li>For $\\rho = \\mu - 2$ it reduces to an extended Hamming code.</li> <li>For $\\rho = \\mu - 1$ it reduces to a single parity check code.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.ReedMullerCode(1, 5)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(32, 6, 16)\n&gt;&gt;&gt; code.generator_matrix\narray([[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n       [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],\n       [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.encode([0, 0, 0, 0, 0, 1])\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n&gt;&gt;&gt; recvword = np.ones(32, dtype=int); recvword[[2, 10, 15, 16, 17, 19, 29]] = 0\n&gt;&gt;&gt; code.decode(recvword)\narray([0, 0, 0, 0, 0, 1])\n</code></pre>"},{"location":"ref/ReedMullerCode/#__init__","title":"<code>__init__(rho, mu)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>rho</code> (<code>int</code>)         \u2013          <p>The parameter $\\rho$ of the code.</p> </li> <li> <code>mu</code> (<code>int</code>)         \u2013          <p>The parameter $\\mu$ of the code.</p> </li> </ul> <p>The parameters must satisfy $0 \\leq \\rho &lt; \\mu$.</p>"},{"location":"ref/ReedMullerCode/#komm._error_control_block.ReedMullerCode.ReedMullerCode.rho","title":"<code>rho</code>  <code>property</code>","text":"<p>The parameter $\\rho$ of the code.</p>"},{"location":"ref/ReedMullerCode/#komm._error_control_block.ReedMullerCode.ReedMullerCode.mu","title":"<code>mu</code>  <code>property</code>","text":"<p>The parameter $\\mu$ of the code.</p>"},{"location":"ref/ReedMullerCode/#komm._error_control_block.ReedMullerCode.ReedMullerCode.reed_partitions","title":"<code>reed_partitions</code>  <code>cached</code> <code>property</code>","text":"<p>The Reed partitions of the code. See LC04, Sec. 4.3.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.ReedMullerCode(2, 4)\n&gt;&gt;&gt; code.reed_partitions[1]\narray([[ 0,  1,  4,  5],\n       [ 2,  3,  6,  7],\n       [ 8,  9, 12, 13],\n       [10, 11, 14, 15]])\n&gt;&gt;&gt; code.reed_partitions[8]\narray([[ 0,  4],\n       [ 1,  5],\n       [ 2,  6],\n       [ 3,  7],\n       [ 8, 12],\n       [ 9, 13],\n       [10, 14],\n       [11, 15]])\n</code></pre>"},{"location":"ref/RepetitionCode/","title":"komm.RepetitionCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Repetition code. For a given length $n$, it is the linear block code whose only two codewords are $00 \\cdots 0$ and $11 \\cdots 1$. The repetition code has the following parameters:</p> <ul> <li>Length: $n$</li> <li>Dimension: $k = 1$</li> <li>Minimum distance: $d = n$</li> </ul> Notes <ul> <li>Its dual is the single parity check code.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.RepetitionCode(5)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(5, 1, 5)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.parity_check_matrix\narray([[1, 1, 0, 0, 0],\n       [1, 0, 1, 0, 0],\n       [1, 0, 0, 1, 0],\n       [1, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.encode([1])\narray([1, 1, 1, 1, 1])\n&gt;&gt;&gt; code.decode([1, 0, 1, 0, 0])\narray([0])\n</code></pre>"},{"location":"ref/RepetitionCode/#__init__","title":"<code>__init__(n)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>n</code> (<code>int</code>)         \u2013          <p>The length $n$ of the code. Must be a positive integer.</p> </li> </ul>"},{"location":"ref/RootRaisedCosinePulse/","title":"komm.RootRaisedCosinePulse","text":"<p>         Bases: <code>FormattingPulse</code></p> <p>Root raised cosine pulse. It is a formatting pulse with impulse response given by $$     h(t) = \\frac{\\sin[\\pi (1 - \\alpha) t] + 4 \\alpha t \\cos[\\pi (1 + \\alpha) t]}{\\pi t [1 - (4 \\alpha t)^2]}, $$ where $\\alpha$ is the roll-off factor. The root raised cosine pulse is depicted below for $\\alpha = 0.25$, and for $\\alpha = 0.75$.</p> <p> </p>"},{"location":"ref/RootRaisedCosinePulse/#__init__","title":"<code>__init__(rolloff, length_in_symbols)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>rolloff</code> (<code>float</code>)         \u2013          <p>The roll-off factor $\\alpha$ of the pulse. Must satisfy $0 \\leq \\alpha \\leq 1$.</p> </li> <li> <code>length_in_symbols</code> (<code>int</code>)         \u2013          <p>The length (span) of the truncated impulse response, in symbols.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.RootRaisedCosinePulse(rolloff=0.25, length_in_symbols=16)\n</code></pre> <pre><code>&gt;&gt;&gt; pulse = komm.RootRaisedCosinePulse(rolloff=0.75, length_in_symbols=16)\n</code></pre>"},{"location":"ref/RootRaisedCosinePulse/#komm._pulses.RootRaisedCosinePulse.RootRaisedCosinePulse.rolloff","title":"<code>rolloff</code>  <code>property</code>","text":"<p>The roll-off factor $\\alpha$ of the pulse.</p>"},{"location":"ref/RootRaisedCosinePulse/#komm._pulses.RootRaisedCosinePulse.RootRaisedCosinePulse.length_in_symbols","title":"<code>length_in_symbols</code>  <code>property</code>","text":"<p>The length (span) of the truncated impulse response.</p>"},{"location":"ref/ScalarQuantizer/","title":"komm.ScalarQuantizer","text":"<p>General scalar quantizer. It is defined by a list of levels, $v_0, v_1, \\ldots, v_{L-1}$, and a list of thresholds, $t_0, t_1, \\ldots, t_L$, satisfying $$     -\\infty = t_0 &lt; v_0 &lt; t_1 &lt; v_1 &lt; \\cdots &lt; t_{L - 1} &lt; v_{L - 1} &lt; t_L = +\\infty. $$ Given an input $x \\in \\mathbb{R}$, the output of the quantizer is given by $y = v_i$ if and only if $t_i \\leq x &lt; t_{i+1}$, where $i \\in [0:L)$.</p> <p>To invoke the quantizer, call the object giving the input signal as parameter (see example in the constructor below).</p>"},{"location":"ref/ScalarQuantizer/#__init__","title":"<code>__init__(levels, thresholds)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>levels</code> (<code>Array1D[float]</code>)         \u2013          <p>The quantizer levels $v_0, v_1, \\ldots, v_{L-1}$. It should be a list floats of length $L$.</p> </li> <li> <code>thresholds</code> (<code>Array1D[float]</code>)         \u2013          <p>The finite quantizer thresholds $t_1, t_2, \\ldots, t_{L-1}$. It should be a list of floats of length $L - 1$. Moreover, they must satisfy $v_0 &lt; t_1 &lt; v_1 &lt; \\cdots &lt; t_{L - 1} &lt; v_{L - 1}$.</p> </li> </ul> <p>Examples:</p> <p>The following example considers the $5$-level scalar quantizer whose characteristic (input \u00d7 output) curve is depicted in the figure below.</p> <p></p> <p>The levels are $$     v_0 = -2, ~ v_1 = -1, ~ v_2 = 0, ~ v_3 = 1, ~ v_4 = 2, $$ and the thresholds are $$    t_0 = -\\infty, ~ t_1 = -1.5, ~ t_2 = -0.3, ~ t_3 = 0.8, ~ t_4 = 1.4, ~ t_5 = \\infty. $$</p> <pre><code>&gt;&gt;&gt; quantizer = komm.ScalarQuantizer(levels=[-2.0, -1.0, 0.0, 1.0, 2.0], thresholds=[-1.5, -0.3, 0.8, 1.4])\n&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, num=11)\n&gt;&gt;&gt; y = quantizer(x)\n&gt;&gt;&gt; np.vstack([x, y])\narray([[-2.5, -2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ,  2.5],\n       [-2. , -2. , -1. , -1. , -1. ,  0. ,  0. ,  1. ,  2. ,  2. ,  2. ]])\n</code></pre>"},{"location":"ref/ScalarQuantizer/#komm._quantization.ScalarQuantizer.ScalarQuantizer.levels","title":"<code>levels</code>  <code>property</code>","text":"<p>The quantizer levels $v_0, v_1, \\ldots, v_{L-1}$.</p>"},{"location":"ref/ScalarQuantizer/#komm._quantization.ScalarQuantizer.ScalarQuantizer.thresholds","title":"<code>thresholds</code>  <code>property</code>","text":"<p>The finite quantizer thresholds $t_1, t_2, \\ldots, t_{L-1}$.</p>"},{"location":"ref/ScalarQuantizer/#komm._quantization.ScalarQuantizer.ScalarQuantizer.num_levels","title":"<code>num_levels</code>  <code>property</code>","text":"<p>The number of quantization levels $L$.</p>"},{"location":"ref/SimplexCode/","title":"komm.SimplexCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Simplex (maximum-length) code. For a given dimension $k$, it is the linear block code with generator matrix whose columns are all the $2^k - 1$ nonzero binary $k$-tuples. The simplex code (also known as maximum-length code) has the following parameters:</p> <ul> <li>Length: $n = 2^k - 1$</li> <li>Dimension: $k$</li> <li>Redundancy: $m = 2^k - k - 1$</li> <li>Minimum distance: $d = 2^{k - 1}$</li> </ul> <p>This class constructs the code in systematic form, with the information set on the left.</p> Notes <ul> <li>For $k = 2$ it reduces to the single parity check code of length $3$.</li> <li>Its dual is the Hamming code.</li> <li>Simplex codes are constant-weight codes.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.SimplexCode(3)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(7, 3, 4)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 1, 1, 0, 1],\n       [0, 1, 0, 1, 0, 1, 1],\n       [0, 0, 1, 0, 1, 1, 1]])\n&gt;&gt;&gt; code.parity_check_matrix\narray([[1, 1, 0, 1, 0, 0, 0],\n       [1, 0, 1, 0, 1, 0, 0],\n       [0, 1, 1, 0, 0, 1, 0],\n       [1, 1, 1, 0, 0, 0, 1]])\n&gt;&gt;&gt; code.encode([1, 0, 1])\narray([1, 0, 1, 1, 0, 1, 0])\n&gt;&gt;&gt; code.decode([1, 0, 1, 1, 1, 1, 0])\narray([1, 0, 1])\n</code></pre>"},{"location":"ref/SimplexCode/#__init__","title":"<code>__init__(k)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>k</code> (<code>int</code>)         \u2013          <p>The dimension $k$ of the code. Must satisfy $k \\geq 2$.</p> </li> </ul>"},{"location":"ref/SincPulse/","title":"komm.SincPulse","text":"<p>         Bases: <code>FormattingPulse</code></p> <p>Sinc pulse. It is a formatting pulse with impulse response given by $$     h(t) = \\operatorname{sinc}(t) = \\frac{\\sin(\\pi t)}{\\pi t}. $$ The sinc pulse is depicted below.</p> <p></p>"},{"location":"ref/SincPulse/#__init__","title":"<code>__init__(length_in_symbols)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>length_in_symbols</code> (<code>int</code>)         \u2013          <p>The length (span) of the truncated impulse response, in symbols.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pulse = komm.SincPulse(length_in_symbols=64)\n</code></pre>"},{"location":"ref/SincPulse/#komm._pulses.SincPulse.SincPulse.length_in_symbols","title":"<code>length_in_symbols</code>  <code>property</code>","text":"<p>The length (span) of the truncated impulse response.</p>"},{"location":"ref/SingleParityCheckCode/","title":"komm.SingleParityCheckCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Single parity check code. For a given length $n$, it is the linear block code whose codewords are obtained by extending $n - 1$ information bits with a single parity-check bit. The repetition code has the following parameters:</p> <ul> <li>Length: $n$.</li> <li>Dimension: $k = n - 1$.</li> <li>Minimum distance: $d = 2$.</li> </ul> Notes <ul> <li>Its dual is the repetition code.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.SingleParityCheckCode(5)\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(5, 4, 2)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 0, 0, 0, 1],\n       [0, 1, 0, 0, 1],\n       [0, 0, 1, 0, 1],\n       [0, 0, 0, 1, 1]])\n&gt;&gt;&gt; code.parity_check_matrix\narray([[1, 1, 1, 1, 1]])\n&gt;&gt;&gt; code.encode([1, 0, 1, 1])\narray([1, 0, 1, 1, 1])\n</code></pre>"},{"location":"ref/SingleParityCheckCode/#__init__","title":"<code>__init__(n)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>n</code> (<code>int</code>)         \u2013          <p>The length $n$ of the code. Must be a positive integer.</p> </li> </ul>"},{"location":"ref/TerminatedConvolutionalCode/","title":"komm.TerminatedConvolutionalCode","text":"<p>         Bases: <code>BlockCode</code></p> <p>Terminated convolutional code. It is a linear block code obtained by terminating a $(n_0, k_0)$ convolutional code. A total of $h$ information blocks (each containing $k_0$ information bits) is encoded. The dimension of the resulting block code is thus $k = h k_0$; its length depends on the termination mode employed. There are three possible termination modes:</p> <ul> <li> <p>Direct truncation. The encoder always starts at state $0$, and its output ends immediately after the last information block. The encoder may not necessarily end in state $0$. The resulting block code will have length $n = h n_0$.</p> </li> <li> <p>Zero termination. The encoder always starts and ends at state $0$. To achieve this, a sequence of $k \\mu$ tail bits is appended to the information bits, where $\\mu$ is the memory order of the convolutional code. The resulting block code will have length $n = (h + \\mu) n_0$.</p> </li> <li> <p>Tail-biting. The encoder always starts and ends at the same state. To achieve this, the initial state of the encoder is chosen as a function of the information bits. The resulting block code will have length $n = h n_0$.</p> </li> </ul> <p>For more details, see LC04, Chs. 11, 12 and WBR01.</p>"},{"location":"ref/TerminatedConvolutionalCode/#__init__","title":"<code>__init__(convolutional_code, num_blocks, mode='zero-termination')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>convolutional_code</code> (<code>ConvolutionalCode</code>)         \u2013          <p>The convolutional code to be terminated.</p> </li> <li> <code>num_blocks</code> (<code>int</code>)         \u2013          <p>The number $h$ of information blocks.</p> </li> <li> <code>mode</code> (<code>Optional[str]</code>)         \u2013          <p>The termination mode. It must be one of <code>'direct-truncation'</code> | <code>'zero-termination'</code> | <code>'tail-biting'</code>. The default value is <code>'zero-termination'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0b1, 0b11]])\n&gt;&gt;&gt; code = komm.TerminatedConvolutionalCode(convolutional_code, num_blocks=3, mode='zero-termination')\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(8, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 0, 1, 0, 0, 0, 0],\n       [0, 0, 1, 1, 0, 1, 0, 0],\n       [0, 0, 0, 0, 1, 1, 0, 1]])\n</code></pre> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0b1, 0b11]])\n&gt;&gt;&gt; code = komm.TerminatedConvolutionalCode(convolutional_code, num_blocks=3, mode='direct-truncation')\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(6, 3, 2)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 0, 1, 0, 0],\n       [0, 0, 1, 1, 0, 1],\n       [0, 0, 0, 0, 1, 1]])\n</code></pre> <pre><code>&gt;&gt;&gt; convolutional_code = komm.ConvolutionalCode([[0b1, 0b11]])\n&gt;&gt;&gt; code = komm.TerminatedConvolutionalCode(convolutional_code, num_blocks=3, mode='tail-biting')\n&gt;&gt;&gt; (code.length, code.dimension, code.minimum_distance)\n(6, 3, 3)\n&gt;&gt;&gt; code.generator_matrix\narray([[1, 1, 0, 1, 0, 0],\n       [0, 0, 1, 1, 0, 1],\n       [0, 1, 0, 0, 1, 1]])\n</code></pre>"},{"location":"ref/TerminatedConvolutionalCode/#komm._error_control_convolutional.TerminatedConvolutionalCode.TerminatedConvolutionalCode.num_blocks","title":"<code>num_blocks</code>  <code>property</code>","text":"<p>The number $h$ of information blocks of the terminated convolutional code.</p>"},{"location":"ref/TerminatedConvolutionalCode/#komm._error_control_convolutional.TerminatedConvolutionalCode.TerminatedConvolutionalCode.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>The termination mode of the terminated convolutional code.</p>"},{"location":"ref/TransmitFilter/","title":"komm.TransmitFilter","text":"<p>Transmit filter.</p>"},{"location":"ref/TransmitFilter/#__init__","title":"<code>__init__(pulse, samples_per_symbol)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>pulse</code> (<code>FormattingPulse</code>)         \u2013          <p>The pulse filter.</p> </li> <li> <code>samples_per_symbol</code> (<code>int</code>)         \u2013          <p>The number of samples (of the output) per symbol (of the input).</p> </li> </ul>"},{"location":"ref/TransmitFilter/#komm._pulses.TransmitFilter.TransmitFilter.pulse","title":"<code>pulse</code>  <code>property</code>","text":"<p>The pulse filter.</p>"},{"location":"ref/TransmitFilter/#komm._pulses.TransmitFilter.TransmitFilter.samples_per_symbol","title":"<code>samples_per_symbol</code>  <code>property</code>","text":"<p>The number of samples per symbol.</p>"},{"location":"ref/TransmitFilter/#__call__","title":"<code>__call__(inp)</code>","text":"<p>Formats a sequence of symbols.</p> <p>Parameters:</p> <ul> <li> <code>inp</code> (<code>Array1D[float]</code>)         \u2013          <p>The input signal, containing symbols of a modulation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>outp</code>  (<code>Array1D[float]</code>)          \u2013          <p>The output signal, formatted.</p> </li> </ul>"},{"location":"ref/TunstallCode/","title":"komm.TunstallCode","text":"<p>         Bases: <code>VariableToFixedCode</code></p> <p>Tunstall code. It is an optimal (minimal expected rate) variable-to-fixed length code for a given probability mass function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.TunstallCode([0.6, 0.3, 0.1], code_block_size=3)\n&gt;&gt;&gt; pprint(code.enc_mapping)\n{(0, 0, 0): (0, 0, 0),\n (0, 0, 1): (0, 0, 1),\n (0, 0, 2): (0, 1, 0),\n (0, 1): (0, 1, 1),\n (0, 2): (1, 0, 0),\n (1,): (1, 0, 1),\n (2,): (1, 1, 0)}\n</code></pre>"},{"location":"ref/TunstallCode/#__init__","title":"<code>__init__(pmf, code_block_size)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The probability mass function used to construct the code.</p> </li> <li> <code>code_block_size</code> (<code>Optional[int]</code>)         \u2013          <p>The code block size $n$. Must satisfy $2^n \\geq |\\mathcal{X}|$, where $|\\mathcal{X}|$ is the cardinality of the source alphabet, given by <code>len(pmf)</code>.</p> </li> </ul>"},{"location":"ref/TunstallCode/#komm._source_coding.TunstallCode.TunstallCode.pmf","title":"<code>pmf</code>  <code>property</code>","text":"<p>The probability mass function used to construct the code.</p>"},{"location":"ref/UniformQuantizer/","title":"komm.UniformQuantizer","text":"<p>         Bases: <code>ScalarQuantizer</code></p> <p>Uniform scalar quantizer. It is a scalar quantizer in which the separation between levels is constant, $\\Delta$, and the thresholds are the mid-point between adjacent levels.</p>"},{"location":"ref/UniformQuantizer/#__init__","title":"<code>__init__(num_levels, input_peak=1.0, choice='mid-riser')</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>num_levels</code> (<code>int</code>)         \u2013          <p>The number of quantization levels $L$.</p> </li> <li> <code>input_peak</code> (<code>Optional[float]</code>)         \u2013          <p>The peak of the input signal $x_\\mathrm{p}$. The default value is <code>1.0</code>.</p> </li> <li> <code>choice</code> (<code>Optional[str]</code>)         \u2013          <p>The choice for the uniform quantizer. Must be one of <code>'unsigned'</code> | <code>'mid-riser'</code> | <code>'mid-tread'</code>. The default value is <code>'mid-riser'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; quantizer = komm.UniformQuantizer(num_levels=8)\n&gt;&gt;&gt; quantizer.levels\narray([-0.875, -0.625, -0.375, -0.125,  0.125,  0.375,  0.625,  0.875])\n&gt;&gt;&gt; quantizer.thresholds\narray([-0.75, -0.5 , -0.25,  0.  ,  0.25,  0.5 ,  0.75])\n&gt;&gt;&gt; x = np.linspace(-0.5, 0.5, num=11)\n&gt;&gt;&gt; y = quantizer(x)\n&gt;&gt;&gt; np.vstack([x, y])\narray([[-0.5  , -0.4  , -0.3  , -0.2  , -0.1  ,  0.   ,  0.1  ,  0.2  ,  0.3  ,  0.4  ,  0.5  ],\n       [-0.375, -0.375, -0.375, -0.125, -0.125,  0.125,  0.125,  0.125,  0.375,  0.375,  0.625]])\n</code></pre> <pre><code>&gt;&gt;&gt; quantizer = komm.UniformQuantizer(num_levels=4, input_peak=1.0, choice='unsigned')\n&gt;&gt;&gt; quantizer.levels\narray([0.  , 0.25, 0.5 , 0.75])\n&gt;&gt;&gt; quantizer.thresholds\narray([0.125, 0.375, 0.625])\n</code></pre> <pre><code>&gt;&gt;&gt; quantizer = komm.UniformQuantizer(num_levels=4, input_peak=1.0, choice='mid-riser')\n&gt;&gt;&gt; quantizer.levels\narray([-0.75, -0.25,  0.25,  0.75])\n&gt;&gt;&gt; quantizer.thresholds\narray([-0.5,  0. ,  0.5])\n</code></pre> <pre><code>&gt;&gt;&gt; quantizer = komm.UniformQuantizer(num_levels=4, input_peak=1.0, choice='mid-tread')\n&gt;&gt;&gt; quantizer.levels\narray([-1. , -0.5,  0. ,  0.5])\n&gt;&gt;&gt; quantizer.thresholds\narray([-0.75, -0.25,  0.25])\n</code></pre>"},{"location":"ref/UniformQuantizer/#komm._quantization.UniformQuantizer.UniformQuantizer.quantization_step","title":"<code>quantization_step</code>  <code>property</code>","text":"<p>The quantization step $\\Delta$.</p>"},{"location":"ref/UniformQuantizer/#komm._quantization.UniformQuantizer.UniformQuantizer.input_peak","title":"<code>input_peak</code>  <code>property</code>","text":"<p>The peak of the input signal $x_\\mathrm{p}$.</p>"},{"location":"ref/UniformQuantizer/#komm._quantization.UniformQuantizer.UniformQuantizer.choice","title":"<code>choice</code>  <code>property</code>","text":"<p>The choice for the uniform quantizer (<code>'unsigned'</code> | <code>'mid-riser'</code> | <code>'mid-tread'</code>).</p>"},{"location":"ref/VariableToFixedCode/","title":"komm.VariableToFixedCode","text":"<p>Binary, prefix-free, variable-to-fixed length code. Let $\\mathcal{X} = \\{0, 1, \\ldots, |\\mathcal{X} - 1| \\}$ be the alphabet of some discrete source. A binary variable-to-fixed length code of code block size $n$ is defined by a (possibly partial) decoding mapping $\\Dec : \\{ 0, 1 \\}^n \\to \\mathcal{X}^+$, where $\\mathcal{X}^+$ denotes the set of all finite-length, non-empty strings from the source alphabet. The elements in the image of $\\Dec$ are called sourcewords.</p> Warning <p>Only prefix-free codes are considered, in which no sourceword is a prefix of any other sourceword.</p>"},{"location":"ref/VariableToFixedCode/#__init__","title":"<code>__init__(sourcewords)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>sourcewords</code> (<code>List[Tuple[int]]</code>)         \u2013          <p>The sourcewords of the code. Must be a list of length at most $2^n$ containing tuples of integers in $\\mathcal{X}$. The tuple in position $i$ of <code>sourcewords</code> should be equal to $\\Dec(v)$, where $v$ is the $i$-th element in the lexicographic ordering of $\\{ 0, 1 \\}^n$.</p> </li> </ul> Note <p>The code block size $n$ and the source cardinality $|\\mathcal{X}|$ are inferred from <code>sourcewords</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode(sourcewords=[(1,), (2,), (0,1), (0,2), (0,0,0), (0,0,1), (0,0,2)])\n&gt;&gt;&gt; (code.source_cardinality, code.code_block_size)\n(3, 3)\n&gt;&gt;&gt; pprint(code.dec_mapping)\n{(0, 0, 0): (1,),\n (0, 0, 1): (2,),\n (0, 1, 0): (0, 1),\n (0, 1, 1): (0, 2),\n (1, 0, 0): (0, 0, 0),\n (1, 0, 1): (0, 0, 1),\n (1, 1, 0): (0, 0, 2)}\n&gt;&gt;&gt; pprint(code.enc_mapping)\n{(0, 0, 0): (1, 0, 0),\n (0, 0, 1): (1, 0, 1),\n (0, 0, 2): (1, 1, 0),\n (0, 1): (0, 1, 0),\n (0, 2): (0, 1, 1),\n (1,): (0, 0, 0),\n (2,): (0, 0, 1)}\n</code></pre>"},{"location":"ref/VariableToFixedCode/#komm._source_coding.VariableToFixedCode.VariableToFixedCode.source_cardinality","title":"<code>source_cardinality</code>  <code>property</code>","text":"<p>The cardinality $|\\mathcal{X}|$ of the source alphabet.</p>"},{"location":"ref/VariableToFixedCode/#komm._source_coding.VariableToFixedCode.VariableToFixedCode.code_block_size","title":"<code>code_block_size</code>  <code>property</code>","text":"<p>The code block size $n$.</p>"},{"location":"ref/VariableToFixedCode/#komm._source_coding.VariableToFixedCode.VariableToFixedCode.enc_mapping","title":"<code>enc_mapping</code>  <code>property</code>","text":"<p>The encoding mapping $\\Enc$ of the code.</p>"},{"location":"ref/VariableToFixedCode/#komm._source_coding.VariableToFixedCode.VariableToFixedCode.dec_mapping","title":"<code>dec_mapping</code>  <code>property</code>","text":"<p>The decoding mapping $\\Dec$ of the code.</p>"},{"location":"ref/VariableToFixedCode/#rate","title":"<code>rate(pmf)</code>","text":"<p>Computes the expected rate $R$ of the code, assuming a given pmf. This quantity is given by $$     R = \\frac{n}{\\bar{k}}, $$ where $n$ is the code block size, and $\\bar{k}$ is the expected sourceword length, assuming iid source symbols drawn from $p_X$. It is measured in bits per source symbol.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The (first-order) probability mass function $p_X$ to be assumed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rate</code>  (<code>float</code>)          \u2013          <p>The expected rate $R$ of the code.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode([(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; code.rate([2/3, 1/3])\n0.9473684210526315\n</code></pre>"},{"location":"ref/VariableToFixedCode/#encode","title":"<code>encode(symbol_sequence)</code>","text":"<p>Encodes a sequence of symbols to its corresponding sequence of bits.</p> <p>Parameters:</p> <ul> <li> <code>symbol_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of symbols to be encoded. Must be a 1D-array with elements in $\\mathcal{X} = \\{0, 1, \\ldots, |\\mathcal{X} - 1| \\}$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bit_sequence</code>  (<code>Array1D[int]</code>)          \u2013          <p>The sequence of bits corresponding to <code>symbol_sequence</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode([(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; code.encode([0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0])\narray([0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0])\n</code></pre>"},{"location":"ref/VariableToFixedCode/#decode","title":"<code>decode(bit_sequence)</code>","text":"<p>Decodes a sequence of bits to its corresponding sequence of symbols.</p> <p>Parameters:</p> <ul> <li> <code>bit_sequence</code> (<code>Array1D[int]</code>)         \u2013          <p>The sequence of bits to be decoded. Must be a 1D-array with elements in $\\{ 0, 1 \\}$.  Its length must be a multiple of $n$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>symbol_sequence</code>  (<code>Array1D[int]</code>)          \u2013          <p>The sequence of symbols corresponding to <code>bit_sequence</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; code = komm.VariableToFixedCode([(0,0,0), (0,0,1), (0,1), (1,)])\n&gt;&gt;&gt; code.decode([0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0])\narray([0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0])\n</code></pre>"},{"location":"ref/WalshHadamardSequence/","title":"komm.WalshHadamardSequence","text":"<p>         Bases: <code>BinarySequence</code></p> <p>Walsh\u2013Hadamard sequence. Consider the following recursive matrix construction: $$     H_1 =     \\begin{bmatrix}         +1     \\end{bmatrix}, \\qquad     H_{2^n} =     \\begin{bmatrix}         H_{2^{n-1}} &amp; H_{2^{n-1}} \\\\         H_{2^{n-1}} &amp; -H_{2^{n-1}}     \\end{bmatrix}, $$ for $n = 1, 2, \\ldots$. For example, for $n = 3$, $$     H_8 =     \\begin{bmatrix}         +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 \\\\         +1 &amp; +1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 \\\\     \\end{bmatrix} $$ The above matrix is said to be in natural ordering. If the rows of the matrix are rearranged by first applying the bit-reversal permutation and then the Gray-code permutation, the following matrix is obtained: $$     H_8^{\\mathrm{s}} =     \\begin{bmatrix}         +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 &amp; +1 \\\\         +1 &amp; +1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 \\\\         +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 \\\\         +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; +1 &amp; -1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 \\\\         +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 &amp; +1 &amp; -1 \\\\     \\end{bmatrix} $$ The above matrix is said to be in sequency ordering. It has the property that row $i$ has exactly $i$ signal changes.</p> <p>The Walsh\u2013Hadamard sequence of length $L$ and index $i \\in [0 : L)$ is a binary sequence whose polar format is the $i$-th row of $H_L$, if assuming natural ordering, or $H_L^{\\mathrm{s}}$, if assuming sequency ordering.</p> References <ol> <li>https://en.wikipedia.org/wiki/Hadamard_matrix</li> <li>https://en.wikipedia.org/wiki/Walsh_matrix</li> </ol>"},{"location":"ref/WalshHadamardSequence/#__init__","title":"<code>__init__(length, ordering='natural', index=0)</code>","text":"<p>Constructor for the class.</p> <p>Parameters:</p> <ul> <li> <code>length</code> (<code>int</code>)         \u2013          <p>Length $L$ of the Walsh\u2013Hadamard sequence. Must be a power of two.</p> </li> <li> <code>ordering</code> (<code>Optional[str]</code>)         \u2013          <p>Ordering to be assumed. Should be one of <code>'natural'</code>, <code>'sequency'</code>, or <code>'dyadic'</code>. The default value is <code>'natural'</code>.</p> </li> <li> <code>index</code> (<code>Optional[int]</code>)         \u2013          <p>Index of the Walsh\u2013Hadamard sequence, with respect to the ordering assumed. Must be in the set $[0 : L)$. The default value is <code>0</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; walsh_hadamard = komm.WalshHadamardSequence(length=64, ordering='sequency', index=60)\n&gt;&gt;&gt; walsh_hadamard.polar_sequence[:16]\narray([ 1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1])\n</code></pre> <pre><code>&gt;&gt;&gt; walsh_hadamard = komm.WalshHadamardSequence(length=128, ordering='natural', index=60)\n&gt;&gt;&gt; walsh_hadamard.polar_sequence[:16]\narray([ 1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1])\n</code></pre>"},{"location":"ref/WalshHadamardSequence/#komm._sequences.WalshHadamardSequence.WalshHadamardSequence.index","title":"<code>index</code>  <code>property</code>","text":"<p>The index of the Walsh\u2013Hadamard sequence, with respect to the ordering assumed.</p>"},{"location":"ref/WalshHadamardSequence/#komm._sequences.WalshHadamardSequence.WalshHadamardSequence.ordering","title":"<code>ordering</code>  <code>property</code>","text":"<p>The ordering assumed.</p>"},{"location":"ref/ZadoffChuSequence/","title":"komm.ZadoffChuSequence","text":"<p>Zadoff\u2013Chu sequence [Not implemented yet].</p>"},{"location":"ref/binlist2int/","title":"komm.binlist2int","text":"<p>Converts a bit array to its integer representation.</p> <p>Parameters:</p> <ul> <li> <code>binlist</code> (<code>List[int] | Array1D[int]</code>)         \u2013          <p>A list or array of $0$'s and $1$'s whose $i$-th element stands for the coefficient of $2^i$ in the binary representation of the output integer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>integer</code>  (<code>int</code>)          \u2013          <p>The integer representation of the input bit array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.binlist2int([0, 1, 0, 1, 1])\n26\n</code></pre> <pre><code>&gt;&gt;&gt; komm.binlist2int([0, 1, 0, 1, 1, 0, 0, 0])\n26\n</code></pre>"},{"location":"ref/entropy/","title":"komm.entropy","text":"<p>Computes the entropy of a random variable with a given pmf. Let $X$ be a random variable with pmf $p_X$ and alphabet $\\mathcal{X}$. Its entropy is given by $$     \\mathrm{H}(X) = \\sum_{x \\in \\mathcal{X}} p_X(x) \\log \\frac{1}{p_X(x)}. $$ By default, the base of the logarithm is $2$, in which case the entropy is measured in bits. For more details, see CT06, Ch. 2.</p> <p>Parameters:</p> <ul> <li> <code>pmf</code> (<code>Array1D[float]</code>)         \u2013          <p>The probability mass function $p_X$ of the random variable. It must be a valid pmf, that is, all of its values must be non-negative and sum up to $1$.</p> </li> <li> <code>base</code> (<code>Optional[float | str]</code>)         \u2013          <p>The base of the logarithm to be used. It must be a positive float or the string <code>'e'</code>. The default value is <code>2.0</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>entropy</code>  (<code>float</code>)          \u2013          <p>The entropy $\\mathrm{H}(X)$ of the random variable.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.entropy([1/4, 1/4, 1/4, 1/4])\n2.0\n</code></pre> <pre><code>&gt;&gt;&gt; komm.entropy([1/3, 1/3, 1/3], base=3.0)\n1.0\n</code></pre> <pre><code>&gt;&gt;&gt; komm.entropy([1.0, 1.0])\nTraceback (most recent call last):\n...\nValueError: Invalid pmf\n</code></pre>"},{"location":"ref/int2binlist/","title":"komm.int2binlist","text":"<p>Converts an integer to its bit array representation.</p> <p>Parameters:</p> <ul> <li> <code>integer</code> (<code>int</code>)         \u2013          <p>The input integer. May be any nonnegative integer.</p> </li> <li> <code>width</code> (<code>Optional[int]</code>)         \u2013          <p>If this parameter is specified, the output will be filled with zeros on the right so that its length will be the specified value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>binlist</code>  (<code>Array1D[int]</code>)          \u2013          <p>An array of $0$'s and $1$'s whose $i$-th element stands for the coefficient of $2^i$ in the binary representation of the input integer.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.int2binlist(26)\narray([0, 1, 0, 1, 1])\n</code></pre> <pre><code>&gt;&gt;&gt; komm.int2binlist(26, width=8)\narray([0, 1, 0, 1, 1, 0, 0, 0])\n</code></pre>"},{"location":"ref/pack/","title":"komm.pack","text":"<p>Packs a given integer array.</p>"},{"location":"ref/qfunc/","title":"komm.qfunc","text":"<p>Computes the Gaussian Q-function. It is given by $$     \\mathrm{Q}(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_x^\\infty \\mathrm{e}^{-u^2/2} \\, \\mathrm{d}u. $$</p> <p>Parameters:</p> <ul> <li> <code>x</code> (<code>float | ArrayND[float]</code>)         \u2013          <p>The input to the function. May be any float or array of floats.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>y</code>  (<code>SameAsInput</code>)          \u2013          <p>The value $y = \\mathrm{Q}(x)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.qfunc(0.0)\n0.5\n</code></pre> <pre><code>&gt;&gt;&gt; komm.qfunc([-1.0, 0.0, 1.0])\narray([0.84134475, 0.5       , 0.15865525])\n</code></pre>"},{"location":"ref/qfuncinv/","title":"komm.qfuncinv","text":"<p>Computes the inverse Gaussian Q-function.</p> <p>Parameters:</p> <ul> <li> <code>y</code> (<code>float | ArrayND[float]</code>)         \u2013          <p>The input to the function. Should be a float or array of floats in the real interval $[0, 1]$.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>x</code>  (<code>SameAsInput</code>)          \u2013          <p>The value $x = \\mathrm{Q^{-1}}(y)$.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; komm.qfuncinv(0.5)\n0.0\n</code></pre> <pre><code>&gt;&gt;&gt; komm.qfuncinv([0.841344746, 0.5, 0.158655254])\narray([-1., 0.,  1.])\n</code></pre>"},{"location":"ref/unpack/","title":"komm.unpack","text":"<p>Unpacks a given bit array.</p>"}]}